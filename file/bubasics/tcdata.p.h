/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 */
/*
 * HISTORY
 * $Log: tcdata.p.h,v $
 * Revision 1.1.83.1  1996/10/02  17:05:31  damon
 * 	Newest DFS from Transarc
 * 	[1996/10/01  18:05:20  damon]
 *
 * $EndLog$
 */
/*
 * (C) Copyright 1996, 1992 Transarc Corporation.
 * All Rights Reserved.
 */
/* $Header: /u0/rcs_trees/dce/rcs/file/bubasics/tcdata.p.h,v 1.1.83.1 1996/10/02 17:05:31 damon Exp $ */

#ifndef _BUBASICS_TCDATA_H
#define	_BUBASICS_TCDATA_H    1

#include <dcedfs/butc.h>
#include <dcedfs/budb.h>
#include <pthread.h>
#include <dcedfs/butm.h>
#include <dcedfs/lock.h>
#include <dcedfs/hyper.h>

/* node with info on each dump of interest, associated with dumpID
 * Key:
 * G - generated by butc
 */

struct dumpNode
{
    /* administrative fields */
    long dumpID;	/* G; really the job or task id */
    long realDumpId;	/* G; the actual dump id; not used */
    struct dumpNode *next;  /* pntr to the next node on the list */
    long status;	/* G; Free, Done, Abort, Error, InProgress etc */
    long creationTime;	/* G; time that the dumpNode was created */
    long timeWhenDone;	/* time when dump/restore op completed */
    osi_dlock_t lock;	/* the address of the lock is used as a cond */

    /* progress tracking of task - also local */
    long bytesDumped;			/* bytes dumped so far */
    afs_hyper_t volumeBeingDumped;		/* how to get this ? */
    long numVolErrs;	/* # of volumes that were processed & had errors */
    statusP statusNodePtr;		/* status node pointer */

    /* passed in from bucoord - common to dump/restore */
    int	opcode;	    		/* Dump, Restore or whatever */
    long arraySize; /* records the actual size of dump/restore array used*/
    char dumpSetName[TC_MAXNAMELEN];	/* name of the dump set to be used */

    /* specific to dumps */
    char *dumpName;			/* pathname of dump schedule node */
    char *volumeSetName;                /* volume set */
    struct tc_tapeSet tapeSetDesc;	/* description of the tape set */
    struct tc_dumpDesc *dumps;		/* list of vols to dump */
    long parent;			/* parent dump ID, from main call */
    long level;				/* this dump's level, from main call */

    /* restore specific */
    struct tc_restoreDesc *restores; 	/* info needed to restore volumes*/
    pthread_t pid;

    /* apparently unused */
    /* the stuff below is used to pass the parameters to a thread */
    long slotsUsed; /*size of  arrays used actually - no refs PA */
};

struct deviceSyncNode{
    osi_dlock_t deviceLock; /* serialize access to tape device */
    long flags;
};

#define TC_REFCOUNT	   2 	/* ref count on butc status nodes */
/* flags used to monitor status of dumps/restores */
#define	INPROGRESS 	0x01	/*dump is in progress */
#define	ABORT_FLAG	0x02	/*abort this dump */
#define	ABORTED		0x04	/*aborted this dump */
#define	DONE		0x08	/*done with this dump */
#define	TC_WAITING	0x10	/*someone is waiting on this dump */
#define	ERROR_FLAG	0x20	/*error in operation */
#define	PARTIAL	0x40	/*partial failure in operation */

#define	TC_GCTIME   300 /* the interval after which the GC is invoked */
#define	TC_ABORTTIME	30 /*time alotted for process to respond to  abort */

/*define some magic numbers to be used with volume headers and trailors on tape */
#define	TC_VOLBEGINMAGIC	0xb0258192  /*32 bit magic numbers */
#define	TC_VOLENDMAGIC		0x9167345b
#define	TC_VOLCONTD		0xffffffff
/*
#define	TC_HEADERFORMAT		"H++NAME#%s#ID#%u#SERVER#%x#PART#%u#FROM#%u#FRAG#%d#BM#%u#--H"
#define	TC_TRAILORFORMAT	"T--NAME#%s#ID#%u#SERVER#%x#PART#%u#FROM#%u#FRAG#%d#CONTD#%x#EM#%u#++T"
*/
#define TC_TRAILERBEGIN		"+=!@#$%><%$#@!=+"	/*indicates that trailer follows */
#define	TC_MAXTAPENAMELEN 100	/*dont know how to estimate these numbers */
#define	TC_ENDMARGIN	50000	/*if only this much space is left, we get another tape */
#define TC_KENDMARGIN   50	/*TC_ENDMARGIN/1000*/
#define TC_DEVICEINUSE 0x1000  	/* used to indicate use of device by somebody *
/

/*
 * These opcodes is made obsolete by the new set of opcodes in butc.idl
 * Awaiting cleanup 1/12/93
 */
/* define the opcodes */
#define	DUMP 0x01	/*dumping */
#define	RESTORE	0x02	/*restoring */

/* these status codes are used by Restorer */
#define TC_IN_NEWFS	0x01
#define TC_OUT_ERROR	0x02
#define TC_OUT_EOFS	0x04
#define TC_OUT_EOT	0x08

/* Database tape names */
#define	DUMP_TAPE_NAME	"bak_db_dump"		/* base name */

/* for user prompt generation */
#define READOPCODE  	0			/* read tape - for restore */
#define WRITEOPCODE 	1			/* write tape - for dump */
#define LABELOPCODE 	2			/* label a tape */
#define READLABELOPCODE 3			/* read tape label */
#define	SCANOPCODE	4			/* scan tape contents */
#define APPENDOPCODE    5                       /* append write tape - for dump */
#define SAVEDBOPCODE    6                       /* save a database tape */
#define RESTOREDBOPCODE 7                       /* restore a database tape */
#define CLOSEOPCODE     8                       /* close a tape drive - for callout */


/* marker used on tape. A header is placed (as a separate block) before the
 * volume data, and is appended (contiguously with the data) to the volume
 * data
 */
struct volumeHeader {
    char preamble[9];
    char postamble[9];
    char pad[6];				/* pad for 8-byte alignment */
    char volumeName[TC_MAXNAMELEN];
    dfsh_diskHyper_t volumeID;
    afsNetAddr server;				/* which server, NOT USED */
    long part;					/* partition vol. was on */
    long from;					/* clone date of vol ?? */
    int frag;
    long magic;					/* just for checking */
    long contd;
    char dumpSetName[TC_MAXNAMELEN];
    long dumpID;				/* ID of enclosing dump */
    long level;					/* dump level, 0=full */
    long parentID;				/* ID of parent dump */
    long endTime;
    long versionflags;				/* previously spare[0] */
    long cloneDate;				/* when this vol. was cloned */
    long spares[2];				/* spare used to be spare[4] */
};

/* Interface structure for STC_LabelTape  */

struct labelTapeIf
{
    struct tc_tapeLabel label;
    u_long taskId;
};

struct scanTapeIf
{
    long addDbFlag;
    u_long taskId;
};

/* handle for the ubik database connection */
typedef struct udbHandleS {
  struct ubik_client *uh_client;      	/* ubik client handle */
  u_long uh_instanceId;			/* instance of client */
  unsigned32 spare1;			/* nominal spares */
  unsigned32 spare2;			/* nominal spares */
  unsigned32 spare3;			/* nominal spares */
  unsigned32 spare4;			/* nominal spares */ 	
} udbHandleT, *udbHandleP;

typedef struct udbClientTextS {
    char *textName;			/* for info. only */
    long  textType;			/* used as key for access */
    u_long textVersion;			/* version # for cache mgmt */
    u_long lockHandle;			/* for atomicity */
    long textSize;			/* no. of bytes */
    FILE *textStream;			/* file stream or NULL */
    unsigned32 spare1;			/* nominal spares */
    unsigned32 spare2;			/* nominal spares */
    unsigned32 spare3;			/* nominal spares */
    unsigned32 spare4;			/* nominal spares */
} udbClientTextT, *udbClientTextP;

#endif	/* _BUBASICS_TCDATA_H */
