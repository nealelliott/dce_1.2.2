#!/bin/ksh
#
# @OSF_COPYRIGHT@
# COPYRIGHT NOTICE
# Copyright (c) 1990, 1991, 1992, 1993, 1996 Open Software Foundation, Inc.
# ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
# src directory for the full copyright text.
#
# HISTORY 
# $Log: dcetest_config,v $
# Revision 1.1.19.3  1996/03/11  02:38:47  marty
# 	Update OSF copyright years
# 	[1996/03/10  20:05:32  marty]
#
# Revision 1.1.19.2  1995/12/11  21:56:06  root
# 	Submit OSF/DCE 1.2.1
# 	[1995/12/11  20:55:57  root]
# 
# Revision 1.1.14.1  1994/10/19  20:30:06  rousseau
# 	Install dcecp and dced. (CR 12616).
# 	[1994/10/19  20:29:51  rousseau]
# 
# Revision 1.1.12.13  1994/09/27  17:49:57  fadden
# 	add install of dced systests
# 	[1994/09/27  17:11:05  fadden]
# 
# Revision 1.1.12.12  1994/08/17  17:41:57  bhaim
# 	fix for 11670
# 	[1994/08/17  17:41:08  bhaim]
# 
# Revision 1.1.12.11  1994/08/11  19:08:12  bhaim
# 	copy dlg_client stuff over to systest
# 	[1994/08/11  19:07:12  bhaim]
# 
# Revision 1.1.12.10  1994/06/22  16:40:51  hester
# 	added install of svc tests
# 	[1994/06/22  16:28:58  hester]
# 
# Revision 1.1.12.9  1994/06/02  16:26:50  zeliff
# 	Remove a typo
# 	[1994/06/02  15:58:33  zeliff]
# 
# 	ot10763: install_f_gds() - remove test/directory/xds
# 	[1994/06/02  15:53:10  zeliff]
# 
# Revision 1.1.12.8  1994/05/23  20:44:15  dassarma
# 	Added changes to install I18N tests.
# 	[1994/05/23  20:43:21  dassarma]
# 
# Revision 1.1.12.7  1994/05/18  21:18:13  zeliff
# 	Install xt_test tool
# 	[1994/05/15  20:09:07  zeliff]
# 
# 	OT10643: update for TETized gds FVT
# 	[1994/05/15  15:22:57  zeliff]
# 
# Revision 1.1.12.6  1994/05/09  22:29:01  pellis
# 	Deleted reference to dcethrp1.
# 	[1994/05/09  22:28:17  pellis]
# 
# Revision 1.1.12.5  1994/05/09  22:11:55  pellis
# 	Removed references to ropen and ropend.
# 	[1994/05/09  22:11:01  pellis]
# 
# Revision 1.1.12.4  1994/05/06  18:09:46  zeliff
# 	ot10565,10227: spiff up dcetest_config
# 	[1994/05/06  17:37:09  zeliff]
# 
# Revision 1.1.12.3  1994/04/21  15:54:16  tom
# 	Bug 10343 - Change dce1.0 to dce1.1.
# 	[1994/04/20  20:06:35  tom]
# 
# Revision 1.1.12.2  1994/04/18  19:56:15  zeliff
# 	ot10384: install audit FVT
# 	[1994/04/18  19:46:11  zeliff]
# 
# Revision 1.1.12.1  1994/03/18  14:38:10  bhaim
# 	Add audit system test menu item
# 	[1994/03/18  14:37:49  bhaim]
# 
# Revision 1.1.8.7  1993/10/29  19:05:26  cmckeen
# 	Removed the "Execute Test" and "Logging Functions" options.
# 	[1993/10/29  19:05:02  cmckeen]
# 
# Revision 1.1.8.6  1993/10/15  21:15:49  ohara
# 	SVR4 porting changes - 8596
# 	[1993/10/15  16:35:04  ohara]
# 
# Revision 1.1.8.5  1993/09/30  15:44:41  pellis
# 	Fixed problem with machine i386 being unknown and removed a couple
# 	of echoes done during tool installation.
# 	[1993/09/30  15:44:28  pellis]
# 
# Revision 1.1.8.4  1993/09/28  20:21:48  pellis
# 	Uncommented DFS system test installation, checked admin installation
# 	and fixed link tools link.
# 	[1993/09/28  20:21:31  pellis]
# 
# Revision 1.1.8.3  1993/09/28  13:06:56  cmckeen
# 	Put in fixes for OT defects 7778 and 7687.
# 	For 7778:
# 	  Changed install_s_cds to find the right directory.
# 	For 7687:
# 	  Created a new variable DCE_TEST_LOCAL and changed DCELOCAL to
# 	  DCE_TEST_LOCAL.  DCELOCAL has meaning outside the script and shouldn't
# 	  be changed.
# 	[1993/09/28  13:06:18  cmckeen]
# 
# Revision 1.1.8.2  1993/09/21  20:00:09  pellis
# 	Updated to install GDS system tests correctly.
# 	[1993/09/21  19:59:53  pellis]
# 
# Revision 1.1.8.1  1993/09/01  18:51:23  cmckeen
# 	Added sleeps after "Not supported in DCE 1.0.3" messages in the
# 	execute and logging options.
# 	[1993/09/01  17:47:24  cmckeen]
# 
# Revision 1.1.6.2  1993/08/13  18:48:11  cmckeen
# 	Added:
# 	1)  Option to install TET
# 
# 	Removed:
# 	1)  Execute option
# 	2)  Logging Functions option
# 
# 	Modified system tests installation to refect the new install tree
# 	structure (due to TET).
# 	[1993/08/13  18:35:44  cmckeen]
# 
# Revision 1.1.2.8  1993/02/16  19:56:06  ramb
# 	Fixed typo in creating HERE document.
# 	[1993/02/16  18:32:03  ramb]
# 
# Revision 1.1.2.7  1993/02/12  21:38:08  gmd
# 	Updated for DFS.
# 	[1993/02/12  20:59:43  gmd]
# 
# Revision 1.1.2.6  1993/02/05  21:24:35  ramb
# 	Fixed so the new 'admin tests' could be installed as part of system
# 	tests. Also made all executable files available unde rin 'systest'
# 	directory appear in the executable test list.
# 	[1993/02/05  21:09:03  ramb]
# 
# Revision 1.1.2.5  1993/02/05  15:17:45  cjd
# 	Embedded copyright notice
# 	[1993/02/05  14:37:04  cjd]
# 
# Revision 1.1.4.2  1993/02/04  21:45:43  cjd
# 	Embedded copyright notice
# 
# Revision 1.1.2.4  1993/01/27  19:41:25  ramb
# 	Modified to install dcetest_config if it is not already installed.
# 	Also removed installing of UNSUPPORTED system tests.
# 	[1993/01/27  19:39:48  ramb]
# 
# Revision 1.1.2.3  1993/01/11  15:54:07  ramb
# 	Remove ';' in line 1258 which is a no-no in this place.
# 	[1993/01/11  15:53:13  ramb]
# 
# Revision 1.1.2.2  1993/01/07  20:08:53  ramb
# 	New version for DCE1.0.2   Provides a framework for installing,
# 	configuring, executing system tests and reviewing/archiving logs.
# 	[1993/01/07  19:17:08  ramb]
# 
# $EndLog$
#
#
#  OSF DCE Version 1.0 
#
#
#
#
#------------------------------------------------------
DCEROOT=/dcetest
DCE_TEST_LOCAL=$DCEROOT/dcelocal
DCEINSTDIR=$DCEROOT/dce1.1
DEBUG="$1"
MACHINES_LIST=""
LOG_DIR_LIST=0
LOG_DIR_LIST_COUNTER=0
MY_DIRECTORY=`dirname $0`
SCHEDULED_TIME=""
CURRENT_DIRECTORY=`pwd`

# This is used by the dce_config installation routine to
# determine whether installation is from tape or filesystem.
TAPE=0
export DCEROOT DCE_TEST_LOCAL DCEINSTDIR
export TAPE

# Set $HOSTNAME to the name of the machine.  Ideally,
# this value is obtained from the DCE configuration file
# dce_cf.db, but is obtained from the "hostname" command
# if this configuration file doesn't yet exist.
# Note that this hostname does NOT have an internet domain 
# suffix (i.e. fenway rather than fenway.osf.org). 
HOSTNAME=`hostname | cut -f1 -d. 2>/dev/null`
if [ -f $DCE_TEST_LOCAL/dce_cf.db ]
then
  HOSTNAME=`cat $DCE_TEST_LOCAL/*.db | fgrep hostname | \
            awk '{print $2}' | cut -f2 -d"/"` || \
             HOSTNAME=`hostname | cut -f1 -d"." 2>/dev/null`
fi
export HOSTNAME
CONFIG_FILE=$DCE_TEST_LOCAL/config.$HOSTNAME

#------------------------------------------------------
# Utilities for installation/configuration routines
#------------------------------------------------------

clear_screen()
{
	if [ "$DEBUG" != "DEBUG" ]
	then
		tput clear
	fi	
}

#-----------------------------------------------------
# expmachinfo()
# This determines the ostype and system type so the right commands could
# be issued when needed.
# Note that this routine is a copy of the script test/systest/tools/expmachinfo
# As 'dcetest_config' exists standalone and cannot assume the availability
# of the file, the script has been copied in here. This should be kept
# consistent with the script.
# The function exports the following variables:
#	OSTYPE OSVERSION OSRELEASE and SYSTYPE
#-----------------------------------------------------
expmachinfo()
{
OSTYPE=`uname -s`
OSVERSION=`uname -v`
OSRELEASE=`uname -r`
SYSTYPE=''

case "$OSTYPE" in
AIX*)
	case "$OSVERSION" in
	1)	
		SYSTYPE=aix12
		;;
	2)
		SYSTYPE=aix21
		;;
	3)
		SYSTYPE=aix31
		;;
	*)
		echo;
		echo "Unknown OS version ($OSVERSION)";
		;;
	esac
	;;
DomainOS)
	SYSTYPE=domain
	;;
OSF1)
	case `uname -m` in
	mips)
		SYSTYPE=osf1mips
		;;
	i386)
		SYSTYPE=osf1i386
		;;
	*)	echo;
		echo "Unknown machine type (`uname -m`)";
		;;
	esac
	;;
SunOS)
	SYSTYPE=sunos
	;;
ULTRIX)
	case "$OSRELEASE" in
	4.1)
		SYSTYPE=ultrix41
		;;
	4.2)
		SYSTYPE=ultrix42
		;;
	*)      echo;
		echo "Unknown OS version ($OSRELEASE)";
		;;
	esac
	;;
HP-UX)  SYSTYPE=hpux
        ;;
SINIX*)
        OSTYPE=SVR4
        TARGET_OS=SINIX
        case "$OSVERSION" in
        A*)
                SYSTYPE=SNISVR4
                ;;
        B*)
                SYSTYPE=SNISVR4
                ;;
        C*)
                SYSTYPE=SNISVR4
                ;;
        D*)
                SYSTYPE=SNISVR4
                ;;
        *)
                echo "Unknown OS version ($OSVERSION)"
                ;;
        esac
        export TARGET_OS
        ;;
SVR4V3)
        SYSTYPE=svr4v3
        OSTYPE=SVR4V3
        TARGET_OS=SVR4V3
        export TARGET_OS
        ;;

*)
	echo;
	echo "Unknown OS type ($OSTYPE)";
	;;
esac

export OSTYPE OSVERSION OSRELEASE SYSTYPE
}

#-----------------------------------------------------
# printPIDs()
# Lists all running processes, greps for string_to_match, prints the PIDS of 
# the lines that match.
#-----------------------------------------------------
printPIDs()
# $1 - string_to_match
{
#
# these strings will be egreped out of the listing.  Do not want to give
# the PIDs of the processes actually doing the work.
#
	LEAVE_OUT="egrep"

# 
# The case statement allows each platform to be represented
#
	case "$SYSTYPE" in
	sun*)
		if [ "$VERBOSE" ]; then
			ps axc | egrep "$1" | egrep -v $LEAVE_OUT
		else
			ps axc | egrep "$1" | egrep -v $LEAVE_OUT | awk '{ print $1 }'
		fi
		;;
	ultrix*)
		if [ "$VERBOSE" ]; then
			ps -axc | egrep "$1" | egrep -v $LEAVE_OUT
		else
			ps -axc | egrep "$1" | egrep -v $LEAVE_OUT | awk '{ print $1 }'
		fi
		;;
	aix*)
		if [ "$VERBOSE" ]; then
			ps -ef | egrep "$1" | egrep -v $LEAVE_OUT
		else
			ps -ef | egrep "$1" | egrep -v $LEAVE_OUT | awk '{ print $2 }'
		fi
		;;
        svr4v3|SNISVR4)
                if [ "$VERBOSE" ]; then
                    /usr/bin/ps -ef | egrep "$1" | egrep -v $LEAVE_OUT
                else
                    /usr/bin/ps -ef | egrep "$1" | egrep -v $LEAVE_OUT | awk '{ print
 $2 }'
                fi
                ;;

        hpux)
                if [ "$VERBOSE" ]; then
			ps -ef | egrep "$1" | egrep -v $LEAVE_OUT
		else
			ps -ef | egrep "$1" | egrep -v $LEAVE_OUT | awk '{ print $2 }'
		fi
		;;

	osf1*|*)
		if [ "$VERBOSE" ]; then
			ps -o pid,ucomm -e | egrep "$1" | egrep -v $LEAVE_OUT
		else
			ps -o pid,ucomm -e | egrep "$1" | egrep -v $LEAVE_OUT | awk '{ print $1 }'
		fi
		;;
	esac

	return $?

} # end printPIDs()



#-----------------------------------------------------
# echon()
# Equivalent of echo -n on AIX.  Used for portability
# to other platforms.  This prevents the new line character
# from being printed after an echo statement.
#-----------------------------------------------------
echon()
{
	echo "$*\c"	
}

#---------------------------------------------
# x_exit()
#
# This routine allows an error message to be
# printed, and the processing to continue
# only after the administrator presses <ENTER>.
# Thus, the administrator can fix the condition
# that occurred manually, if so desired, or may
# force the routine to exit by using CTRL-C.
#---------------------------------------------
x_exit()
{
	echon "\tAborting.... ";
	#read string;
	exit
}

#---------------------------------------------
# get_option()
#
# This routine reads an input value and ensures it
# is among the valid values.  The user is continually
# prompted until a valid value is entered.
#
#---------------------------------------------
get_option()
{
        read opt

	# Ensure option gets a bad value if <RETURN> was
	# pressed prior to entering a value
	opt=${opt:-'10000'}
	FOUND=1

	for item in $opt
	do
		# Ensure option gets a bad value if <RETURN> was
		# pressed prior to entering a value
		option=${item:-10000}
		FOUND=1
       		for i in $LIST
       		do
			if [ $option -eq $i ]; then
				FOUND=0
		fi
       		done
       		if [ "$FOUND" -ne "0" ]; then
			echo 
			echo "\t\t An invalid value was entered."
			echo "\t\t Valid values are: $LIST"
			while [ $FOUND -ne 0 ] 
			do
				echon "\t\t Re-enter selection:  "
				get_option
			done
       		fi
	done
}

#---------------------------------------------
# get_string()
#
# This routine reads an input string.
#---------------------------------------------
get_string()
{
        read string
	export string
}

#---------------------------------------------
# one_option()
#
# Ensures only one option was selected from the menu
# from which this routine was invoked.
#---------------------------------------------
one_option()
{
	ONE_ARG=0
	while [ $ONE_ARG -eq "0" ]
	do
		numargs=0
		for i in $opt
		do
			numargs=`expr $numargs + 1`
		done
        	if [ $numargs -ne "1" ]
        	then
			echo
			echon "\tOnly one choice may be entered.  Re-enter selection:  "
			numargs=0
			get_option
		else
			ONE_ARG=1
        	fi
	done
}

#------------------------------------------------------
# Menus for installation and configuration of DCE
#------------------------------------------------------

print_menu0()
{
	echo "\n"
	echo "\t DCE Test Main Menu"
	echo "\n"
	echo "\t 1. Install"
	echo "\t 2. Configure"
	echo "\n"

	echo "\t 99. Exit"
	echo "\n"

	echon "\tselection:  "
}

print_binary_loc_menu()
{
	echo "\n"
	echo "\t Location of DCE Test Install Binaries"
	echo "\n"
	echo "\n"
	echo "\t 1. Filesystem"
	echo "\t 2. Media"
	echo "\n"

	echo "\t 98. Return to previous menu"
	echo "\t 99. Exit"
	echo "\n"

	echon "\tselection:  "
}

print_install_menu()
{
	echo "\n"
	echo "\t DCE Test Installation Menu"
	echo "\n"

	echo "\t 1. Functional Tests"
	echo "\t 2. System Tests"
	echo "\t 3. TET"
	echo "\n"

	echo "\t 98. Return to previous menu"
	echo "\t 99. Exit"
	echo "\n"

	echon "\tselection:  "
}

print_install_f_tests_menu()
{
	echo "\n"

	echo "\t DCE Test Installation (Functional Tests) Menu"
	echo "\n"

	echo "\t 1. Cell Directory Service"
	echo "\t 2. Distributed File Service"
	echo "\t 3. Global Directory Service"
	echo "\t 4. Remote Procedure Call"
	echo "\t 5. Security"
	echo "\t 6. Threads"
	echo "\t 7. Distributed Time Service"
	echo "\t 8. Audit"
	echo "\t 9. DCE Control Program"
	echo "\t 10. DCE Host Configuration Server"
	echo "\n"
	
	echo "\t 97. All of the above"
	echo "\t 98. Return to previous menu"
	echo "\t 99. Exit"
	echo "\n"

	echon "\tselection:  "
}

print_install_s_tests_menu()
{
	echo "\n"

	echo "\t DCE Test Installation (System Tests) Menu"

	echo "\t 1. Admin Tests"
	echo "\t 2. Cell Directory Service"
	echo "\t 3. Distributed File Service"
	echo "\t 4. Global Directory Service"
	echo "\t 5. Remote Procedure Call"
	echo "\t 6. Security"
	echo "\t 7. Threads"
	echo "\t 8. Distributed Time Service"
	echo "\t 9. Audit"
	echo "\t 10. I18N"
	echo "\t 11. Serviceability"
	echo "\t 12. DCED"
	echo "\n"
	
	echo "\t 97. All of the above"
	echo "\t 98. Return to previous menu"
	echo "\t 99. Exit"

	echon "\tselection:  "
}

print_log_menu()
{
	echo "\n"

	echo "\t DCE Test Logging Functions Menu"
	echo "\n"

	echo "\t 1. View Log"
	echo "\t 2. Roll-up logs"
	echo "\t 3. Archive Logs"

	echo "\t 98. Return to previous menu"
	echo "\t 99. Exit"

	echon "\tselection:  "
}

make_executetest_awk()
{
cat > /tmp/executetest.awk.$$ <<==EOF==
BEGIN	{
		counter=0
		print
		print 
		print "\tDCE Execute Test Menu"
		print
	}
\$0 ~ /.*\*$/	{
			++counter
			x=split(\$1,tests,"/")
			str=substr(tests[x],1,length(tests[x])-1)
			printf("\t%3d. %s\n",counter,str)
			printf("%d ",counter) > "/tmp/executetest.list.$$"
		}
END	{
		print
		++counter
		if ( counter < 98 ) {
			counter=98
		}
		printf("\t%3d. Return to previous menu\n",counter)
		printf("%d ",counter) > "/tmp/executetest.list.$$"
		printf("%d\n",counter) > "/tmp/executetest.previous.$$"
		++counter
		printf("\t%3d. Exit\n",counter)
		printf("%d\n",counter) > "/tmp/executetest.list.$$"
		printf("%d\n",counter) > "/tmp/executetest.exit.$$"
		print
	}
==EOF==
}


make_rollup_awk1()
{
cat > /tmp/rollup_awk1.$$ <<==EOF==
/ PASS | FAIL /	{
		if (NF == 0)
		{
			next
		}
		x=split(\$1,name,".")
		if (x != 4)
		{
			next
		}

		for (i=0; i < x; i++)
		{
			printf("%s ",name[i+1])
		}
		if (\$0 ~ / PASS /) {
			printf(" PASS\n");
		}
		else {
			printf(" FAIL\n");
		}
	}
==EOF==
}

make_rollup_awk2()
{
cat > /tmp/rollup_awk2.$$ <<==EOF==
BEGIN	{
		print "              Log Analysis By Machine/Script"
		print "              ------------------------------"
		print
		print "Machine          Script          Pid             Passed   Failed"
		print "-------------    -------------   --------        ------   ------"
		prev_machine=""
		prev_script=""
		prev_pid=""
	}		
	{
		if (NR == 1) {
			prev_machine=\$3
			prev_script=\$1
			prev_pid=\$2
			passed=0
			failed=0
		}
		if ( (prev_machine != \$3) || (prev_script != \$1) || (prev_pid != \$2)){
			printf("%-16s %-15s %-15s %-6d   %-6d\n",prev_machine,prev_script,prev_pid,passed,failed)
			prev_machine=\$3
			prev_script=\$1
			prev_pid=\$2
			passed=0
			failed=0
		}
		if ( \$5 == "PASS") {
			passed++
		}
		else {
			failed++
		}
	}
END	{
			printf("%-16s %-15s %-15s %-6d   %-6d\n",prev_machine,prev_script,prev_pid,passed,failed)
	}
==EOF==
}

make_rollup_awk3()
{
cat > /tmp/rollup_awk3.$$ <<==EOF==
BEGIN	{
		print "              Log Analysis By Script/Machine"
		print "              ------------------------------"
		print
		print "Script           Machine         Pid             Passed   Failed"
		print "-------------    -------------   --------        ------   ------"
		prev_machine=""
		prev_script=""
		prev_pid=""
	}		
	{
		if (NR == 1) {
			prev_machine=\$3
			prev_script=\$1
			prev_pid=\$2
			passed=0
			failed=0
		}
		if ( (prev_machine != \$3) || (prev_script != \$1) || (prev_pid != \$2)){
			printf("%-16s %-15s %-15s %-6d   %-6d\n",prev_script,prev_machine,prev_pid,passed,failed)
			prev_machine=\$3
			prev_script=\$1
			prev_pid=\$2
			passed=0
			failed=0
		}
		if ( \$5 == "PASS") {
			passed++
		}
		else {
			failed++
		}
	}
END	{
			printf("%-16s %-15s %-15s %-6d   %-6d\n",prev_script,prev_machine,prev_pid,passed,failed)
	}
==EOF==
}

make_viewlog_awk()
{
cat > /tmp/viewlog.awk.$$ <<==EOF==
BEGIN	{
		counter=0
		print
		print 
		print "\tDCE View Logs Menu"
		print
	}
\$0 ~ /.*\/$/	{
			++counter
			str=substr(\$1,1,length(\$1)-1)
			printf("\t%3d. %s\n",counter,str)
			printf("%d ",counter) > "/tmp/viewlog.list.$$"
			printf("%d %s\n",counter,str) > "/tmp/viewlog.dirlist.$$"
		}
END	{
		print
		printf("%d",counter) > "/tmp/viewlog.counter.$$"
		++counter
		if ( counter < 98 ) {
			counter=98
		}
		printf("\t%3d. Return to previous menu\n",counter)
		printf("%d ",counter) > "/tmp/viewlog.list.$$"
		printf("%d\n",counter) > "/tmp/viewlog.previous.$$"
		++counter
		printf("\t%3d. Exit\n",counter)
		printf("%d\n",counter) > "/tmp/viewlog.list.$$"
		printf("%d\n",counter) > "/tmp/viewlog.exit.$$"
		print
	}
==EOF==
}


#------------------------------------------------------
# menu0()
#
# Display the DCE Main Menu, and allow the user
# to select "Installation", "Configuration",
# "start DCE", or "stop DCE".  Invoke the appropriate
# routine based on the selection.
#------------------------------------------------------
menu0()
{
	mkdir $DCEROOT >/dev/null 2>&1

	while :
	do
#		LIST="1 2 3 4 99"
		LIST="1 2 99"
		export LIST

		print_menu0

		get_option

		# Only allow one option from this menu
		one_option

	       	# Note there's no need to check for an invalid option, because
	       	# the get_option routine already did that.
		case $opt in
		 	1)	get_binary_loc;
				if [ $? != 0 ]
				then
					continue
				fi;
				setup_destination;
				install_menu;
				;;
			2)	configure_menu;
				;;
#		 	3)	#execute_menu;
#                                echo "\n \nNot supported in DCE 1.0.3 \n"
#				sleep 2
#				;;
#			4)	#log_menu;
#                                echo "\n \nNot supported in DCE 1.0.3 \n"
#				sleep 2
#				;;
	            	99)	menu99;
				break;
				;;
		esac
	done
}

#------------------------------------------------------
# get_local_loc()
#
# Get the location where the tests should be installed into
#------------------------------------------------------
get_local_loc()
{
	while :
	do
		echo 
		echo "\tEnter the path to the DCE Test tree location."
		echo "\tThis will be the directory that will contain all the tests."
		echo "\tPlease locate this directory somewhere other than the root"
		echo "\tpartition, if possible. A softlink $DCE_TEST_LOCAL will be made"
		echo "\tto this location."
		echon "\tdirectory: "
		get_string
		DCELOCALDIR=$string
		if [ ! -a $DCELOCALDIR ]
		then
			mkdir $DCELOCALDIR
			if [ $? -ne "0" ]
			then
				echo
				echo "\tUnable to create $DCELOCALDIR directory"
				echo "\tPlease enter a valid location"
				echo
				continue
			fi
		fi
		touch $DCELOCALDIR/$$.OK > /dev/null 2>&1
		if [ $? -ne "0" ]
		then
			echo
			echo "\tUnable to write to $DCELOCALDIR..."
			echo "\tPlease re-enter..."
			continue
		else
			rm $DCELOCALDIR/$$.OK
			break
		fi
	done
	DCELOCALDIR=$string
	return 1
}

#------------------------------------------------------
# delete_or_rename_old_local_loc()
#
# check with the user if he wants to get rid of the old tests...
# setup a /dcetest/dcelocal.xx softlink to the old location
# where 'xx' is an incremented number. This preserves the old test
# directories in case the user does not want to get rid of them
#------------------------------------------------------
delete_or_rename_old_local_loc()
{
	echo
	echon "\tDo you want to delete $DCELOCALLINKDIR tree (n) "
	get_string
	answer=${string:-"n"}
	case $answer in
		y|yes)	echo;
			echo "\tDeleting old test tree $DCELOCALLINKDIR";
			rm -rf $DCELOCALLINKDIR;
			rm $DCE_TEST_LOCAL;
			return;;
		*)   ;;
	esac

	number=0
	while :
	do
		if [ -a $DCE_TEST_LOCAL.$number ]
		then
			let number=number+1
			continue
		else
			break
		fi
	done
	mv $DCE_TEST_LOCAL $DCE_TEST_LOCAL.$number
	return
}


#------------------------------------------------------
# setup_destination()
#
# setup final destination for installation
#------------------------------------------------------
setup_destination()
{
	# if /dcetest does not exist, then make one
	if [ ! -a $DCEROOT ]
	then
	    mkdir $DCEROOT
	fi

	touch $DCEROOT/$$.OK > /dev/null 2>&1
	if [ $? -ne "0" ]
	then
		echo
		echo "\tUnable to write to $DCEROOT..."
		echo "\tCannot proceed further until this is rectified..."
		x_exit 
	fi
	rm $DCEROOT/$$.OK
	
	# check if /dcetest/dcelocal exists. 
	issymlink ${DCE_TEST_LOCAL}
	stat=$?
	if [ $stat -eq "2" ]
	then
		# DCE_TEST_LOCAL does not exist. ask for location to store the
		# binaries and set the symbolic link to it.
		get_local_loc
		ln -s $DCELOCALDIR $DCE_TEST_LOCAL
		return
	fi

	if [ $stat -eq "0" ]
	then
		# DCE_TEST_LOCAL exists and is a symbolic link
		DCELOCALLINKDIR=`ls -l $DCE_TEST_LOCAL | cut -f2 -d">" | cut -c2-`
		#check if the link's actual directory exists
		touch $DCELOCALLINKDIR/$$.OK > /dev/null 2>&1
		if [ $? -ne "0" ]
		then
			echo
			echo "\t$DCE_TEST_LOCAL points to $DCELOCALLINKDIR"
			echo "\tBut unable to write to $DCELOCALLINKDIR..."
			echo "\tCannot proceed further until this is rectified..."
			x_exit
		fi
		rm $DCELOCALLINKDIR/$$.OK
		export DCELOCALLINKDIR
	
		# tell the user that this is the place that the existing
		# tests are located in and that the root partition has
		# a symbolic link to this location. Ask the user if they
		# want to continue to use this location for storing the
		# tests. If they specify a new location, then rename the
		# old link to dcelocal.xx where xx is an incremented number
		# create the new location if need be and set the link to
		# point to the new location.
		echo 
		echo "\tTests have previously been installed in $DCELOCALLINKDIR"
		echon "\tDo you want to continue storing the tests in the same location (y) "
		get_string
		answer=${string:-"y"}
		case $answer in
			y)   ;;
			yes) ;;
			*)   get_local_loc;
			     delete_or_rename_old_local_loc;
			     ln -s $DCELOCALDIR $DCE_TEST_LOCAL;;
		esac
	fi

	if [ $stat -eq "1" ]
	then
		# DCE_TEST_LOCAL exists and is not a symbolic link
		# so what do we do here
		# warn the user that s/he could run out of space on the
		# root partition and ask them if they want to move it to
		# a different location and set a symbolic link to that 
		# location.
		echo
		echo "\tWARNING: $DCE_TEST_LOCAL exists in not a symbolic link and you"
		echo "\t         run the risk of running out of space on the root partition"
		echon "\t        Do you want to move the directory to a different partition (y) "
		get_string
		answer=${string:-"y"}
		case $answer in
			y|yes)	get_local_loc;
				ln -s $DCELOCALDIR $DCE_TEST_LOCAL;;
			*)   ;;
		esac
	fi
}


#---------------------------------------------------
# get_binary_loc()
#
# This script finds the location of the DCE object code.
# It accepts input from the user as to the location of
# the binaries, and sets the appropriate environment
# variable ($DCESHARED) to this value.  
#---------------------------------------------------
get_binary_loc()
{
	print_binary_loc_menu

	verify
	return $?
}

#---------------------------------------------------
# verify()
#
# This routine prompts the user for information about
# the binary locations they specified in the
# get_binary_loc routine.
#
#---------------------------------------------------
verify()
{
	PARENT="get_binary_loc"
	LIST="1 2 98 99"
	export LIST PARENT
	get_option

	# Only allow the first choice for this menu, as you can't install 
	# from two different places at once.
	one_option

	case $opt in
		1)  while :
		    do
			echo "\n"
			echo "\tEnter the full path to the DCE binary install tree."
			echo "\tThis will be the directory that contains the"
			echo "\t.../<BUILD>/install/<machinetype>$DCEINSTDIR"
			echon "\tdirectory:  "
			get_string
			DCEINST=${string}
			export DCEINST
			# Does $DCEINST exist?  It must, or binaries won't be located.
			ls $DCEINST >/dev/null 2>&1
			if [ $? -ne "0" ]
			then
				echo
				echo "\t$DCEINST is not a valid directory."
				x_exit 
				continue
			else
				# Ensure this directory has test and test/systest
				# subdirectories.  This helps verify 
				# the directory entered was really what was
				# intended.
				if [ -d $DCEINST/test -a -d $DCEINST/test/systest ] || [ -d $DCEINST/test -a -d $DCEINST/test/tet ]
				then
					# directory is probably valid, so use it.
					break
				else
					echo
					echo "\t$DCEINST must contain test and test/systest"
					x_exit
					continue
				fi
			fi
		    done;
		    return 0;;
		2)  echo;
		    echon "\tEnter name of media device (/dev/rmt0):  ";
		    get_string;
		    DEV=${string:-/dev/rmt0};
		    export DEV;
		    echo "\n\n"
		    echo "\tMedia must be prepared by using the following:"
		    echo "\n"
		    echo "\tOn machine containing the complete install tree,"
		    echo "\t\tcd <.../install/<machine>/opt>"
		    echo "\t\ttar -cvf$DEV dce1.1"
		    x_exit
		    TAPE=1;
		    export TAPE;
		    return 0;;
		98) return 1;;
		99) menu99;;
	esac
}

#---------------------------------------------------
# issymlink()
#
# This routine checks to see if the directory needed is
# a symbolic link to a writable directory.  This is 
# necessary because Bourne shell has no built in test
# for a symbolic link.  (Bourne shell is used for this
# configuration script for portability purposes).
#
# This routine returns:
#		0 - if object exists and is a symlink
#		1 - if object exists and is NOT a symlink
#		2 - if object doesn't exist
#		
#---------------------------------------------------
issymlink()
{
	# Check to see if the object exists.  If not,
	# return a 2, which indicates the directory
	# needs to be created
	ls $1 >/dev/null 2>&1 || return 2

	if [ $? -eq "0" ]
	then
		# this is necessary because $DCE_TEST_LOCAL might be a symbolic
		# link to another filesystem.
		ls -ld $1 | grep "^[	 ]*l" >/dev/null
		if [ "$?" -eq 0 ]; then
		  	return 0
		else
		  	return 1
		fi
	else
		return 2
	fi
}

#------------------------------------------------------
# install_menu()
#
# Display the DCE Test Installation Menu, and allow the user
# to select "Functional Tests", "System Tests".
# Invoke the appropriate
# routine based on the selection.
#------------------------------------------------------
install_menu()
{
	while :
	do
		LIST="1 2 3 98 99"
		PARENT=menu0
		export LIST PARENT

		print_install_menu

		get_option

		# Only allow one option from this menu
		one_option

		# Note there's no need to check for an invalid option, because
	       	# the get_option routine already did that.
		case $opt in
			 1)	install_functional_tests_menu;;
			 2)	install_system_tests_menu;;
	                 3)     install_tet;;
			98)	$PARENT;;
	            	99)	menu99;;
		esac
	done
}

#------------------------------------------------------
# install_functional_tests_menu()
#
# Display the DCE Functional Test Installation Menu. 
#------------------------------------------------------
install_functional_tests_menu()
{
	return_from_menu=0
	while :
	do
		LIST="1 2 3 4 5 6 7 8 9 10 97 98 99"
		export LIST
		print_install_f_tests_menu
		get_option
		for optionitem in $opt 
		do
        	# Note there's no need to check for an invalid option, because
        	# the get_option routine already did that.
			case $optionitem in
			 	1) 	install_f_cds; 
					install_f_profile_dcest;;
				 2)	install_f_dfs; 
					install_f_profile_dcest;;
				 3)	install_f_gds; 
					install_f_profile_dcest;;
				 4)	install_f_rpc;
					install_f_profile_dcest;;
				 5)	install_f_sec; 
					install_f_profile_dcest;;
				 6)	install_f_thr; 
					install_f_profile_dcest;;
				 7)	install_f_dts; 
					install_f_profile_dcest;;
				 8)	install_f_aud; 
					install_f_profile_dcest;;
				 9)	install_f_dcecp; 
					install_f_profile_dcest;;
				10)	install_f_dced; 
					install_f_profile_dcest;;
				97)	install_f_all; 
					install_f_profile_dcest;
					return_from_menu=1;;
				98)	return_from_menu=1;;
       		        	99)	menu99;;
			esac
		done
		if [ "$return_from_menu" = "1" ]
		then
			break
		fi
	done
#	after_config_profile_dcest
}

install_f_profile_dcest()
{
	install test/systest/profile.dcest
	if [ ! -f $DCE_TEST_LOCAL/test/systest/dcetest_config ]
	then
		install test/systest/dcetest_config
	fi
}


#------------------------------------------------------
# install_f_cds()
#
# Install CDS functional tests
#------------------------------------------------------
install_f_cds()
{
	install test/directory/cds
}

#------------------------------------------------------
# install_f_dfs()
#
# Install DFS functional tests
#------------------------------------------------------
install_f_dfs()
{
	install test/file
}

#------------------------------------------------------
# install_f_gds()
#
# Install GDS functional tests
#------------------------------------------------------
install_f_gds()
{
	install test/directory/gds/mavrostest
	install test/tet/functional/directory/gds
	install test/tet/functional/directory/xds
}

#------------------------------------------------------
# install_f_rpc()
#
# Install RPC functional tests
#------------------------------------------------------
install_f_rpc()
{
	install test/rpc
}

#------------------------------------------------------
# install_f_sec()
#
# Install SEC functional tests
#------------------------------------------------------
install_f_sec()
{
	install test/security
}

#------------------------------------------------------
# install_f_thr()
#
# Install THREADS functional tests
#------------------------------------------------------
install_f_thr()
{
	install test/threads
}

#------------------------------------------------------
# install_f_dts()
#
# Install DTS functional tests
#------------------------------------------------------
install_f_dts()
{
	install test/time
}

#------------------------------------------------------
# install_f_aud()
#
# Install AUD functional tests
#------------------------------------------------------
install_f_aud()
{
	install test/tet/functional/security/audit
}

#------------------------------------------------------
# install_f_dcecp()
#
# Install DCECP functional tests
#------------------------------------------------------
install_f_dcecp()
{
	install test/tet/tools
	install test/tet/functional/admin/dcecp
}

#------------------------------------------------------
# install_f_dced()
#
# Install DCED functional tests
#------------------------------------------------------
install_f_dced()
{
	install test/tet/functional/admin/dced
}

#------------------------------------------------------
# install_f_all()
#
# Install all functional tests
#------------------------------------------------------
install_f_all()
{
	install_f_cds
	install_f_dfs
	install_f_gds
	install_f_rpc
	install_f_sec
	install_f_thr
	install_f_dts
	install_f_aud
	install_f_dcecp
	install_f_dced
}

#---------------------------------------------
# read_media()
#
# Reads information from the media device and stores
# it into $DCEINSTDIR
#---------------------------------------------
read_media()
{
	TARGETDIR=$1
	if [ $TAPE -eq 1 ]
   	then
		LASTDIR=`pwd`
		cd $DCEROOT
		RESTLIST=""
  		for i in $LIST
   		do
			RESTLIST="$RESTLIST dce1.1/$TARGETDIR/$i"
		done
		tar -xvf $DEV $RESTLIST || \
		   { echo "\tEnsure $DEV is ready ..."; x_exit; }
		cd $LASTDIR
   	fi
}

#---------------------------------------------------
# install()
#
# 
#	Create any directories needed
#---------------------------------------------------
install()
{
	DIRLIST=$*

	for i in $DIRLIST
	do
		if [ -d $DCEINST/$i ]; then
			if [ ! -d $DCE_TEST_LOCAL/$i ]; then
				setdirperms $DCE_TEST_LOCAL/$i || { echo "\tcan't create $DCE_TEST_LOCAL/$i"; x_exit; }
			elif [ ! -w $DCE_TEST_LOCAL/$i ]; then
				echo "$DCE_TEST_LOCAL/$i doesn't have write permission"
				x_exit
			fi
		fi
	done

	# Install the binaries
	for d in $DIRLIST
	do
		echo "\t\tinstalling $d ..."
		if [ $TAPE -eq "1" ]
		then
			read_media $d
		else
			dest=$DCE_TEST_LOCAL/$d
			dest=${dest%/*}
			if [ -a $DCEINST/$d ]
			then
				mkdir -p $dest > /dev/null 2>&1
				cp -pr $DCEINST/$d $dest || \
        	  	     		{ echo "Can't create file $DCE_TEST_LOCAL/$d/$i";
	        	       		echo "\tEnsure that the file is in the install tree"; x_exit; }
			else
				echo
        	  	     	echo "\t$DCEINST/$d does not exist"
	        	       	echo "\tEnsure that the file is in the install tree"
				echo "\t$DCEINST/$d not installed..."
			fi
		fi				
	done
}



#------------------------------------------------------
# install_system_tests_menu()
#
# Display the DCE System Tests Installation Menu. 
#------------------------------------------------------
install_system_tests_menu()
{
	return_from_menu=0
	while :
	do
		LIST="1 2 3 4 5 6 7 8 9 10 11 12 97 98 99"
		export LIST
		print_install_s_tests_menu
		get_option
		for optionitem in $opt 
		do
        	# Note there's no need to check for an invalid option, because
        	# the get_option routine already did that.
			case $optionitem in
				 1) 	install_s_admin; 
					install_s_tools;;
				 2) 	install_s_cds; 
					install_s_profile_dcest_tet;
					install_s_tools;;
				 3)	install_s_dfs; 
					install_s_tools;;
				 4)	install_s_gds; 
					install_s_profile_dcest;
					install_s_tools;;
				 5)	install_s_rpc; 
					install_s_profile_dcest_tet;
					install_s_tools;;
				 6)	install_s_sec; 
					install_s_profile_dcest_tet;
					install_s_tools;;
				 7)	install_s_thr; 
					install_s_profile_dcest_tet;
					install_s_tools;;
				 8)	install_s_dts; 
					install_s_profile_dcest_tet;
					install_s_tools;;
				 9)	install_s_audit; 
					install_s_profile_dcest_tet;
					install_s_tools;;
				10)	install_s_i18n;
					install_s_profile_dcest_tet;
					install_s_tools;;
				11)	install_s_svc;
					install_s_profile_dcest_tet;
					install_s_tools;;
				12)	install_s_dced;
					install_s_profile_dcest_tet;
					install_s_tools;;
				97)	install_s_all; 
					install_s_profile_dcest_tet;
					install_s_tools;
					return_from_menu=1;;
				98)	return_from_menu=1;;
       		        	99)	menu99;;
#					after_dcetest_config;
			esac
		done
		if [ "$return_from_menu" = "1" ]
		then
			break
		fi
	done
#	after_dcetest_config
}

#------------------------------------------------------
# install_s_profile_dcest_tet()
#
# Install profile.dcest.tet
#------------------------------------------------------
install_s_profile_dcest_tet()
{
	install test/tet/system/profile.dcest.tet
	install test/systest/dcetest_config
}

#------------------------------------------------------
# install_s_profile_dcest()
#
# Install profile.dcest
#------------------------------------------------------
install_s_profile_dcest()
{
	install test/tet/system/profile.dcest
	install test/systest/dcetest_config
}


#------------------------------------------------------
# install_s_tools()
#
# Install system test tools
#------------------------------------------------------
install_s_tools()
{
	if [ -d $DCE_TEST_LOCAL/test/systest/tools ] ; then
		echo
		echon "\tDo you want to re-install test/systest/tools (n) "
		get_string
		answer=${string:-"n"}
		case $answer in
			y|yes)	;;
			*)	return;;
		esac
	fi	

	install test/tet/system/tools

	if [ -d ${DCE_TEST_LOCAL}/test/systest ] ; then
		rm -rf ${DCE_TEST_LOCAL}/test/systest/tools
		ln -s ${DCE_TEST_LOCAL}/test/tet/system/tools \
		${DCE_TEST_LOCAL}/test/systest/tools
	fi
	install_f_profile_dcest
}


#------------------------------------------------------
# install_s_admin()
#
# Install CDS system tests
#------------------------------------------------------
install_s_admin()
{
	install test/systest/admin
}

#------------------------------------------------------
# install_s_cds()
#
# Install CDS system tests
#------------------------------------------------------
install_s_cds()
{
	install test/tet/system/directory/cds
}

#------------------------------------------------------
# install_s_dfs()
#
# Install DFS system tests
#------------------------------------------------------
install_s_dfs()
{
	install test/systest/file
}

#------------------------------------------------------
# install_s_gds()
#
# Install GDS system tests
#------------------------------------------------------
install_s_gds()
{
	install test/systest/directory/gds
}

#------------------------------------------------------
# install_s_rpc()
#
# Install RPC system tests
#------------------------------------------------------
install_s_rpc()
{
	install test/tet/system/rpc
}

#------------------------------------------------------
# install_s_sec()
#
# Install SEC system tests
#------------------------------------------------------
install_s_sec()
{

CLIENT_PATH=${DCEINST}/test/security/api/moretests/dlg_client
DELEGATE_PATH=${DCEINST}/test/security/api/moretests/dlg_intermediary
ACL_PATH=${DCEINST}/test/security/svr_example/acl_server
TARGET_PATH=${DCE_TEST_LOCAL}/test/tet/system/security/ts/dlgcfg001



#check for target directory, if it does not exist create it
       ls ${TARGET_PATH} >/dev/null 2>&1
       if [ $? -ne "0" ]
       then
	 	mkdir -p ${TARGET_PATH}
       		if [ $? -ne "0" ]
		then
                	echo "\tCould not create ${TARGET_PATH}."
		else
			chmod 755 ${TARGET_PATH}
			chown root ${TARGET_PATH}
			chgrp bin ${TARGET_PATH}
		fi
       else
		rm -rf ${TARGET_PATH}
       		if [ $? -ne "0" ]
		then
                	echo "\tCould not remove ${TARGET_PATH}."
		fi
	 	mkdir -p ${TARGET_PATH}
       		if [ $? -ne "0" ]
		then
                	echo "\tCould not create ${TARGET_PATH}."
		else
			chmod 755 ${TARGET_PATH}
			chown root ${TARGET_PATH}
			chgrp bin ${TARGET_PATH}
		fi

	fi

	install test/tet/system/security

#check for dlg_client needed by dlgcfg001 test
       ls ${CLIENT_PATH} >/dev/null 2>&1
       if [ $? -ne "0" ]
       then
   		echo	 
                echo "\t${CLIENT_PATH} not found."
                echo "\tCannot run DLGCFG001 without ${CLIENT_PATH}"
        else
	 	cp ${CLIENT_PATH} ${TARGET_PATH}
		chmod a+x ${TARGET_PATH}/dlg_client

	fi

#check for dlg_intermediary needed by dlgcfg001 test
       ls ${DELEGATE_PATH} >/dev/null 2>&1
       if [ $? -ne "0" ]
       then
   		echo	 
                echo "\t${DELEGATE_PATH} not found."
                echo "\tCannot run DLGCFG001 without ${DELEGATE_PATH}"
        else
	 	cp ${DELEGATE_PATH} ${TARGET_PATH}
		chmod a+x ${TARGET_PATH}/dlg_intermediary

	fi

#check for acl_server needed by dlgcfg001 test
       ls ${ACL_PATH} >/dev/null 2>&1
       if [ $? -ne "0" ]
       then
   		echo	 
                echo "\t${ACL_PATH} not found."
                echo "\tCannot run DLGCFG001 without ${ACL_PATH}"
        else
	 	cp ${ACL_PATH} ${TARGET_PATH}
		chmod a+x ${TARGET_PATH}/acl_server

	fi
}

#------------------------------------------------------
# install_s_thr()
#
# Install THREADS system tests
#------------------------------------------------------
install_s_thr()
{
	install test/tet/system/threads
}

#------------------------------------------------------
# install_s_dts()
#
# Install DTS system tests
#------------------------------------------------------
install_s_dts()
{
	install test/tet/system/time
}

#------------------------------------------------------
# install_s_audit()
#
# Install audit system  tests
#------------------------------------------------------
install_s_audit()
{
	install test/tet/system/audit
}

#------------------------------------------------------
# install_s_i18n()
#
# install I18N system tests.
#------------------------------------------------------
install_s_i18n()
{
	install  test/tet/system/I18N
}

#------------------------------------------------------
# install_s_svc()
#
# install SVC system tests.
#------------------------------------------------------
install_s_svc()
{
	install  test/tet/system/svc
}

#------------------------------------------------------
# install_s_dced()
#
# install DCED system tests.
#------------------------------------------------------
install_s_dced()
{
	install  test/tet/system/dced
}

#------------------------------------------------------
# install_s_all()
#
# Install all system tests
#------------------------------------------------------
install_s_all()
{
	install_s_admin
	install_s_cds
	install_s_dfs
	install_s_gds
	install_s_rpc
	install_s_sec
	install_s_thr
	install_s_dts
	install_s_audit
	install_s_i18n
	install_s_svc
	install_s_dced
}

#------------------------------------------------------
# install_tet()
#
# Install TET
#------------------------------------------------------
install_tet()
{
	install test/tet/bin
	install test/tet/lib
}


#---------------------------------------------------
# setdirperms()
#
# This routine is used to set ownership, group, and permission
# bits for the newly created $DCE_TEST_LOCAL structure.
#---------------------------------------------------
setdirperms()
{
	mkdir -p $1 > /dev/null 2>&1
	chmod 755 $1
	chown root $1
	chgrp bin $1
	return 0
}

#------------------------------------------------------
# menu99()
#
# Exit Menu.  Quit the program.
#------------------------------------------------------
menu99()
{
#  after_dcetest_config  
  rm /tmp/viewlog*$$*  /tmp/executetest*$$* > /dev/null 2>&1
  rm /tmp/awk.*$$* /tmp/profile*$$* > /dev/null 2>&1
  rm /tmp/dcetest*$$* > /dev/null 2>&1 
  rm /tmp/roll*$$* > /dev/null 2>&1
  rm /tmp/sh*$$* /tmp/default*$$*  > /dev/null 2>&1
  rm /tmp/check_scheduled_time*$$* > /dev/null 2>&1
  rm /tmp/job_string*$$* > /dev/null 2>&1
  exit
}



#------------------------------------------------------
#
#
# Configure Menu.
#------------------------------------------------------
configure_menu()
{
	isinstalled;
	if [ $? -eq 1 ]
	then
		return
	fi

	OLD_DCELOGDIR=""
	OLD_DCETMPDIR=""

	if [ -a $CONFIG_FILE ]
	then
		OLD_DCELOGDIR=`grep 'DEFAULT_STLIB=' $CONFIG_FILE | cut -f1 | awk -F"=" '{ print $2 }'`
		OLD_DCETMPDIR=`grep 'DEFAULT_STTMPDIR=' $CONFIG_FILE | cut -f1 | awk -F"=" '{ print $2 }'`
	fi
	echo $DCELOGDIR
	NEW_DCELOGDIR=$OLD_DCELOGDIR
	NEW_DCETMPDIR=$OLD_DCETMPDIR

	#ask where the user wants the logs to be stored...
	if [ "$OLD_DCELOGDIR" != "" ]
	then
		echo
		echo "\tCurrently the log files are being stored in $OLD_DCELOGDIR"
		echon "\tDo you want to change the location (n) "
		get_string
		answer=${string:-"n"}
		case $answer in
			y|yes)	get_new_log_loc;
				rename_or_delete_old_log_loc;
				link_log_loc;
				;;
			*)	;;
		esac
	else
		get_new_log_loc
		link_log_loc
	fi

	#ask where the user wants the tmp files to be stored...
	if [ "$OLD_DCETMPDIR" != "" ]
	then
		echo
		echo "\tCurrently the log files are being stored in $OLD_DCETMPDIR"
		echon "\tDo you want to change the location (n) "
		get_string
		answer=${string:-"n"}
		case $answer in
			y|yes)	get_new_tmp_loc;
				;;
			*)	;;
		esac
	else
		get_new_tmp_loc
	fi
	
	make_config_file
	return
}

get_new_log_loc()
{
	while :
	do
		echo 
		echo "\tYou need to specify the directory where the logs would be stored."
		echo "\tPlease locate this directory somewhere other than the root"
		echo "\tpartition, if possible. A softlink would be established to"
		echo "\tpoint to this directory from $DCE_TEST_LOCAL/status."
		echo "\t   (Use a name other than 'status')"
		echon "\tEnter directory to store the logs: "
		get_string
		NEW_DCELOGDIR=$string
		if [ "$NEW_DCELOGDIR" = "" ]
		then
			echo 
			echo "\tInvalid directory location specified..."
			echo "\tPlease specify a valid directory location"
			echon "\tPress ENTER to continue"
			continue
		fi
		if [ ! -d $NEW_DCELOGDIR ]
		then
			echo 
			echo "\tDirectory $NEW_DCELOGDIR does not exist..."
			echon "\tDo you want it it to be created (y) "
			get_string
			answer=${string:-"y"}
			case $answer in
				y|yes)	mkdir -p $NEW_DCELOGDIR;;
				*)	continue;;
			esac
		fi
		break
	done
}

			
rename_or_delete_old_log_loc()
{
	if [ -d $OLD_DCELOGDIR ]
	then
		echo 
		echon "\tDo you want to delete $OLD_DCELOGDIR (n) "
		get_string
		answer=${string:-"n"}
		case $answer in
			y|yes)	echo;
				echo "\tDeleting $OLD_DCELOGDIR...";
				rm -rf $OLD_DCELOGDIR;
				;;
			*)	
				number=0
				while :
				do
					if [ -a $DCE_TEST_LOCAL/status.$number ]
					then
						let number=number+1
						continue
					else
						break
					fi
				done;
				echo;
				echo "\tRenaming $DCE_TEST_LOCAL/status to $DCE_TEST_LOCAL/status.$number";
				mv $DCE_TEST_LOCAL/status $DCE_TEST_LOCAL/status.$number;
				;;
		esac
	fi
}

link_log_loc()
{
	rm -f $DCE_TEST_LOCAL/status
	ln -s $NEW_DCELOGDIR $DCE_TEST_LOCAL/status
}

make_config_file()
{
	echo "DEFAULT_STLIB=$NEW_DCELOGDIR" > $CONFIG_FILE
	echo "DEFAULT_STTMPDIR=$NEW_DCETMPDIR" >> $CONFIG_FILE
}

get_new_tmp_loc()
{
	while :
	do
		echo 
		echo "\tYou need to specify the directory where the temporary files"
		echo "\twould be stored."
		echon "\tEnter directory to store the temporary files: "
		get_string
		NEW_DCETMPDIR=$string
		if [ "$NEW_DCETMPDIR" = "" ]
		then
			echo
			echo "\tInvalid directory location specified..."
			echo "\tPlease specify a valid directory location"
			echon "\tPress ENTER to continue"
			continue
		fi
		if [ ! -d $NEW_DCETMPDIR ]
		then
			echo 
			echo "\tDirectory $NEW_DCETMPDIR does not exist..."
			echon "\tDo you want it it to be created (y) "
			get_string
			answer=${string:-"y"}
			case $answer in
				y|yes)	mkdir -p $NEW_DCETMPDIR;;
				*)	continue;;
			esac
		fi
		echo 
		echo "\tPlease ensure that $NEW_DCETMPDIR is periodically cleaned..."
		break
	done
}


#------------------------------------------------------
#
#
# Execute Test Menu.
#------------------------------------------------------
execute_menu()	
{
	isinstalled;
	if [ $? -eq 1 ]
	then
		cd $CURRENT_DIRECTORY
		return
	fi

	isconfigured;
	if [ $? -eq 1 ]
	then
		cd $CURRENT_DIRECTORY
		return
	fi

	cd $DCE_TEST_LOCAL/test/systest

	make_executetest_awk
	ls -F1 $DCE_TEST_LOCAL/test/systest | grep -v profile.dcest | grep -v dcetest_config | awk -f /tmp/executetest.awk.$$ > /tmp/executetest.out.$$
	grep '1\.' /tmp/executetest.out.$$ > /dev/null 2>&1
	if [ $? -eq "1" ]
	then
		echo 
		echo "\tNo tests to execute..."
		echon "\tPress RETURN to continue..."
		get_string
		cd $CURRENT_DIRECTORY
		return
	fi

	while :
	do
		clear_screen
		LIST=`cat /tmp/executetest.list.$$`
		prev_number=`cat /tmp/executetest.previous.$$`
		exit_number=`cat /tmp/executetest.exit.$$`
		export LIST
		more /tmp/executetest.out.$$
		echon "\tselection:  "

		get_option

		# Only allow one option from this menu
		one_option
		break
	done

	if [ "$opt" -eq "$prev_number" ]
	then
		cd $CURRENT_DIRECTORY
		return
	elif [ "$opt" -eq "$exit_number" ]
	then
		cd $CURRENT_DIRECTORY
		exit
	else
		test=`grep "$opt." /tmp/executetest.out.$$ | cut -f2 | cut -d. -f2 | cut -d' ' -f2`
		execute $DCE_TEST_LOCAL/test/systest/$test
	fi
			
	cd $CURRENT_DIRECTORY
	rm /tmp/executetest.*.$$
}

execute()
{
	. $DCE_TEST_LOCAL/test/systest/profile.dcest
	testname=`basename $1`
	testdir=`dirname $1`
	while :
	do
		clear_screen
		$testdir/$testname -h
		echo
		echon "Please specify desired options-> $testname "
		get_string
		test_options=$string
		$testdir/$testname -H $test_options
		if [ "$?" = "0" ]
		then
			SCHEDULED_TIME=""
			get_schedule_time "$testname $test_options"
			if [ "$?" = "0" ]
			then
				echo "at -k $SCHEDULED_TIME $testdir/$testname $test_options"
				at -k $SCHEDULED_TIME <<==EOF==
$testdir/$testname $test_options
==EOF==
				break
			else
				$testname $test_options
				break
			fi
		fi
	done
	press_return_continue
}

get_schedule_time()
{
	while :
	do
		clear_screen
		echo $1
		echo "----------------------------------------------------"
		make_schedule_time 
		echon "Enter execution time: "
		get_string
		typeset -u upcase_string=$string
		if [ "$string" = "" ]
		then
			return 1
		fi
		if [ "$upcase_string" = "HELP" ]
		then
			man at
			continue
		fi
		SCHEDULED_TIME=$string
		cat > /tmp/check_scheduled_time.$$ <<==EOF==
#!/bin/sh
echo "hello" > /dev/null
==EOF==
		at -k $SCHEDULED_TIME 2> /tmp/job_string.$$  <<==EOF==
/tmp/check_scheduled_time.$$
==EOF==
		if [ "$?" != "0" ]
		then
			echo 
			echon "Invalid time entered. Press RETURN to continue."
			get_string
			continue
		else
			atrm `cat /tmp/job_string.$$ | cut -d' ' -f2` > /dev/null
			break
		fi
	done
	return 0	
}

make_schedule_time()
{

	You can choose to have the test run now or defer its execution to
	a later time.  If you wish to defer to a later time, please enter
	the time to start in the following format:
		time [date] [increment]
	This format is the same format as used by the 'at' command.
	Some examples are given below:
	          5 pm Friday uuclean
        	  now next week uuclean
	          now + 2 days uuclean
        	  3:00  pm  January  24
	          3pm  Jan  24
        	  1500  jan  24

	Press RETURN if you want the test started now              OR
	Enter HELP   if you want to view the man page for 'at' now OR
	Enter 'time-to-start' in the format described above.

}

#------------------------------------------------------
#
#
# Log Menu.
#------------------------------------------------------
log_menu()
{
	isinstalled;
	if [ $? -eq 1 ]
	then
		return
	fi


	if [ "$LOG_DIR_LIST" = "0" ]
	then
		get_log_dir_list
		LOG_DIR_LIST=1
	fi

	while :
	do
		clear_screen
		LIST="1 2 3 98 99"
		export LIST
		print_log_menu	

		get_option

		for optionitem in $opt 
		do
        	# Note there's no need to check for an invalid option, because
	       	# the get_option routine already did that.
			case $optionitem in
				 1) 	log_view;
					;;
				 2)	log_rollup;
					;;
				 3)	log_archive;
					;;
				98)	return;;
       		        	99)	menu99;;
			esac
		done
	done
}

log_view()
{
#	while :
#	do
#		echo
#		machine=`hostname`
#		echon "Enter system name ($machine): "
#		get_string
#		answer=${string:-$machine}
#		ping -c1 $answer > /dev/null 2>&1
#		if [ $? -eq "1" ]
#		then
#			echo
#			echo "\tInvalid system name entered. Please re-enter."
#			continue
#		fi
#		break
#	done

	grep '1\.' /tmp/viewlog.out.$$ > /dev/null 2>&1
	if [ $? -eq "1" ]
	then
		echo 
		echo "\tNo log files to view..."
		echon "\tPress RETURN to continue..."
		get_string
		return
	fi

	while :
	do
		clear_screen
		LIST=`cat /tmp/viewlog.list.$$`
		prev_number=`cat /tmp/viewlog.previous.$$`
		exit_number=`cat /tmp/viewlog.exit.$$`
		export LIST
		more /tmp/viewlog.out.$$
		echon "\tselection:  "

		get_option

		# Only allow one option from this menu
		one_option
		break
	done

	if [ "$opt" -eq "$prev_number" ]
	then
		return
	elif [ "$opt" -eq "$exit_number" ]
	then
		menu99
	else
		dir=`grep "$opt." /tmp/viewlog.out.$$ | cut -f2 | cut -d. -f2 | cut -d' ' -f2`
		viewlog $DCELOGDIR/current/$dir/pass_fail_log
	fi
}

	
get_log_dir_list()
{
	if [ "$DCELOGDIR" = "" ]
	then
		DCELOGDIR=`grep 'DEFAULT_STLIB=' $CONFIG_FILE | cut -f1 | awk -F"=" '{ print $2 }'`
		if [ "$DCELOGDIR" = "" ]
		then
			echo
			echo "\tDCELOGDIR variable is not set."
			echo "\tPlease configure and restart..."
			echon "\tPresss RETURN to continue"
			get_string
			return
		fi
		export DCELOGDIR
	fi
	
	make_viewlog_awk
	ls -F1p $DCELOGDIR/current | awk -f /tmp/viewlog.awk.$$ > /tmp/viewlog.out.$$
	LOG_DIR_LIST_COUNTER=`cat /tmp/viewlog.counter.$$`
}
viewlog()
{
	clear_screen
	logfile=$1
	passed=`grep " PASS " $logfile | wc -l`
	failed=`grep " FAIL " $logfile | wc -l`
	echo
	echo
	echo "\t$logfile results are:"
	echo "\t\tTotal number of iterations passed = $passed"
	echo "\t\tTotal number of iterations failed = $failed"
	if [ passed -gt 0 ]
	then
		echo
		echon "\tPrint the list of passed iterations (n): "
		get_string
		answer=${string:-"n"}
		case $answer in
			y|yes)	viewlog_passed $1;
				;;
			*)	;;
		esac
	fi
	if [ failed -gt 0 ]
	then
		echo
		echon "\tPrint the list of failed iterations (y): "
		get_string
		answer=${string:-"y"}
		case $answer in
			y|yes)	viewlog_failed $1;
				;;
			*)	;;
		esac
	fi
}

viewlog_passed()
{
	grep " PASS " $1 | cut -d' ' -f1 > /tmp/viewlog_passed.$$
	IFS="."
	echo >> /tmp/viewlog_passed.$$.$$
	echo "List of passed iterations" >> /tmp/viewlog_review.$$
	echo "-------------------------" >> /tmp/viewlog_review.$$
	while read script pid machine iteration
	do
		if [ "$script" != "" ]
		then
			echo "[$script.$pid.$machine.$iteration] $script passed on $machine (pid $pid) iteration $iteration." >> /tmp/viewlog_review.$$
		fi
	done < /tmp/viewlog_passed.$$
	IFS=" 	
"
	rm /tmp/viewlog_passed.$$
	review_iteration pass
}

viewlog_failed()
{
	grep " FAIL " $1 | cut -d' ' -f1 > /tmp/viewlog_failed.$$
	IFS="."
	echo >> /tmp/viewlog_failed.$$.$$
	echo "List of failed iterations" >> /tmp/viewlog_review.$$
	echo "-------------------------" >> /tmp/viewlog_review.$$
	while read script pid machine iteration
	do
		if [ "$script" != "" ]
		then
			echo "[$script.$pid.$machine.$iteration] $script failed on $machine (pid $pid) iteration $iteration. " >> /tmp/viewlog_review.$$
		fi
	done < /tmp/viewlog_failed.$$
	IFS=" 	
"
	rm /tmp/viewlog_failed.$$
	review_iteration fail
}
	
review_iteration()
{
	while :
	do
		more /tmp/viewlog_review.$$
		if [ "$1" = "pass" ]
		then
			press_return_continue
			break
		fi
		echo 
		echon "Enter iteration to review (shown within square brackets): "
		get_string
		if [ "$string" = "" ]
		then
			break
		fi
		grep "\[$string\]" /tmp/viewlog_review.$$ > /dev/null
		if [ $? -eq "1" ]
		then
			echo
			echo "\tInvalid iteration entered. Please re-enter."
			continue
		fi
		more $DCELOGDIR/current/$dir/$1/$string/*
		echo
		echon "\tDo you wish to review more iterations? (n): "
		get_string
		answer=${string:-"n"}
		case $answer in
			y|yes)	continue;
				;;
			*)	break;
				;;
		esac
	done
	rm /tmp/viewlog_review.$$
}

log_rollup()
{
	echo
	echon "\tPlease wait.  Rolling up logs..."
	make_rollup_awk1
	while read number dirname
	do
		cat $DCELOGDIR/current/$dirname/pass_fail_log | awk -f /tmp/rollup_awk1.$$ >> /tmp/rollup_log1.$$
		echon " $number"
	done < /tmp/viewlog.dirlist.$$
	echo " done."
	
	if [ "$OSTYPE" = "AIX" ]
	then
		sort_options="+2 -3 +0 -1 +1 -2 -n"
	else
		sort_options="-f3 -f1 -f2"
	fi
	sort $sort_options < /tmp/rollup_log1.$$ > /tmp/rollup_log2.$$ 
	make_rollup_awk2
	clear_screen
	cat /tmp/rollup_log2.$$ | awk -f /tmp/rollup_awk2.$$ | more
	press_return_continue

	if [ "$OSTYPE" = "AIX" ]
	then
		sort_options="+0 -1 +2 -3 +1 -2 -n"
	else
		sort_options="-f1 -f3 -f2"
	fi
	sort $sort_options < /tmp/rollup_log1.$$ > /tmp/rollup_log3.$$
	make_rollup_awk3
	clear_screen
	cat /tmp/rollup_log3.$$ | awk -f /tmp/rollup_awk3.$$ | more
	press_return_continue
	#rm /tmp/rollup_log*$$
}

press_return_continue()
{
	echo
	echon "Press RETURN to continue: "
	get_string
}

log_archive()
{
	echo
	echo "\tPlease wait.  Archiving logs..."
	while read number dirname
	do
		if [ ! -a $DCELOGDIR/archive/$dirname ]
		then
			mkdir -p $DCELOGDIR/archive/$dirname
		fi
		month=`ls -l $DCELOGDIR/current/$dirname/pass_fail_log | tr -s ' ' '\011' | cut -f6`
		date=`ls -l $DCELOGDIR/current/$dirname/pass_fail_log | tr -s ' ' '\011' | cut -f7`
		time=`ls -l $DCELOGDIR/current/$dirname/pass_fail_log | tr -s ' ' '\011' | cut -f8`
		filename="$month.$date.$time"
		IFS=":"
		newfilename="archive"
		newlogname="pass_fail_log"
		for x in $filename
		do
			newfilename=$newfilename.$x
			newlogname=$newlogname.$x
		done
		IFS=" 	
"
		echo
		echo "\tTarring     $DCELOGDIR/current/$dirname..."
		tar -cvf $DCELOGDIR/archive/$dirname/$newfilename.tar $DCELOGDIR/current/$dirname/pass_fail_log $DCELOGDIR/current/$dirname/pass $DCELOGDIR/current/$dirname/fail > /dev/null
		if [ $? -eq "0" ]
		then
			mv $DCELOGDIR/current/$dirname/pass_fail_log $DCELOGDIR/archive/$dirname/$newlogname
			touch $DCELOGDIR/current/$dirname/pass_fail_log
			rm -rf $DCELOGDIR/current/$dirname/pass
			mkdir  $DCELOGDIR/current/$dirname/pass
			rm -rf $DCELOGDIR/current/$dirname/fail
			mkdir  $DCELOGDIR/current/$dirname/fail
			echo "\tCompressing $DCELOGDIR/archive/$dirname/$newfilename.tar..."
			compress $DCELOGDIR/archive/$dirname/$newfilename.tar
		fi
	done < /tmp/viewlog.dirlist.$$
	echo
	echo "\tdone."
}

get_machines_list()
{
	if [ "$MACHINES_LIST" != "" ]
	then
		machines_list=$MACHINES_LIST
	else
		machines_list=`hostname`
	fi

	while :
	do
		echo
		echo "\tPlease specify the list of machines to roll-up data from."
		echo "\tPlease separate the machine names with a space."
		echon "\tEnter list ($machines_list): "
		get_string
		if [ "$string" = "" ] 
		then
			string=$machines_list
		fi
		list_ok=0
		for i in $string
		do
			ping -c1 $i > /dev/null 2>&1
			if [ $? -eq 1 ]
			then
				list_ok=1
				echo
				echo "\t$i not responding. Please re-enter list"
				break
			fi
		done
		if [ $list_ok -eq "0" ]
		then
			break
		fi
	done
	MACHINES_LIST=$string
}

isinstalled()
{
	#check if profile.dcest exists
	#if it does not, tell him to install the software before proceeding
	if [ ! -a $DCE_TEST_LOCAL/test/systest/profile.dcest ]
	then
		echo 
		echo "\tYou must install tests before configuring the system!"
		echo "\tPlease install system test and then proceed..."
		echon "\tPress RETURN to continue..."
		get_string
		return 1
	else
		return 0
	fi
}

isconfigured()
{
	#check if 'DEFAULT_' lines are specified in  profile.dcest
	#if it does not, tell him to install the software before proceeding
	if [ ! -a $DCE_TEST_LOCAL/test/systest/profile.dcest ]
	then
		echo 
		echo "\tYou must configure 'dcetest' before executing the tests!"
		echo "\tPlease choose 'configure' option and then proceed..."
		echon "\tPress RETURN to continue..."
		get_string
		return 1
	else
		return 0
	fi
}

trap_signal()
{
	echo
	echo "========================================"
	echo "Trap signal received..."
	echo "========================================"
	echo
	echo "Signal received, exiting..."
	menu99
}

after_dcetest_config()
{
echo "after_dcetest_config\n"
cp $MY_DIRECTORY/systest.functions $DCE_TEST_LOCAL/test/systest/tools/systest.functions
chmod +x $DCE_TEST_LOCAL/test/systest/tools/systest.functions

cp $MY_DIRECTORY/expmachinfo $DCE_TEST_LOCAL/test/systest/tools/expmachinfo
chmod +x $DCE_TEST_LOCAL/test/systest/tools/expmachinfo

cp $MY_DIRECTORY/rshsp $DCE_TEST_LOCAL/test/systest/tools/rshsp
chmod +x $DCE_TEST_LOCAL/test/systest/tools/rshsp

cp $MY_DIRECTORY/chkproc $DCE_TEST_LOCAL/test/systest/tools/chkproc
chmod +x $DCE_TEST_LOCAL/test/systest/tools/chkproc

cp $MY_DIRECTORY/killproc $DCE_TEST_LOCAL/test/systest/tools/killproc
chmod +x $DCE_TEST_LOCAL/test/systest/tools/killproc

cp $MY_DIRECTORY/getproc $DCE_TEST_LOCAL/test/systest/tools/getproc
chmod +x $DCE_TEST_LOCAL/test/systest/tools/getproc

if [ -a $DCE_TEST_LOCAL/test/systest/dceth001 ]
then
	cp $MY_DIRECTORY/dceth001 $DCE_TEST_LOCAL/test/systest
fi

if [ -a $DCE_TEST_LOCAL/test/systest/dcethrpc ]
then
	cp $MY_DIRECTORY/dcethrpc $DCE_TEST_LOCAL/test/systest
fi

if [ -a $DCE_TEST_LOCAL/test/systest/dcetmall ]
then
	cp $MY_DIRECTORY/dcetmall $DCE_TEST_LOCAL/test/systest
fi

if [ -a $DCE_TEST_LOCAL/test/systest/dcerpbnk ]
then
	cp $MY_DIRECTORY/dcerpbnk $DCE_TEST_LOCAL/test/systest
fi

if [ -a $DCE_TEST_LOCAL/test/systest/dceseacl ]
then
	cp $MY_DIRECTORY/dceseacl $DCE_TEST_LOCAL/test/systest
fi

if [ -a $DCE_TEST_LOCAL/test/systest/dcesepol ]
then
	cp $MY_DIRECTORY/dcesepol $DCE_TEST_LOCAL/test/systest
fi

if [ -a $DCE_TEST_LOCAL/test/systest/dcesestr ]
then
	cp $MY_DIRECTORY/dcesestr $DCE_TEST_LOCAL/test/systest
fi

if [ -a $DCE_TEST_LOCAL/test/systest/dcegdshd ]
then
	cp $MY_DIRECTORY/dcegdshd $DCE_TEST_LOCAL/test/systest
fi

cd $DCE_TEST_LOCAL/test/systest
rm dcecdacs dcecdnam dcecdras dcecdrep dcedfacl dcedfcce dcedfdbe dcedffme dcedflck dcedfst1 dcedfst4 dcedfusr dcegdacl dcerpacf dcerpary dcerpidl dcerpper dcerprec dcethcac dcethsig > /dev/null 2>&1
cd $CURRENT_DIRECTORY

after_config_profile_dcest
}

after_config_profile_dcest()
{
  cp $MY_DIRECTORY/profile.dcest $DCE_TEST_LOCAL/test/systest/profile.dcest
}

#------------------------------------------------------
# MAIN program
# main()
#
# Execute menu0.  From there, receive user input as
# to which operation is desired, and continue until
# the user requests to exit.
#------------------------------------------------------
ROUTINE="menu0"
FLAG=0
expmachinfo

trap   'trap_signal' 1 2 3 15

$ROUTINE

