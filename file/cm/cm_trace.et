#
# @OSF_COPYRIGHT@
# COPYRIGHT NOTICE
# Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
# ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
# the full copyright text.
#
#
# Copyright (C) 1996, 1992 Transarc Corporation
# Licensed Materials - Property of Transarc
# All rights reserved.
#
# cache manager trace table
#
error_table 2 zcm
	ec	CM_TRACE_RCSID,
		"$Header: /afs/tr/project/fs/dev/dfs-dev/src/file/cm/RCS/cm_trace.et,v 1.218 1996/06/13 20:26:29 andi Exp $"
	ec	CM_TRACE_LOOKUP,
		"CM cm_lookup %x %s"
	ec	CM_TRACE_SEARCHACLCACHE,
		"CM cm_GetACLCache vp %x pag %x"
	ec	CM_TRACE_FOUNDACLCACHE,
		"CM foundaclcache rights %x"
	ec	CM_TRACE_ADDACL,
		"CM addacl vp %x pag %x rights %#x"
	ec	CM_TRACE_FREEALLACLS,
		"CM free all acls vp %x"
	ec	CM_TRACE_INVALIDATEACL,
		"CM invalidate acl vp %x, user %x"
	ec	CM_TRACE_BKGFOUND,
		"CM bkg found req %d, vp %x"
	ec	CM_TRACE_NEWCELL,
		"CM cm_NewCell %s"
	ec	CM_TRACE_CREATECELL,
		"CM creating cell %s"
	ec	CM_TRACE_FINDCELLID,
		"CM looking for cell %s"
	ec	CM_TRACE_GETCELLSTART,
		"CM start VL_GetCellInfo"
	ec	CM_TRACE_GETCELLEND,
		"CM end VL_GetCellInfo, code %d"
	ec	CM_TRACE_NEWCONN,
		"CM cm_ConnByHost: creating conn type %#x, conn %x"
	ec	CM_TRACE_STOMPBINDING,
		"CM stomping binding %x"
	ec	CM_TRACE_MARKCONNBAD,
		"CM mark conn bad for pag %x"
	ec	CM_TRACE_GCCONNS,
		"CM GC conns %#x"
	ec	CM_TRACE_GETTGTTIME,
		"CM get TGT time %x for pag %x"
	ec	CM_TRACE_STARTSETCONTEXT,
		"CM start AFS_SetContext conn %x srv level %#x"
	ec	CM_TRACE_ENDSETCONTEXT,
		"CM end AFS_SetContext code %d"
	ec	CM_TRACE_CONNBYMHOSTS,
		"CM cm_ConnByMHosts server type %x"
	ec	CM_TRACE_FILESETSALLBAD,
		"CM cm_ConnByMHosts: all filesets bad"
	ec	CM_TRACE_FILESETWENTBUSY,
		"CM cm_ConnByMHosts: fileset Id(%d) went busy"
	ec	CM_TRACE_CONNBYHOST, 
		"CM cm_ConnByHost server type %#x, serverp %x"
	ec	CM_TRACE_FOUNDSERVERDOWN,
		"CM cm_ConnByMHosts: found  %d-th server down"
	ec	CM_TRACE_CBMREASON,
		"CM cm_ConnByMHosts: reason %d for volume %d"
	ec	CM_TRACE_CHECKVOLNAMES,
		"CM running cm_CheckVolumeNames"
	ec	CM_TRACE_FLUSHACTIVESCACHES,
		"CM running FlushActiveSCaches"
	ec	CM_TRACE_FLUSHACTIVESUBCALLS,
		"CM flushactivescaches starting %d concurrent storebacks"
	ec	CM_TRACE_WTHRUDSLOTS,
		"CM running write through dslots"
	ec	CM_TRACE_STKNMGMT,
		"CM servertokenmgt running %d subops"
	ec	CM_TRACE_RENEWLAZYREPS,
		"CM running minor renewlazyreps"
	ec	CM_TRACE_MAJORRENEW,
		"CM running major renewlazyreps"
	ec	CM_TRACE_RENEWWORK,
		"CM RenewLazyReps refresh vol %d, age %d, mtl %d totiv %d"
	ec	CM_TRACE_RENEWSUBS,
		"CM Renewlazyreps starts %d subjobs"
	ec	CM_TRACE_CHECKONVOLROOT,
		"CM running CheckOnVOLRoot"
	ec	CM_TRACE_REFRESHKEEPALIVES,
		"CM running refreshkeepalives"
	ec	CM_TRACE_REFRESHCALLED,
		"CM called RefreshKA with %d fids, code %d"
	ec	CM_TRACE_GCEXPORTER,
		"CM running gcexporter"
	ec	CM_TRACE_PINGSERVERS,
		"CM running Ping Servers"
	ec	CM_TRACE_PINGSERVER1,
		"CM Ping Servers queuing at time %x"
	ec	CM_TRACE_PINGSERVER2,
		"CM Ping Servers done at time %x"
	ec	CM_TRACE_PINGSERVERSNA,
		"CM running pingservers no adjust"
	ec	CM_TRACE_CHECKDOWN,
		"CM running Check Down Servers"
	ec	CM_TRACE_GETDCACHEFAIL,
		"CM getdcache failed to find vp %x, chunk %d"
	ec	CM_TRACE_GETDCACHEWIN,
		"CM getdcache found vp %x, chunk %d in dcp %x"
	ec	CM_TRACE_FETCHDC,
		"CM fetchDCache scp %x, dcp %x"
	ec	CM_TRACE_FAKE0,
		"CM faking 0 byte entry locally"
	ec	CM_TRACE_READDIRSTART,
		"CM start  AFS_Readdir at position %d"
	ec	CM_TRACE_READDIREND,
		"CM end AFS_Readdir, code %d"
	ec	CM_TRACE_FETCHDATASTART,
		"CM start  AFS_FetchData at position %d"
	ec	CM_TRACE_FETCHDATAEND,
		"CM end AFS_FetchData, code %d"
	ec	CM_TRACE_STOREALLSEGS,
		"CM storeallsegments vp %x"
	ec	CM_TRACE_SMUSH,
		"CM locally smushing scp %x, dcp %x"
	ec	CM_TRACE_GETDOWNDSTART,
		"CM in cm_GetDownD, need space %d"
	ec	CM_TRACE_FLUSHDC,
		"CM in flushDCache, dcp %x"
	ec	CM_TRACE_STOREFILE,
		"CM cm_StoreDCache scp %x, dcp %x"
	ec	CM_TRACE_STOREFILESTART,
		"CM cm_StoreDCache starts store"
	ec	CM_TRACE_STOREFILEEND,
		"CM cm_StoreDCache starts end, code %d"
	ec	CM_TRACE_INVALIDATEALL,
		"CM cm_InvalidateAllSegments scp %x"
	ec	CM_TRACE_DOLOOKUP,
		"CM nh_dolookup dvp %x, name %s"
	ec	CM_TRACE_DOLOOKUPSTART,
		"CM nh_dolookup calling AFS_Lookup"
	ec	CM_TRACE_DOLOOKUPEND,
		"CM nh_dolookup back from AFS_Lookup, code %d"
	ec	CM_TRACE_PIOCTL,
		"CM cm_pioctl vp %x, opcode %d"
	ec	CM_TRACE_STOREACLSTART,
		"CM start AFS_StoreACL"
	ec	CM_TRACE_STOREACLEND,
		"CM end AFS_StoreACL, code %d"
	ec	CM_TRACE_FETCHACLSTART,
		"CM start AFS_FetchACL"
	ec	CM_TRACE_FETCHACLEND,
		"CM end AFS_FetchACL, code %d"
	ec	CM_TRACE_REMOVEMOUNTSTART,
		"CM start removemount RPC"
	ec	CM_TRACE_REMOVEMOUNTEND,
		"CM end removemount RPC, code %d"
	ec	CM_TRACE_ANALYZE,
		"CM cm_Analyze: conn %x, code %d, pag %x"
	ec	CM_TRACE_ANALYZESUB,
		"CM cm_Analyze: volerr subcode %d"
	ec	CM_TRACE_ANALYZESTALE,
		"CM cm_Analyze: host stale"
	ec	CM_TRACE_ANALYZEBUSY,
		"CM cm_Analyze: doing busy retry, vol.low %d"
	ec	CM_TRACE_ANALYZEFASTBUSY,
		"CM cm_Analyze: doing fast busy retry, vol.low %d, code %d"
	ec	CM_TRACE_ANALYZEMOVED,
		"CM cm_Analyze: check loc of volume %d: result %d, gotNewLoc %d"
	ec	CM_TRACE_CHECKVLDBSTART,
		"CM starting checkvldb's vlgetentrybyid"
	ec	CM_TRACE_CHECKVLDBEND,
		"CM checkvldb's vlgetentrybyid done, code %d"
	ec	CM_TRACE_SCACHEREPCHECK,
		"CM havetoken revalidate replicated vol %d, time %x"
	ec	CM_TRACE_SCACHESTART,
		"CM start AFS_FetchStatus"
	ec	CM_TRACE_SCACHEEND,
		"CM end AFS_FetchStatus code %d"
	ec	CM_TRACE_STORESTATUSSTART,
		"CM begin AFS_StoreStatus"
	ec	CM_TRACE_STORESTATUSEND,
		"CM end AFS_StoreStatus, code %d"
	ec	CM_TRACE_SCANSTATUS,
		"CM scanstatus vp %x, flags %#x"
	ec	CM_TRACE_LOOKUPROOTSTART,
		"CM begin AFS_LookupRoot"
	ec	CM_TRACE_LOOKUPROOTEND,
		"CM end AFS_LookupRoot, code %d"
	ec	CM_TRACE_PINGSERVER,
		"CM pingserver server %x"
	ec	CM_TRACE_CHECKDOWNINT,
		"CM checkdownservers server %x"
	ec	CM_TRACE_GETTIMESTART,
		"CM begin AFS_GetTime"
	ec	CM_TRACE_GETTIMEEND,
		"CM end AFS_GetTime, code %d"
	ec	CM_TRACE_GABFETCHSTART,
		"CM getaccessbits starting fetch for vp %x"
	ec	CM_TRACE_GABFETCHEND,
		"CM getaccessbits end fetch, code %d"
	ec	CM_TRACE_CVSUPDATE,
		"CM checkvolsync updates time when vv current for vol %d to %d"
	ec	CM_TRACE_CVSBACK,
		"CM checkvolsync sees vv going back, vol %d, to vv.low %d"
	ec	CM_TRACE_CVSSET,
		"CM checkvolsync notes %d fids from vol.low %d, to vv.low %d"
	ec	CM_TRACE_TKNPROBE,
		"CM TKN_Probe called"
	ec	CM_TRACE_TKNINITSTATE,
		"CM TKN_InitTokenState called"
	ec	CM_TRACE_TKNINITSERVER,
		"CM TKN_InitTokenState's server is %x"
	ec	CM_TRACE_TKNINITEND,
		"CM TKN_InitTokenState returning code %d"
	ec	CM_TRACE_STARTTSR,
		"CM TKN_InitTokenState start TSR"
	ec	CM_TRACE_ENDTSR,
		"CM TKN_InitTokenState end TSR"
	ec	CM_TRACE_TKNREVSTART,
		"CM TKN_TokenRevoke start"
	ec	CM_TRACE_REVOKEONETOKEN,
		"CM Revoke one token; type %#x"
	ec	CM_TRACE_TKNREVBASE,
		"CM revoking %d tokens from server %x"
	ec	CM_TRACE_REVOKEHERE,
		"CM revoking here tokens for volume %#x"
	ec	CM_TRACE_REVOKEHERE2,
		"CM RevokeHereTokens: checkvolumeinfo, Error %d"
	ec	CM_TRACE_REVOKEHERE3,
		"CM RevokeHereTokens end"
	ec	CM_TRACE_RESTORETOKENS,
		"CM VL_RESTORETOKENS is set"
	ec	CM_TRACE_TKNREVFILE,
		"CM revoking from vp %x, rights %#x"
	ec	CM_TRACE_TKNREVFILEEND,
		"CM revoke for vp %x returns code %d"
	ec	CM_TRACE_TKNSETPARAMS,
		"CM TKN_SetParams called"
	ec	CM_TRACE_TKNGETSI,
		"CM TKN_GetServerInterfaces called"
	ec	CM_TRACE_GETSIEND,
		"CM TKN_GetServerInterfaces returns code %d"
	ec	CM_TRACE_GETTOKENSTART,
		"CM begin AFS_GetToken for vp %x, rights %#x"
	ec	CM_TRACE_GETTOKENEND,
		"CM end AFS_GetToken, code %d"
	ec	CM_TRACE_RELTOKENSTART,
		"CM begin AFS_ReleaseTokens for %d tokens"
	ec	CM_TRACE_RELTOKENEND,
		"CM end AFS_ReleaseTokens, code %d"
	ec	CM_TRACE_CONFIGCELL,
		"CM configure cell %s"
	ec	CM_TRACE_CONFIGCELLEND,
		"CM configure cell returned code %d"
	ec	CM_TRACE_FHTOVP,
		"CM in cm_fhtovp"
	ec	CM_TRACE_OPEN,
		"CM cm_open vp %x, flags %#x"
	ec	CM_TRACE_CLOSE,
		"CM cm_close vp %x, flags %#x"
	ec	CM_TRACE_WRITE,
		"CM cm_write vp %x, flag %#x"
	ec	CM_TRACE_WRITEOVL,
		"CM write overflows chunk, max %d, len %d"
	ec	CM_TRACE_READ,
		"CM cm_read vp %x, nolock %d"
	ec	CM_TRACE_READFAWAIT,
		"CM waiting for fetchack, dcp %x"
	ec	CM_TRACE_READDWAIT,
		"CM waiting for data to arrive, validPos is %d"
	ec	CM_TRACE_IOCTL,
		"CM in ioctl, vp %x"
	ec	CM_TRACE_GETATTR,
		"CM in cm_getattr, vp %x, flag %#x"
	ec	CM_TRACE_SETATTR,
		"CM in cm_setattr, vp %x, flag %#x"
	ec	CM_TRACE_ACCESS,
		"CM in cm_access, vp %x, mode %#x"
	ec	CM_TRACE_LOOKUPDOTDOTFAIL,
		"CM lookup failed to find good '..' back pointer"
	ec	CM_TRACE_LOOKUPFID,
		"CM found fid %x.%x.%x.%x (hex)"
	ec	CM_TRACE_LOOKUPMTPT,
		"CM lookup crossing mount point"
	ec	CM_TRACE_LOOKUPMTPTFID,
		"CM mount point points to fid %x.%x.%x.%x"
	ec	CM_TRACE_LOOKUPMTPTFAIL,
		"CM mount point lookup failed"
	ec	CM_TRACE_LOOKUPVP,
		"CM lookup returning vp %x"
	ec	CM_TRACE_LOOKUPCF,
		"CM lookup connection failure"
	ec	CM_TRACE_CREATE,
		"CM create dvp %x, name %s, mode %#x"
	ec	CM_TRACE_CREATESTART,
		"CM begin AFS_CreateFile"
	ec	CM_TRACE_CREATEEND,
		"CM end AFS_CreateFile, code %d"
	ec	CM_TRACE_EVALMOUNTPOINT,
		"CM in EvalMountPoint, vp %x"
	ec	CM_TRACE_CREATEFIND,
		"CM create's scache search returns %#x"
	ec	CM_TRACE_REMOVE,
		"CM remove dvp %x, name %s"
	ec	CM_TRACE_REMOVESTART,
		"CM begin AFS_RemoveFile"
	ec	CM_TRACE_REMOVEEND,
		"CM end AFS_RemoveFile, code %d"
	ec	CM_TRACE_LINK,
		"CM hard link to vp %x, from dir %x name %s"
	ec	CM_TRACE_LINKSTART,
		"CM begin AFS_HardLink"
	ec	CM_TRACE_LINKEND,
		"CM end AFS_HardLink, code %d"
	ec	CM_TRACE_RENAME,
		"CM rename old vp %x, old name %s, new vp %x, new name %s"
	ec	CM_TRACE_RENAMESTART,
		"CM begin AFS_Rename"
	ec	CM_TRACE_RENAMEEND,
		"CM end AFS_Rename, code %d"
	ec	CM_TRACE_MKDIR,
		"CM mkdir dvp %x, name %s"
	ec	CM_TRACE_MKDIRSTART,
		"CM begin AFS_MakeDir"
	ec	CM_TRACE_MKDIREND,
		"CM end AFS_MakeDir, code %d"
	ec	CM_TRACE_RMDIR,
		"CM removedir dvp %x, name %s"
	ec	CM_TRACE_RMDIRSTART,
		"CM begin AFS_RemoveDir"
	ec	CM_TRACE_RMDIREND,
		"CM end AFS_RemoveDir, code %d"
	ec	CM_TRACE_READDIR,
		"CM cm_readdir vp %x, len %d"
	ec	CM_TRACE_READDIRLOOP,
		"CM readdir filePos %d, chunk %d"
	ec	CM_TRACE_READDIRCFOUND,
		"CM lookup cookie returned %d"
	ec	CM_TRACE_READDIRCLOST,
		"CM lookup cookie failed, trying from chunk %d"
	ec	CM_TRACE_READDIRSYNC,
		"CM readdir resync, filePos %d, from chunk %d"
	ec	CM_TRACE_READDIRREAD,
		"CM readdir reading from chunk %d, relative pos %d"
	ec	CM_TRACE_READDIRRET,
		"CM readdir returning new offset %d, code %d"
	ec	CM_TRACE_SYMLINK,
		"CM symlink creating dvp %x, name %s"
	ec	CM_TRACE_SYMLINKSTART,
		"CM begin AFS_SymLink"
	ec	CM_TRACE_SYMLINKEND,
		"CM end AFS_SymLink, code %d"
	ec	CM_TRACE_READLINK,
		"CM readlink vp %x"
	ec	CM_TRACE_FSYNC,
		"CM fsync vp %x"
	ec	CM_TRACE_INACTIVE,
		"CM inactive vp %x"
	ec	CM_TRACE_BMAP,
		"CM bmap vp %x"
	ec	CM_TRACE_STRATEGY,
		"CM strategy bp %x"
	ec	CM_TRACE_USTRAT,
		"CM user strat, vp %x, bp->flags %#x"
	ec	CM_TRACE_NOOP,
		"CM noop"
	ec	CM_TRACE_MERGESTAT,
		"CM mergestatus vp %x, tokenp %x, flags %#x"
	ec	CM_TRACE_MERGESTATOK,
		"CM mergestatus ctime OK for merging, local mod flags %#x"
	ec	CM_TRACE_MERGESTATACL,
		"CM mergestatus add pag %x rights %#x"
	ec	CM_TRACE_UPDATESTAT,
		"CM updatestatus dirvalequalp == %d"
	ec	CM_TRACE_QUOTASTART,
		"CM begin AFS_Quota "
	ec	CM_TRACE_QUOTAEND,
		"CM end AFS_Quota, code %d"
	ec	CM_TRACE_GETACL,
		"CM cm_getacl vp %x"
	ec	CM_TRACE_GETACLSTART,
		"CM begin AFS_GetAcl"
	ec	CM_TRACE_GETACLEND,
		"CM end AFS_GetAcl, code %d"
	ec	CM_TRACE_SETACL,
		"CM cm_setacl vp %x"
	ec	CM_TRACE_SETACLSTART,
		"CM begin AFS_SetAcl"
	ec	CM_TRACE_SETACLEND,
		"CM end AFS_SetAcl, code %d"
	ec	CM_TRACE_INSTALLVOLENTRY,
		"CM Install vol entry for volume ID %d"
	ec	CM_TRACE_GETVOLBYIDSTART,
		"CM begin VL_GetEntryByID"
	ec	CM_TRACE_GETVOLBYIDEND,
		"CM end VL_GetEntryByID, code %d"
	ec	CM_TRACE_GETVOLBYNAME,
		"CM getvolbyname looking for volume %s"
	ec	CM_TRACE_GETVOLSTART,
		"CM begin VL_GetVolByName"
	ec	CM_TRACE_GETVOLEND,
		"CM end VL_GetVolByName, code %d"
	ec	CM_TRACE_NEWVOLNAME,
		"CM setting vol name for vol %x to %s"
	ec	CM_TRACE_SETGROUPS,
		"CM in afs_xsetgroups"
	ec	CM_XXX_OBSOLETE_1,
		"CM used to be CM_TRACE_SETPAG"
	ec	CM_TRACE_ACLRECYCLE,
		"CM getfreeaclent recycles acl entry from vp %x"
	ec	CM_TRACE_GETCELLFAIL,
		"CM cm_GetCell failed to find cell %x.%x"
	ec	CM_TRACE_GETCELLBYNAMEFAIL,
		"CM cm_GetCellByName failed to find cell %s"
	ec	CM_TRACE_CONN,
		"CM cm_ConnByHost using conn %x, service %#x"
	ec	CM_TRACE_RESETUSERCONNS,
		"CM in cm_ResetUserConns for pag %x"
	ec	CM_TRACE_FQST,
		"CM in cm_FlushQueuedServerTokens for server %x"
	ec	CM_TRACE_GETDONLINE,
		"CM in GetDOnLine, scp %x, dcp %x"
	ec	CM_TRACE_GETDONLINEHARD,
		"CM getdonline: getting tokens to get chunk online"
	ec	CM_TRACE_SYNCDCACHE,
		"CM cm_SyncDCache syncing all chunks from vp %x"
	ec	CM_TRACE_SYNCDCACHEFAIL,
		"CM cm_SyncDCache fail (ETIMEDOUT) from vp %x"
	ec	CM_TRACE_TRUNCATEALLSEGS,
		"CM TruncateAllSegments truncating vp %x to %d"
	ec	CM_TRACE_GETDOWNDSLOTRECYCLE,
		"CM getdowndslot recycling dcp %x"
	ec	CM_TRACE_INVALIDATEONESEG,
		"CM invalidateoneseg vp %x, dcp %x"
	ec	CM_TRACE_CLEAROLS,
		"CM clearing online state for vp %x, dcp %x"
	ec	CM_TRACE_UPDATETID,
		"CM setting online token ID for vp %x, dcp %x"
	ec	CM_TRACE_NHENTER,
		"CM in nh_enter, scp %x, name %s, vnode %#x"
	ec	CM_TRACE_NHDELETE,
		"CM in nh_delete, scp %x, name %s"
	ec	CM_TRACE_NHDELETEDVP,
		"CM nh_deleted_vp for scp %x"
	ec	CM_TRACE_RELEASELOCKF,
		"CM releaselockf vp %x, type %x, start %d, lastbyte %d"
	ec	CM_TRACE_SETLOCKF,
		"CM cm_SetLockF vp %x, type %x, start %d, lastbyte %d"
	ec	CM_TRACE_REVOKELOCKF,
		"CM cm_TryLockRevoke vp %x, type %x colA %x colB %x"
	ec	CM_TRACE_REVOKENOLOCKF,
		"CM cm_TryLockRevoke: No lockf found vp %x"
	ec	CM_TRACE_SETLOCKFNOTOKEN,
		"CM lock token conflict"
	ec	CM_TRACE_SETLOCKFLOCAL,
		"CM setlockf: blocked locally == %d"
	ec	CM_TRACE_CHECKERROR,
		"CM checkerror returning code %d"
	ec	CM_TRACE_GETSCACHE,
		"CM cm_GetScache vp %x, volume.low %#x, vnode %#x"
	ec	CM_TRACE_MARKTIME,
		"CM MarkTime vp %x, time %x, flags %#x"
	ec	CM_TRACE_SYNCSCACHE,
		"CM SyncSCache vp %x"
	ec	CM_TRACE_SYNCSCACHEFAIL,
		"CM SyncSCache fail (ETIMEDOUT) from vp %x"
	ec	CM_TRACE_FLUSHSCACHE,
		"CM recycling scache %#x, really"
	ec	CM_TRACE_RESETBINDMOUNTS,
		"CM resetting all bind mount points"
	ec	CM_TRACE_RECLAIMLOST,
		"CM lost race in reclaim, scp %x"
	ec	CM_TRACE_SERVERDOWN,
		"CM server %x just marked down"
	ec	CM_TRACE_SHUTDOWN,
		"CM cm_shutdown called!"
	ec	CM_TRACE_STABILIZESCACHEWAIT,
		"CM StabilizeSCache waiting vp %x"
	ec	CM_TRACE_STABILIZEDCACHEWAIT1,
		"CM StabilizeDCache waiting vp %x, dcp %x (1)"
	ec	CM_TRACE_STABILIZEDCACHEWAIT2,
		"CM StabilizeDCache waiting vp %x, dcp %x (2)"
	ec	CM_TRACE_CACHEFETCHPROC,
		"CM cache fetch proc dcp %x, new pos %d"
	ec	CM_TRACE_FREEALLCOOKIES,
		"CM cm_FreeAllCookies, scp %x"
	ec	CM_TRACE_RESERVEBLOCKSEMERGENCY,
		"CM reserveblocks emergency, scp %x, truncating dcp %x!"
	ec	CM_TRACE_GETTOKENS,
		"CM gettokens vp %x, rights.low %#x"
	ec	CM_TRACE_TOKENRACE,
		"CM token revoke race occurred"
	ec	CM_TRACE_DOPARTIALWRITE,
		"CM in DoPartialWrite"
	ec	CM_TRACE_READMANUALLYONLINE,
		"CM in cm_read, getting chunk online manually"
	ec	CM_TRACE_READZEROES,
		"CM cm_read: read past chunk EOF, padding with zeroes"
	ec	CM_TRACE_READPREFETCH,
		"CM read starting prefetch for offset %d"
	ec	CM_TRACE_SWAPOUTVOL,
		"CM swapping out vol structure at %x"
	ec	CM_TRACE_ASYNCSTART,
		"CM async grant RPC vp %x type %#x range(%d:%d)"
	ec	CM_TRACE_ASYNCEND,
		"CM asycn grant returns code %d"
	ec	CM_TRACE_ASYNCNOSERVER,
		"CM async can't find fid's server"
	ec	CM_TRACE_ASYNCDONE,
		"CM async done, states %#x, code %d"
	ec	CM_TRACE_TKNASYNC,
		"CM TKN_AsyncGrant fid %x.%x.%x.%x, rights %#x"
	ec	CM_TRACE_TKNASYNCDONE,
		"CM TKN_AsyncGrant done for vp %#x"
	ec	CM_TRACE_REFRESHTOKEN1, 
		"CM Refresh Tokens at time %x, opcount %d"
	ec	CM_TRACE_REFRESHTOKEN2, 
		"CM Refresh Tokens done at time %x"
	ec	CM_TRACE_STARTUPDATETOKEN,
		"CM start UpdateTokensLifetime"
	ec	CM_TRACE_UPDATETOKEN,
		"CM Update Tokens for scp %x"
	ec	CM_TRACE_SETPARAMSTART,
		"CM start AFS_SetParams"
	ec	CM_TRACE_SETPARAMEND,
		"CM end AFS_SetParams code %d"
	ec	CM_TRACE_MOVETOKEN,
		"CM restore move tokens"
	ec	CM_TRACE_RECOVERTOKENS,
		"CM recover token renew = %d"
	ec 	CM_TRACE_STARTGETTOKENTSR,
		"CM start TSR AFS_GetToken, type %#x, verNum %d,%d"
	ec 	CM_TRACE_ENDGETTOKENTSR,
		"CM end TSR AFS_GetToken, code %d, type %#x, verNum %d,%d"
	ec	CM_TRACE_RECOVERTOKENSTATE,
		"CM RecoverTokenState, flags %#x, tsrMode %d"
	ec	CM_TRACE_CMREADVDIR,
		"CM cm_ReadVDir exit resid %d"
	ec	CM_TRACE_GETNEWTGT,
		"CM get a new tgt for pag %x, lifetime %x"
	ec 	CM_TRACE_TRYBIND,
		"CM Trybind on name = %s"
	ec	CM_TRACE_TRYBIND1,
		"CM Trybind: cannot get helper"
	ec	CM_TRACE_TRYBIND2,
		"CM Trybind: read helper returns avpp  %x, replyCode %d"
	ec	CM_TRACE_TOKENTSRCTIME,
		"CM  and ctime %#x,%#x vs %#x,%#x"
	ec	CM_TRACE_TSRASYNCSTART,
		"CM TSR Async start with server %x type %#x"
	ec	CM_TRACE_TSRASYNCEND,
		"CM TSR Async end with server %x"
	ec	CM_TRACE_WAKEUPASYNCSTART,
		"CM Wake up async grant from server %x START"
	ec	CM_TRACE_WAKEUPASYNCEND,
		"CM Wake up async grant END"
	ec	CM_TRACE_TOKENERRORMAP,
		"CM GetTokens mapping token conflict to volume busy"
	ec	CM_TRACE_GETHERETOKENS,
		"CM Get HERE Token for volume %#x, request %#x"
	ec	CM_TRACE_REVOKEHEREGC,
		"CM HERE token GC revoke, code %d"
	ec	CM_TRACE_RECOVERHERETOKEN,
		"CM GetHereToken in RecoverTokenState failed, code %d"
	ec	CM_TRACE_RELINQUISH,
		"CM RevokeHereTokens Relinquish! code = %d"
	ec	CM_TRACE_REVOKEHERE_END,
		"CM RevokeHereTokens end, code %d"
	ec	CM_TRACE_ISDOINGTSRMOVE,
		"CM someone else is doing TSR-move, nowait = %d"
	ec	CM_TRACE_CRASHMOVETOKEN,
		"CM TSR-CRASH-MOVE for volume %#x"
	ec	CM_TRACE_MOVEHASDIRTYDATA,
		"CM TSR-MOVE has dirty data in volume %#x, tsr-mode %x"
	ec	CM_TRACE_HAVETOKHARDREPCHECK,
		"CM havetokens: vol %d known %x: past hard limit %d"
	ec	CM_TRACE_HAVETOKGRAYREPCHECK,
		"CM havetokens: vol %d known %x, tried %x: past check interval %d"
	ec	CM_TRACE_PAGEIN,
		"CM pagein vp %x off %x len %x rw=%d"
	ec	CM_TRACE_PAGEINDONE,
		"CM pagein done code %d"
	ec	CM_TRACE_PAGEOUT,
		"CM pageout vp %x off %x len %x flags=%x"
	ec	CM_TRACE_PAGEOUTDONE,
		"CM pageout done code %d"
	ec	CM_TRACE_VMRW,
		"CM vmrw vp %x, write=%d, off=%#x, len=%#x"
	ec	CM_TRACE_SIMTOKENREVOKE,
		"CM Simulating token revoke, scp=%#x rights.low=%#x"
	ec	CM_TRACE_TKNREVSERVER1,
		"CM TKN_TokenRevoke: incoming server %x not scp %x's RW server %x, and no hereServerp for volp %x"
	ec	CM_TRACE_TKNREVSERVER2,
		"CM TKN_TokenRevoke: incoming server %x neither scp %x's RW server %x nor hereServerp %x"
	ec	CM_TRACE_TKNREVSERVER3,
		"CM TKN_TokenRevoke: incoming server %x not scp %x's RW server %x, but same as volp %x's hereServerp"
	ec	CM_TRACE_STRATEGYDONE,
		"CM cm strategy done, vp %#x, code %d, left %#x"
	ec	CM_TRACE_TOKENTSRDV,
		"CM TSR fid %x.%x.%x.%x, data version %u,,%u vs %u,,%u"
	ec	CM_TRACE_TOKENTSRBADSCP,
		"CM TSR fid %x.%x.%x.%x, modChunks %d, modFlags %#x;"
	ec	CM_TRACE_SERVERPOSTCRASH,
		"CM TSR: server back up, fid %x.%x.%x.%x, gettoken flags now %#x"
	ec	CM_TRACE_VOLPOSTMOVE,
		"CM TSR: volume back up, fid %x.%x.%x.%x, gettoken flags now %#x"
	ec	CM_TRACE_TOKENASYNCRACE,
		"CM token async grant race occurred"
	ec	CM_TRACE_MARKBADSCACHE,
		"CM marking scache %#x bad (code is %d)"
	ec	CM_TRACE_TOKENTSRNOCRASHLOCKS,
		"CM TSR fid %x.%x.%x.%x, tsrMode %#x, have LOCKS"
	ec	CM_TRACE_TOKENTSRMOVEDONE,
		"CM TSR fid %x.%x.%x.%x, tsrMode %#x, move finished early"
	ec	CM_TRACE_BADTKNINITID,
		"CM STKN_InitTokenState: no server (IP %#x, UUID %x/%x/%x/%x)"
	ec	CM_TRACE_BADTKNREVOKEID,
		"CM STKN_TokenRevoke: no server (IP %#x, UUID %x/%x/%x/%x)"
	ec	CM_TRACE_BADTKNASYNCGRANTID,
		"CM STKN_AsyncGrant: no server (IP %#x, UUID %x/%x/%x/%x)"
	ec	CM_TRACE_CONNIDSET,
		"CM cm_ConnByHost: setting UUID %x/%x/%x/%x in connp %x"
	ec	CM_TRACE_CONNIDSET2,
		"CM cm_ConnByHost: passing other UUID %x/%x/%x/%x for connp %x"
	ec	CM_TRACE_GENCNTCHANGED,
		"CM cm_ConnByMHosts: found changed gen. count %d -> %d"
	ec	CM_TRACE_STARTSETCONTEXT2,
		"CM cm_ConnByHost: new I/F, server %#lx needs a reset, calling with DO_RESET"
	ec	CM_TRACE_CONNANDRESET,
		"CM cm_ConnAndReset: conn %#lx, server %#lx, service %#lx"
	ec	CM_TRACE_CONNANDRESET2,
		"CM cm_ConnAndReset: conn %#lx, server %#lx: reset %d tokens"
	ec	CM_TRACE_CONNANDRESET3,
		"CM cm_ConnAndReset: conn %#lx, service %#lx: calling AFS_SetContext"
	ec	CM_TRACE_CONNANDRESET4,
		"CM cm_ConnAndReset: conn %#lx: AFS_SetContext result is %d"
	ec	CM_TRACE_TRYWITHOUTID,
		"CM TSR: can't obtain by ID, fid %x.%x.%x.%x, gettoken flags now %#x"
	ec	CM_TRACE_TOKENTSRNOLOCKS,
		"CM TSR fid %x.%x.%x.%x, have LOCKS; gettoken flags %#lx, token types %#lx"
	ec	CM_TRACE_TSRVOLMOVEDONE,
		"CM TSR: move finished already, fid %x.%x.%x.%x, gettoken flags now %#x, tsrMode now %#x"
	ec	CM_TRACE_STOREDATAINVALID,
		"CM cm_StoreDCache: store was invalid, fid %x.%x.%x.%x, from %lu,,%lu for %lu, code %d"
	ec	CM_TRACE_STORESTATUSINVALID,
		"CM cm_StoreDCache: store was invalid, scp %x, fid %x.%x.%x.%x, code %d"
	ec	CM_TRACE_INVALIDATEALLINVALID,
		"CM cm_InvalidateAllSegments: invalidating active store, fid %x.%x.%x.%x, scp states %#lx, storeCount %d, code %d"
	ec	CM_TRACE_INVALIDATEONEINVALID,
		"CM cm_InvalidateOneSegment: invalidating active seg, scp %x, fid %x.%x.%x.%x, dcp states %#lx, code %d"
	ec	CM_TRACE_STORESCACHEINVALID,
		"CM cm_StoreSCache: store was invalid, scp %x, fid %x.%x.%x.%x, code %d"
	ec	CM_TRACE_STOREACLINVALID,
		"CM cm_setacl: store was invalid, scp %x, fid %x.%x.%x.%x, code %d"
	ec	CM_TRACE_STOREACLCONNINVALID,
		"CM cm_setacl: cm_Conn set invalid, scp %x, fid %x.%x.%x.%x, code %d"
	ec	CM_TRACE_STORESCACHECONNINVALID,
		"CM cm_StoreSCache: cm_Conn set invalid, scp %x, fid %x.%x.%x.%x, code %d"
	ec	CM_TRACE_STOREDATACONNINVALID,
		"CM cm_StoreDCache: cm_Conn set invalid, fid %x.%x.%x.%x, from %lu,,%lu for %lu, code %d"
	ec	CM_TRACE_STORESTATUSCONNINVALID,
		"CM cm_StoreDCache: cm_Conn set invalid, scp %x, fid %x.%x.%x.%x, code %d"
	ec	CM_TRACE_REVOKEHEREID,
		"CM RevokeHereToken: holding ID %lu,,%lu for vol %lu,,%lu, so giving %lu,,%lu back to server %x"
	ec	CM_TRACE_REVOKEHERECELL,
		"CM RevokeHereToken: unrecognized cell %lu,,%lu, fid %x.%x.%x.%x, so giving %lu,,%lu back to server %x"
	ec	CM_TRACE_STARTSETCONTEXT_A,
		"CM start recheck AFS_SetContext: conn %x srv level %#x"
	ec	CM_TRACE_ENDSETCONTEXT_A,
		"CM end recheck AFS_SetContext: code %d"
	ec	CM_TRACE_CONNRESETWAITSECPRI,
		"CM cm_ConnAndReset: SECONDARY waiting for PRIMARY: conn %#lx, server %#lx, service %#lx"
	ec	CM_TRACE_CONNRESETWAITOK,
		"CM cm_ConnAndReset: waiting for mutex: conn %#lx, server %#lx, service %#lx"
	ec	CM_TRACE_CVSUPDATE2,
		"CM checkvolsync, same vv: updates time when vv current for vol %lu,,%lu from %lu to %lu"
	ec	CM_TRACE_CVSUPDATE3,
		"CM checkvolsync, advanced vv: updates time when vv current for vol %lu,,%lu from %lu to %lu"
	ec	CM_TRACE_CVSBACK2,
		"CM checkvolsync sees vv going back, vol %lu,,%lu, from vv %lu,,%lu to vv %lu,,%lu"
	ec	CM_TRACE_CVSSET2,
		"CM checkvolsync notes %d fids from vol %lu,,%lu, incidental vv %lu,,%lu, to vv %lu,,%lu"
	ec	CM_TRACE_CVSFLUSH,
		"CM checkvolsync flushed %d fids from vol %lu,,%lu"
	ec	CM_TRACE_CVSSET3,
		"CM checkvolsync finally advances vv for vol %lu,,%lu from %lu,,%lu to %lu,,%lu; reallyvv %lu,,%lu"
	ec	CM_TRACE_FINDSERVERIP,
		"CM cm_FindServerIP: found %#x type %d in serverp %#x"
	ec	CM_TRACE_FINDSERVERIPNOT,
		"CM cm_FindServerIP: could not find %#x type %d"
	ec	CM_TRACE_SETSERVERRANKFX,
		"CM cm_SetServerRank: FX server %#x -> %d"
	ec	CM_TRACE_SETSERVERRANKREP,
		"CM cm_SetServerRank: REP server %#x -> %d"
	ec	CM_TRACE_SETSERVERRANKFL,
		"CM cm_SetServerRank: FL server %#x -> %d"
	ec	CM_TRACE_SETQUEUEDRANK,
		"CM cm_SetServerRank: Existing Qd rank for %#x[%d] -> %d"
	ec	CM_TRACE_QUEUERANK,
		"CM cm_SetServerRank: Adding Qd rank request for %#x[%d] -> %d"
	ec	CM_TRACE_DEFRANK,
		"CM cm_DefaultRank addr %#x type %#x"
	ec	CM_TRACE_DEFRANKSIS,
		"CM cm_DefaultRank found sister server %#x rank %d"
	ec	CM_TRACE_DEFRANKQD,
		"CM cm_DefaultRank Found Qd Req rank %d"
	ec	CM_TRACE_DEFRANKCOMP,
		"CM cm_DefaultRank computed default rank %d"
	ec	CM_TRACE_RESORT,
		"CM cm_ReSortServers: sorting volumes referencing server %#x"
	ec	CM_TRACE_RESORTC,
		"CM cm_ReSortCellSrvs: sorting cells referencing server %#x"
	ec	CM_TRACE_OLDNEWSERVER,
		"CM cm_ConnByMHosts: At position %d old server %#x new server %#x"
	ec	CM_TRACE_TIMEBAD,
		"CM cm_ConnByMHosts: This index [%d] timeBad %#x EarliestIx %d softestError %d"
	ec	CM_TRACE_GENORSERVERCHANGED,
		"CM cm_ConnByMHosts: found either bad server %#x or gen. count changed %d -> %d"
	ec	CM_TRACE_SERVERPOOF,
		"CM cm_ConnByMHosts: The server at index %d is now NULL"
	ec	CM_TRACE_CONNBYHOSTFAILED,
		"CM cm_ConnByMHosts: cm_ConnByHost failed (fatal=%d)"
	ec	CM_TRACE_GENCNTCHANGED2,
		"CM cm_ConnByMHosts: found gen. count changed after cm_ConnByHost %d -> %d"
	ec	CM_TRACE_MARKBADSCACHE_2,
		"CM Finished marking scache %#x bad (code is %d)"
	ec	CM_TRACE_GETSLOCK_ASYNC,
		"CM cm_GetSLock(scp=%#x, tokens=%#x..) discovers async status of %d"
	ec	CM_TRACE_GETSLOCK_TOKRANGE,
		"CM cm_GetSLock(scp=%#x, tokens=%#x..) gets code %d from GetTokensRange"
	ec	CM_TRACE_CM_WRITE_NODCACHE,
		"CM cm_write calls cm_FindDCache(scp=%#x, pos=%#x), returns EIO"
	ec	CM_TRACE_GETDLOCK_ONLINE,
		"CM cm_GetDLock calls GetDOnLine(scp=%#x, dcp=%#x, tokentype=%x,,%x..): code %d"
	ec	CM_TRACE_CM_WRITE_LCLNOGO,
		"CM cm_write calls cm_CFileRDWR, scp=%#x, dcp=%#x: code %d, resid %#x"
	ec	CM_TRACE_CM_WRITE_STOREIT,
		"CM cm_write calls DoPartialWrite(scp=%#x, lastoffs=%#x...): code %d"
	ec	CM_TRACE_STOREALL_SC,
		"CM cm_StoreAllSegments calls StoreSCache(scp=%#x, aflags=%#x..): code %d"
	ec	CM_TRACE_STOREALL_DC,
		"CM cm_StoreAllSegments calls StoreDCache(scp=%#x, dcp=%#x, aflags=%#x..): code %d"
	ec	CM_TRACE_CM_WRITE_STORED,
		"CM DoPartialWrite calls cm_StoreDCache(scp=%#x, dcp=%#x, ...): code %d"
	ec	CM_TRACE_BKGDONE,
		"CM bkgDaemon done with req %#x opcode %d: code %d"
	ec	CM_TRACE_BKGWAITED,
		"CM bkgWait read req %#x and got code %d"
	ec	CM_TRACE_BKGQUEUED,
		"CM bkgQueue returns req %#x, doing op %d on %#x"
	ec	CM_TRACE_BKGRELEASE,
		"CM bkgRelease releasing req %#x"
	ec	CM_TRACE_FLUSHEXISTS,
		"CM cm_FlushExists considering flushing name %s in dir %#x for EEXIST error"
	ec	CM_TRACE_FLUSHEXISTS_1,
		"CM cm_FlushExists: nh_lookup returns code=%d, vnode=%d"
	ec	CM_TRACE_FLUSHEXISTS_2,
		"CM cm_FlushExists FLUSHING name %s in dir %#x for EEXIST error"
	ec	CM_TRACE_CVSSET5,
		"CM checkvolsync: flushing(#%d) fid %x.%x.%x.%x, type %d vp %x"
	ec	CM_TRACE_CVSSET6,
		"CM checkvolsync: we flushed input fid %x.%x.%x.%x, so return CM_REP_ADVANCED_AGAIN"
	ec	CM_TRACE_GETDONLINEHARDER,
		"CM cm_GetDOnLine: Checking for fetch: scp dv %lu,,%lu, dcp dv %lu,,%lu, scp type %ld"
	ec	CM_TRACE_NEEDRPC_YES,
		"CM cm_NeedRPC(%lu,,%lu): Yes, we have to make an RPC"
	ec	CM_TRACE_FAST_RPC_ERROR_RESET, 
		"CM cm_ConnAndReset: RPC rejection in %d seconds!" 
	ec	CM_TRACE_FAST_RPC_ERROR_SETCTX, 
		"CM cm_ConnByHost: RPC rejection in %d seconds!" 
	ec	CM_TRACE_PUTAPAGE_PAST_EOF,
		"CM cm_putapage throwing away page past EOF. scp %x length %x offset %x\n"
	ec 	CM_TRACE_GETPAGE_PAST_EOF,
		"CM cm_getpage request fully past EOF, scp %x scp->m.Length %x offset %x len %x"
	ec	CM_TRACE_SETFL,
		"CM cm_setfl vp %x, oflags %#x, nflags %#x"
	ec	CM_TRACE_CHECKOPENS,
		"CM cm_CheckOpens(%x, %d): opens %d, v_count %d"
	ec	CM_TRACE_CHECKOPENS_2,
		"CM cm_CheckOpens: opens %d, readers %d, writers %d, shareds %d; CLEARING"
	ec	CM_TRACE_ADDMAP,
		"CM cm_addmap(%x): prot %#lx, flags %#lx: setting RMAPPED, WMAPPED"
	ec	CM_TRACE_PAGEIN_SETMAPPED,
		"CM cm_getpage(%x): setting RMAPPED, WMAPPED"
	ec	CM_TRACE_MAP_SETMAPPED,
		"CM cm_map(%x): prot %#lx, maxprot %#lx, flags %#lx; setting RMAPPED, WMAPPED"
	ec	CM_TRACE_CALLING_REFRESH,
		"CM cm_RefreshKeepAlives(): calling %x with %d fids, for example %x.%x.%x.%x"
	ec	CM_TRACE_ADD_REFR,
		"CM cm_RefreshKeepAlives(), spot %d: adding fid %d for %x: %x.%x.%x.%x"
	ec	CM_TRACE_ADD_EXPR,
		"CM cm_RefreshKeepAlives(): overwriting expr of %x (fid %x.%x.%x.%x), was %d"
	ec	CM_TRACE_STOREDATANOTOKENS,
		"CM cm_StoreDCache: storing chunk without tokens, fid %x.%x.%x.%x, from %lu,,%lu for %lu (scp = %x)"
	ec	CM_TRACE_STOREDATANOTINLINE,
		"CM cm_StoreDCache: storing offline chunk, fid %x.%x.%x.%x, from %lu,,%lu for %lu (dcp = %x)"
	ec	CM_TRACE_VDIR_RECLAIM,
		"CM cm_ReclaimVDirs: Vdir count is %d, so reclaming"
	ec	CM_TRACE_VDIR_RECLAIMING_NOW,
		"CM cm_ReclaimVDirs: scp %x, name '%s', giving vp %x; vdirp states %#lx"
	ec	CM_TRACE_VDIR_RECLAIM_DONE,
		"CM cm_ReclaimVDirs: Ending; inspected %d vdirs; freed %d vdirs; count %d"
# the following 3 messages are no longer used
	ec	CM_TRACE_VDIRGC_NEWCOUNT,
		"CM cm_GCVDirs: Ending; vdir count is now %d, after %d loops"
	ec	CM_TRACE_VDIRGC_NEWMINTIMEOUT,
		"CM cm_GCVDirs: advancing minTimeout from %d to %d"
	ec	CM_TRACE_VDIRGC_GCING_NOT,
		"CM cm_GCVDirs: Bypassing GC since only %d seconds since %d"
	ec	CM_TRACE_CONN_INTERRUPTED,
		"CM cm_ConnByMHosts: Sleep interrupted"
	ec	CM_TRACE_TKMSLEEP_INTERRUPTED,
		"CM cm_Analyze: TKM-induced sleep interrupted"
	ec	CM_TRACE_BUSYSLEEP_INTERRUPTED,
		"CM cm_Analyze: vol-induced sleep interrupted"
	ec	CM_TRACE_FIXCELLROOT,
		"CM cm_RevalidateCellRoot: from volid %lu,,%lu to %lu,,%lu (%s)"
	ec	CM_TRACE_GETCELLROOT,
		"CM cm_DoCellRootScp: using fid %x.%x.%x.%x"
	ec	CM_XXX_OBSOLETE_2,
		"CM used to be CM_TRACE_QUEUESETSIZE"
	ec	CM_TRACE_SETPARAMSTART_1,
		"CM start AFS_SetParams, server %x, to set client size of %#x"
	ec	CM_TRACE_SETPARAMEND_1,
		"CM end AFS_SetParams got server size of %#x: code %d"
	ec	CM_TRACE_TKNSETPARAMS_MORE,
		"CM TKN_SetParams called: flag %d, mask %#x"
	ec	CM_TRACE_TSRRACINGREVOKE,
		"CM cm_RecoverSCacheToken: racing revoke for fid %x.%x.%x.%x, ID %lu,,%lu"
	ec	CM_TRACE_BULKSTAT,
		"CM cm_BulkFetchStatus: scp %x"
	ec	CM_TRACE_BULKSTAT_OFFSET,
		"CM bulkstat: offset %d out of range %d"
	ec	CM_TRACE_BULKSTAT_NORPC,
		"CM bulkstat: server does not export bulkstat"
	ec	CM_TRACE_BULKSTAT_OTHERCLIENT,
		"CM bulkstat: some other client changed dir"
	ec	CM_TRACE_BULKSTAT_OTHERTHREAD,
		"CM bulkstat: some other thread changed dir"
	ec	CM_TRACE_BULKSTAT_NOTOK,
		"CM bulkstat: token revoked"
	ec	CM_TRACE_BULKSTAT_ERROR,
		"CM bulkstat: error for file %s"
	ec	CM_TRACE_BULKSTAT_END,
		"CM cm_BulkFetchStatus: scp %x, error %d"
	ec	CM_TRACE_BULKSTAT_DELETED,
		"CM bulkstat: error for file %s"
	ec	CM_TRACE_RESTOREMOVE_PREP,
		"CM cm_RestoreMoveTokens: About to check tokens; orig=%x, new=%x"
	ec	CM_TRACE_RESTOREMOVE_FAIL_1,
		"CM cm_RestoreMoveTokens: VALIDATE on!  Fid %x.%x.%x.%x, token flags %#x, server %x, types %x"
	ec	CM_TRACE_RESTOREMOVE_FAIL_2,
		"CM cm_RestoreMoveTokens: on old server!  Fid %x.%x.%x.%x, token flags %#x, server %x, types %x"
	ec	CM_TRACE_RESTOREMOVE_FAIL_3,
		"CM cm_RestoreMoveTokens: not on new server!  Fid %x.%x.%x.%x, token flags %#x, server %x, types %x"
	ec	CM_TRACE_REDUNDANT1,
		"CM cm_StripRedundantTokens: token id %lu,,%lu types %x reduced by id %lu,,%lu types %x"
	ec	CM_TRACE_REDUNDANT2,
		"CM cm_StripRedundantTokens: token %x, id %lu,,%lu, types %x reduced to %x"
	ec	CM_TRACE_NOTREALLYDOWN,
		"CM cm_ServerDown(%x): (lastcall=%d + TTL=%d) later than now=%d: server stays up"
	ec	CM_TRACE_TRYLOCKREV_2,
		"CM tryLockRevoke preserving %lx: type %d, [%lx..%lx]"
	ec	CM_TRACE_TRYLOCKREV_3,
		"CM tryLockRevoke blocked preserving type %d [%lx..%lx] pid %d"
	ec	CM_TRACE_TRYLOCKREV_4,
		"CM tryLockRevoke returning token type %d, id %lx,,%lx, flags %#lx"
	ec	CM_TRACE_ANALYZEFID,
		"CM cm_Analyze: conn %x, code %d, pag %x,\n                               fid %x.%x.%x.%x"
	ec	CM_TRACE_ADJSIZE_ENTRY,
		"CM cm_AdjustSize: dcp %x has chunkBytes %x, startDirty %x, endDirty %x"
	ec	CM_TRACE_ADJSIZE_EXIT,
		"CM cm_AdjustSize: newSize %x: now chunkBytes %x, startDirty %x, endDirty %x"
	ec	CM_TRACE_QUICKDISCARD,
		"CM cm_QuickDiscard: dcp %x starts with chunkBytes %x, startDirty %x, endDirty %x"
	ec	CM_TRACE_SETCHUNKRANGE_1,
		"CM cm_SetChunkDirtyRange: dcp %x starts with startDirty %x, endDirty %x"
	ec	CM_TRACE_SETCHUNKRANGE_2,
		"CM cm_SetChunkDirtyRange: given start=%x, end=%x; ends with startDirty %x, endDirty %x"
	ec	CM_TRACE_HOTWIRE1,
		"CM cm_HotWireSegment: scp %x, dcp %x, offset %x, checkLength %x"
	ec	CM_TRACE_HOTWIRE2,
		"CM cm_HotWireSegment: dcp %x (being hotwired) starts with chunkBytes %x, startDirty %x, endDirty %x"
	ec	CM_TRACE_MERGESTATLENGTH,
		"CM cm_MergeStatus(%x): overwriting our cached %lu,,%lu with low half of %lu,,%lu"
	ec	CM_TRACE_GETDONL_LENGTHS,
		"CM cm_GetDOnLine: scp length now 0,,%#x, chunk start %x, chunkBytes %x"
	ec	CM_TRACE_CONN_CLASH,
		"CM cm_Conn: conn %x already in use (callCount %d); recycling."
	ec	CM_TRACE_MARKEXPIRED,
		"CM mark TGT expired for pag %x"
	ec	CM_TRACE_GETTGTTIME2,
		"CM TGTLifeTime(pag %x) gives time %x, expired %d"
	ec	CM_TRACE_AUTHN_DINKING,
		"CM cm_ReactToAuthCodes: conn %x, authn %d, authz %d"
	ec	CM_TRACE_SERVER_HIGH_AUTHN,
		"CM cm_ReactToAuthnCodes: server %x (%d..%d): max goes to %d"
	ec	CM_TRACE_SERVER_LOW_AUTHN,
		"CM cm_ReactToAuthnCodes: server %x (%d..%d): min goes to %d"
	ec	CM_TRACE_VOLUME_HIGH_AUTHN,
		"CM cm_ReactToAuthnCodes: volume %x (%d..%d): max goes to %d"
	ec	CM_TRACE_VOLUME_LOW_AUTHN,
		"CM cm_ReactToAuthnCodes: volume %x (%d..%d): min goes to %d"
	ec	CM_TRACE_AUTHNFAIL1,
		"CM cm_Conn: volp %x, cell flags %d: authn LB %d exceeds UB %d"
	ec	CM_TRACE_AUTHNFAIL2,
		"CM cm_Conn: volp %x, cell flags %d: authn LB %d >none (UB %d), but authz NONE"
	ec	CM_TRACE_AUTHNBOUND1,
		"CM cm_Conn: volp %x, cell flags %d: authn %d raised to LB %d"
	ec	CM_TRACE_AUTHNBOUND2,
		"CM cm_Conn: volp %x, cell flags %d: authn %d lowered to UB %d"
	ec	CM_TRACE_CONN_GIVINGUP,
		"CM cm_Conn: giving up.  forceUnauth %d, exp'd %d, authn %d, authz %d"
	ec	CM_TRACE_CONN_WITHAUTH,
		"CM cm_ConnByHost using conn %x, service %#x, authn %d, authz %d"
	ec	CM_TRACE_CONN_AUTHRESULT,
		"CM cm_ConnByHost authenticating conn %x: result %d, authn %d, authz %d"
	ec	CM_TRACE_INSTALLVOL_BADLIMITS,
		"CM cm_InstallVolumeEntry: volume %lu,,%lu has bad min/max auth limits: min %d, max %d"
	ec	CM_TRACE_GC_TGT,
		"CM GCOldConn: GCing tgt entry %x with pag %x, time %d, flags %#x"
	ec	CM_TRACE_GETNEWTGT_CALL,
		"CM newtgt(pag %x, lifetime %x) called"
	ec	CM_TRACE_GETNEWTGT_CALL_OLD,
		"CM newtgt(): lifeTime expired: returning EINVAL"
	ec	CM_TRACE_GETNEWTGT_ACCESS,
		"CM newtgt(): mypag %x, pag %x: not super-user, so returning EACCES"
	ec	CM_TRACE_CONN_BADAUTHCACHE,
		"CM cm_ConnByHost: isExp %d, cached conn expiry %d, forceUnauth %d: restarting."
	ec	CM_TRACE_CONN_DOWNMAXSUPP,
		"CM cm_ConnByHost: unsupported_authn: taking maxSupp from %d to %d; LB currently %d" 
	ec	CM_TRACE_ANA_DOWNMAXSUPP,
		"CM cm_ReactToAuthCodes: unsupported_authn: taking maxSupp from %d to %d; LB currently %d" 
	ec	CM_TRACE_ANA_HARDUB,
		"CM cm_ReactToAuthnCodes: raised LB %d -> %d but cannot raise UB %d past maxSupp %d"

	ec	CM_TRACE_CRMOUNT,
		"CM cm_PCreateMountPoint: vnode %x"
	ec	CM_TRACE_CRMOUNT_END,
		"CM cm_PCreateMountPoint returns code %d"

	ec	CM_TRACE_RANK_PUT,
		"CM cm_AddrRankPut(addr=%#lx, svc=%ld, rank=%ld)"
	ec	CM_TRACE_RANK_GET,
		"CM cm_AddrRankGet(addr=%#lx, svc=%ld) yields rank=%ld returning %ld"
	ec	CM_TRACE_RANK_COMP,
		"CM cm_AddrRankCompute(addr=%#lx) returning %ld"

	ec	CM_TRACE_SITE_ALLOC_ENTER,
		"CM cm_SiteAlloc(svc=%ld, addrvp=%#lx, addrvcnt=%ld)"
	ec	CM_TRACE_SITE_ALLOC_EXIT,
		"CM cm_SiteAlloc(svc=%ld, addrvp=%#lx) returns sitep=%#lx"

	ec	CM_TRACE_SITE_ADDRREPLACE_ENTER,
		"CM cm_SiteAddrReplace(sitep=%#lx, addrvp=%#lx, addrvcnt=%ld)"
	ec	CM_TRACE_SITE_ADDRREPLACE_SAME,
		"CM cm_SiteAddrReplace(sitep=%#lx) same addrs, returning"
	ec	CM_TRACE_SITE_ADDRREPLACE_EXIT,
		"CM cm_SiteAddrReplace(sitep=%#lx) returning"

	ec	CM_TRACE_SITE_ADDRUPDATE_CHANGE,
		"CM SiteAddrUpdate(sitep=%#lx) same-addr=%ld, new-addr=%ld"
	ec	CM_TRACE_SITE_ADDRUPDATE_GEN,
		"CM SiteAddrUpdate(sitep=%#lx) addr-gen bumped to=%ld"

	ec	CM_TRACE_SITE_SETRANK_ENTER,
		"CM cm_SiteAddrSetRankAll(addr=%#lx, svc=%ld, rank=%ld)"
	ec	CM_TRACE_SITE_SETRANK_CHANGE,
		"CM cm_SiteAddrSetRankAll(addr=%#lx) setting for sitep=%#lx"
	ec	CM_TRACE_SITE_SETRANK_GEN,
		"CM cm_SiteAddrSetRankAll(addr=%#lx) addr-gen bumped to=%ld"
	ec	CM_TRACE_SITE_SETRANK_EXIT,
		"CM cm_SiteAddrSetRankAll(addr=%#lx) returning"

	ec	CM_TRACE_SITE_ADDRDOWN_ENTER,
		"CM cm_SiteAddrDown(sitep=%#lx, addr=%#lx)"
	ec	CM_TRACE_SITE_ADDRDOWN_GEN,
		"CM cm_SiteAddrDown(sitep=%#lx) addr-gen bumped to=%ld"
	ec	CM_TRACE_SITE_ADDRDOWN_EXIT,
		"CM cm_SiteAddrDown(sitep=%#lx) returning %ld"

	ec	CM_TRACE_SITE_ADDRUP_ENTER,
		"CM cm_SiteAddrUp(sitep=%#lx, addr=%#lx)"
	ec	CM_TRACE_SITE_ADDRUP_GEN,
		"CM cm_SiteAddrUp(sitep=%#lx) addr-gen bumped to=%ld"
	ec	CM_TRACE_SITE_ADDRUP_EXIT,
		"CM cm_SiteAddrUp(sitep=%#lx) returning"

	ec	CM_TRACE_SITE_MARKALLUP_ENTER,
		"CM cm_SiteAddrMarkAllUp(sitep=%#lx, ifAllDown=%ld)"
	ec	CM_TRACE_SITE_MARKALLUP_GEN,
		"CM cm_SiteAddrMarkAllUp(sitep=%#lx) addr-gen bumped to=%ld"
	ec	CM_TRACE_SITE_MARKALLUP_EXIT,
		"CM cm_SiteAddrMarkAllUp(sitep=%#lx) returning"

	ec	CM_TRACE_CONNBYMHOSTS_LASTHIT,
		"CM cm_ConnByMHosts(service=%#lx) last-server info reused"
	ec	CM_TRACE_CONNBYMHOSTS_SUCCESS,
		"CM cm_ConnByMHosts(service=%#lx) try-addr=%#lx, got-addr=%#lx, successful, returning connp=%#lx"
	ec	CM_TRACE_GENCHANGED_ADDRORHOST,
		"CM cm_ConnByMHosts: addr or host gen count change noticed"

	ec	CM_TRACE_CONNBYHOST_RESULT,
		"CM cm_ConnByHost(service=%#lx) try-addr=%#lx, got-addr=%#lx, with result connp=%#lx"

	ec	CM_TRACE_REVIVEADDRS_ENTER,
		"CM cm_ReviveAddrsForServers() entered"
	ec	CM_TRACE_REVIVEADDRS_EXIT,
		"CM cm_ReviveAddrsForServers() returning"

	ec	CM_TRACE_REVIVEADDRS_SERVER_ENTER,
		"CM ReviveAddrsForServer(serverp=%#lx) entered"
	ec	CM_TRACE_REVIVEADDRS_SERVER_CONFLICT,
		"CM ReviveAddrsForServer(serverp=%#lx) in progress, returning"
	ec	CM_TRACE_REVIVEADDRS_SERVER_NOCONN,
		"CM ReviveAddrsForServer(serverp=%#lx) no conn for addr=%#lx"
	ec	CM_TRACE_REVIVEADDRS_SERVER_CONN,
		"CM ReviveAddrsForServer(serverp=%#lx) tried addr=%#lx with result code=%ld"
	ec	CM_TRACE_REVIVEADDRS_SERVER_EXIT,
		"CM ReviveAddrsForServer(serverp=%#lx) returning"

	ec	CM_TRACE_FXREPFETCH_SCHED_ENTER,
		"CM cm_FxRepAddrFetch() entered"
	ec	CM_TRACE_FXREPFETCH_SCHED_FAILED,
		"CM cm_FxRepAddrFetch() queue request failed"
	ec	CM_TRACE_FXREPFETCH_SCHED_EXIT,
		"CM cm_FxRepAddrFetch() returning"

	ec	CM_TRACE_FXREPFETCH_ENTER,
		"CM FxRepAddrFetch(fxserverp=%#lx, repserverp=%#lx) entered"
	ec	CM_TRACE_FXREPFETCH_NOCONN,
		"CM FxRepAddrFetch() unable to get conn"
	ec	CM_TRACE_FXREPFETCH_STARTGETINFO,
		"CM FxRepAddrFetch() start VL_GetSiteInfo()"
	ec	CM_TRACE_FXREPFETCH_ENDGETINFO,
		"CM FxRepAddrFetch() end VL_GetSiteInfo(), code=%ld"
	ec	CM_TRACE_FXREPFETCH_EXIT,
		"CM FxRepAddrFetch(fxserverp=%#lx, repserverp=%#lx) returning"

	ec	CM_TRACE_SETSERVERSIZE,
		"CM 64-bit server (%p) maxFileSize is %#x,,%#x"
	ec	CM_TRACE_SETSERVERSIZE_OLD,
		"CM 32-bit server (%p) maxFileSize is %#x,,%#x"
	ec	CM_TRACE_MERGESTATLONGLEN,
		"CM mergestatus length %u,,%u too long"

	ec	CM_TRACE_SITE_RANKOVERRIDE_ENTER,
		"CM cm_SiteAddrRankOverride(sitep=%#lx, addr=%#lx) entered"
	ec	CM_TRACE_SITE_RANKOVERRIDE_GEN,
		"CM cm_SiteAddrRankOverride(sitep=%#lx) addr-gen bumped to=%ld"
	ec	CM_TRACE_SITE_RANKOVERRIDE_EXIT,
		"CM cm_SiteAddrRankOverride(sitep=%#lx) returning"

	ec	CM_TRACE_REACTBINDCHANGE_ENTER,
		"CM cm_ReactToBindAddrChange(connp=%#lx, doOverride=%ld) conn-addr=%#lx, bind-addr=%#lx"
	ec	CM_TRACE_REACTBINDCHANGE_ADDRERR,
		"CM cm_ReactToBindAddrChange(connp=%#lx, doOverride=%ld) err getting addr=%ld"

	ec	CM_TRACE_RESETAUTHN_ENTER,
		"CM running cm_ResetAuthnForServers()"
end
