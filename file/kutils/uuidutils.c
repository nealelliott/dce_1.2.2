/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 */
/*
 * HISTORY
 * $Log: uuidutils.c,v $
 * Revision 1.1.42.1  1996/10/02  17:53:31  damon
 * 	Newest DFS from Transarc
 * 	[1996/10/01  18:41:36  damon]
 *
 * Revision 1.1.37.2  1994/06/09  14:12:25  annie
 * 	fixed copyright in src/file
 * 	[1994/06/09  13:25:50  annie]
 * 
 * Revision 1.1.37.1  1994/02/04  20:21:56  devsrc
 * 	Merged from 1.0.3a to 1.1
 * 	[1994/02/04  15:14:35  devsrc]
 * 
 * Revision 1.1.35.2  1994/01/20  18:43:24  annie
 * 	added copyright header
 * 	[1994/01/20  18:39:39  annie]
 * 
 * Revision 1.1.35.1  1993/12/07  17:27:32  jaffe
 * 	1.0.3a update from Transarc
 * 	[1993/12/03  15:43:22  jaffe]
 * 
 * $EndLog$
 */

#include <dcedfs/param.h>                  /* Should be always first */
#include <dcedfs/stds.h>
#include <dcedfs/sysincludes.h>
#include <dcedfs/queue.h>
#include <dce/nbase.h>
#ifdef KERNEL
#include <dcedfs/osi_net.h>
#include <dcedfs/lock.h>
#include <dce/ker/pthread.h>
#endif /* KERNEL */

RCSID("$Header: /u0/rcs_trees/dce/rcs/file/kutils/uuidutils.c,v 1.1.42.1 1996/10/02 17:53:31 damon Exp $")

#ifdef KERNEL
struct lock_data dfsuuid_lock;
#endif /* KERNEL */

/* test to see if a uuid is odd or not */
dfsuuid_GetParity(uuidp)
  uuid_t *uuidp;
{
    return (uuidp->time_low & 1);
}

/* allocate a uuid with the low order bit of time_low field 0 iff
 * isFermion is 0.  Tries reasonably hard to ensure that we won't
 * generate a UUID that would be generated by some other process, but
 * lack of a pid in the UUID structure itself makes this hard to really
 * guarantee.  Put uuid in *uuidp and return an error code.
 */
dfsuuid_Create(uuidp, isFermion)
  uuid_t *uuidp;
  int isFermion;
{
    uuid_t id1, id2;
    unsigned32 st;
    static int initd = 0;

#ifdef KERNEL
    if (!initd) {
	lock_Init(&dfsuuid_lock);
	initd = 1;
    }
    lock_ObtainWrite(&dfsuuid_lock);
#endif /* KERNEL */
    /* allocate a pair of uuids, if necessary, and return one with
     * the appropriate low order bit.
     */
    uuid_create(&id1, &st);
    if ((id1.time_low & 1) == isFermion) {
	*uuidp = id1;
	goto done;
    }
    /* otherwise we got the wrong type of uuid, so get another and
     * return an appropriate UUID whose time_low field has the
     * proper parity and lies between id1.time_low and id2.time_low.
     * Note that we may not used id2, but even creating it guarantees
     * that the clock has advanced past a certain point.
     */
    uuid_create(&id2, &st);
    if ((id2.time_low & 1) == isFermion) {
	*uuidp = id2;
	goto done;
    }
    /* otherwise id1 and id2 have the same, wrong, parity.  Some
     * uuid between the two should have the right parity.  We've also
     * held a lock, and so no one else using this allocation scheme
     * within this addr space should have allocated any intervening
     * UUID.  So, return one of the intervening UUIDs, for example
     * id1.time_low+1, with the proper parity.
     * Note that id2.time_low may be lower than id1.time_low if the
     * clock_seq field changed, but if that happened, no further UUIDs
     * in id1's clock_seq series will be used.
     */
    id1.time_low++;	/* adjust id1 to have the right parity */
    *uuidp = id1;

  done:
#ifdef KERNEL
    lock_ReleaseWrite(&dfsuuid_lock);
#endif /* KERNEL */
    return 0;
}
