/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 * 
 */

#include <pthread.h>
#include <stdio.h>
#include <errno.h>
#include <locale.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <pwd.h>
#include <dce/dce.h>
#include <dce/dce_msg.h>
#include <dce/dcesvcmsg.h>
#include <dcemcpmsg.h>
#include <tcl.h>
#include <moscp.h>
#include <util_login.h>

Tcl_Interp *attr_interp;
Tcl_Interp *dir_interp;
boolean32 check_visible_pw = FALSE;

/* shouldn't these be generated by sams? */
dce_svc_subcomp_t mcp_svc_table[1];
dce_svc_handle_t mcp_svc_handle;

/* Prototypes */
#define DCP_MAX_CMD_SIZE                2048

/* Prototypes */
int main(int, char **);
int Tcl_AppInit(Tcl_Interp *);
void init_mcp_svc(void);
void init_cds_attribute_table(Tcl_Interp *);
void init_rgy_attribute_table(Tcl_Interp *);
void init_schema_attribute_table(Tcl_Interp *);
void setup_signal_handling(void);
char *readline(char *);


int
main(int argc, char *argv[])
{
    Tcl_Interp                    *interp;
    Tcl_DString                   command;
    char                          buffer[DCP_MAX_CMD_SIZE];
    char                          *cmd, *args, *line, *fileName;
    int                           code, gotPartial, tty, got_signal;
    int                           exitCode = 0;
    boolean32                     echo_commands = FALSE;
    char                          *p;
    char                          *tcl_var;
    error_status_t		  msg_st;
    /* 
     * User-specific startup script. Only loaded when we are running
     * interactively. 
     */
    char                          *tcl_RcFileName = "~/.dcecprc";	

    /* Initialize Tcl incore messages */
    dce_msg_define_msg_table (dce_tcl_g_table,
                        sizeof dce_tcl_g_table / sizeof dce_tcl_g_table[0],
			&msg_st);

    if (msg_st != rpc_s_ok)
        fprintf(stderr, "Unable to open Tcl message table\n");
    
    /* Create the interpreters */
    interp = Tcl_CreateInterp();
    
    /*
     * Make command-line arguments available in the Tcl variables "argc"
     * and "argv".  If the first argument doesn't start with a "-" then
     * strip it off and use it as the name of a script file to process.
     */
    fileName = NULL;
    if ((argc > 1) && (argv[1][0] != '-')) {
        fileName = argv[1];
        argc--;
        argv++;
    }
    args = Tcl_Merge(argc-1, argv+1);
    Tcl_SetVar(interp, "argv", args, TCL_GLOBAL_ONLY);
    ckfree(args);
    sprintf(buffer, "%d", argc-1);
    Tcl_SetVar(interp, "argc", buffer, TCL_GLOBAL_ONLY);
    Tcl_SetVar(interp, "argv0", (fileName != NULL) ? fileName : argv[0],
               TCL_GLOBAL_ONLY);
    
    /* Set the "tcl_interactive" variable. */
    tty = isatty(0);
    Tcl_SetVar(interp, "tcl_interactive",
               ((fileName == NULL) && tty) ? "1" : "0", TCL_GLOBAL_ONLY);
    
    /* Application initialization */
    if (Tcl_AppInit(interp) != TCL_OK) {
        fprintf(stderr, "Application initialization failed: %s\n", interp->result);
    }
    

    /* If a script file was specified then just source that file and quit. */
    if (fileName != NULL) {
        code = Tcl_EvalFile(interp, fileName);
        if (code != TCL_OK) {
            fprintf(stderr, "%s\n", interp->result);
            exitCode = 1;
        }
        goto done;
    }
    
    /*
     * Source a user-specific startup file if Tcl_AppInit specified one 
     * and if the file exists.
     */
    if (tcl_RcFileName != NULL) {
        Tcl_DString DSbuffer;
        char *fullName;
        
        fullName = Tcl_TildeSubst(interp, tcl_RcFileName, &DSbuffer);
        if (fullName == NULL) {
            fprintf(stderr, "%s\n", interp->result);
        } else {
            if (access(fullName, R_OK) == 0) {
                code = Tcl_EvalFile(interp, fullName);
                if (code != TCL_OK) {
                    fprintf(stderr, "%s\n", interp->result);
                }
            }
        }
        Tcl_DStringFree(&DSbuffer);
    }
    

    /* Squash any result that previous startup commands may have left around */
    Tcl_ResetResult(interp);
    

    /*
     * Process commands from stdin until there's an end-of-file.
     */

    setup_signal_handling();
    gotPartial = 0;
    Tcl_DStringInit(&command);

    if (!tty) {
        tcl_var = Tcl_GetVar(interp, "dcecp_echo_commands", TCL_GLOBAL_ONLY);
        if (tcl_var && !strcmp(tcl_var, "1")) {
            echo_commands = TRUE;
        }
        if (tcl_var) {
            free(tcl_var);
        }
    }


  top:
    got_signal = 0;
    TRY {
	for (;;) {
	    clearerr(stdin);
	    if (tty) {
		char *promptCmd;
		
		promptCmd = Tcl_GetVar(interp,
				       gotPartial ? "tcl_prompt2" : "tcl_prompt1", 
				       TCL_GLOBAL_ONLY);
		if (promptCmd == NULL) {
		  defaultPrompt:
		    if (!gotPartial) {
			Tcl_SetResult(interp, "moscp> ", TCL_STATIC);
		    }
		    else {
			Tcl_SetResult(interp, "> ", TCL_STATIC);
		    }
		} else {
		    code = Tcl_Eval(interp, promptCmd);
		    if (code != TCL_OK) {
			goto defaultPrompt;
		    }
		}
		fflush(stdout);
	    }
	    
            
            if (tty) {
                line = readline(interp->result);
            }
            else {
                if (fgets(buffer, DCP_MAX_CMD_SIZE, stdin) == NULL) {
                    line = NULL;
                }
                else {
                    line = dce_strdup(buffer);
                    
                    if (echo_commands) {
                        fwrite(line, strlen(line), 1, stdout);
                    } 
                } 
            }

	    if (line == NULL) {
		if (ferror(stdin)) {
		    if (errno == EINTR) {
			if (tcl_AsyncReady) {
			    (void) Tcl_AsyncInvoke((Tcl_Interp *) NULL, 0);
			}
			clearerr(stdin);
		    } else {
			goto done;
		    }
		} else {
		    /* Handle EOF at begining of line */
		    if (gotPartial) {
			/* 
			 * if in middle of multi-line command, clean up and 
			 * goto top level prompt. 
			 */
			gotPartial=0;
			Tcl_DStringFree(&command);
			continue;
		    } else {
			/* At top level command, exit dcecp */
			goto done;
		    }
		}
                buffer[0] = 0;
            }
            add_history(line);
	    strcpy(buffer, line);
	    free(line);
	    
	    /* 
	     * This is needed because readline strips off the trailing
	     * newline. This makes writing interactive multi-line commands
	     * fail.
	     */
	    strcat(buffer, "\n");
	    
	    cmd = Tcl_DStringAppend(&command, buffer, -1);
            if ((buffer[0] != 0) && !Tcl_CommandComplete(cmd)) {
		gotPartial = 1;
		continue;
	    }
	    
	    gotPartial = 0;
	    code = Tcl_RecordAndEval(interp, cmd, 0);
	    Tcl_DStringFree(&command);
	    
	    if (code != TCL_OK) {
                if (tty) {
                    char *info_cmd="puts stderr [format {Error: %s} [set errorInfo]]";
                    tcl_var = Tcl_GetVar(interp, 
                                         "dcecp_verbose_errors", 
                                         TCL_GLOBAL_ONLY);
                    if (tcl_var && !strcmp(tcl_var, "1")) {
                        Tcl_Eval(interp, info_cmd);
                    } else {
                        fprintf(stderr, "Error: %s\n", interp->result);
                    }
                }
                exitCode = 1;
	    } 
            else if (*interp->result != 0) { 
                
                /* 
                 * We are not using printf() here because it has a limit
                 * (at least on OSF/1) of how much it can print at once.
                 * fwrite() and fputs() have the same problem as printf().
                 */
                p = interp->result;
                while(*p != '\0') {
                    putchar(*p);
                    p++;
                }
                printf("\n");
                exitCode = 0;
	    } 

	    /* No matter what, save the result in $_r */
	    DCP_GENERAL_SET_R_VAR(interp->result);
	    
	} /* End of while(1) loop */
    }    
    CATCH_ALL {
	got_signal = 1;
    }

    ENDTRY
    if (got_signal) {
	gotPartial=0;
	Tcl_DStringFree(&command);
	goto top;
    }
    

    /*
     * Rather than calling exit, invoke the "exit" command so that
     * users can replace "exit" with some other command to do additional
     * cleanup on exit.  The Tcl_Eval call should never return.
     */
    
  done:
    sprintf(buffer, "exit %d", exitCode);
    Tcl_Eval(interp, buffer);
    return 1;
}

/*
 * setup_signal_handling
 *
 * Arrange to catch SIGINT thread-safely, so we can return to dcecp
 * main prompt rather than killing dcecp session.
 */

void
setup_signal_handling(void)
{
    sigset_t set;
    pthread_t me;

    sigemptyset(&set);
    sigaddset(&set, SIGINT);
    me = pthread_self();
    pthread_signal_to_cancel_np(&set, &me);
}


/* 
 * Tcl_AppInit
 * 
 * Do application specific startup stuff here
 *
 */
int
Tcl_AppInit(Tcl_Interp *interp)
{
    int                           argc, result, argv_index, new_index;
    char                          **argv;
    char                          *p;
    boolean32                     standalone_flag = FALSE;
    boolean32                     command_flag = FALSE;
    char                          *cds_attr_eval_file = "attr_eval.tcl";
    char                          *cds_dir_ops_file = "dir_ops.dcecp";
    char                          temp_attr_eval_file[256];
    char                          command[1024], *one_command = NULL;

    /* Set the locale and initialize the msg table */
    (void)setlocale(LC_ALL, "");
    init_mcp_svc();
    
    Tcl_SplitList(interp, 
                  Tcl_GetVar(interp, "argv", 0), 
                  &argc,
                  &argv);

    argv_index = 0;
    new_index = 0;

    while (argv[argv_index] != NULL) {
        if (strcmp (argv[argv_index], "-c") == 0) {
            /* We've got a '-c', we're done */
            command_flag = TRUE;
            argv_index++;  /* Bump past the '-c' */
            /* Copy down the rest */
            for (; argv_index <= argc; argv_index++) {
                argv[new_index] = argv[argv_index];
                new_index++;
            }
            argc--;
            break;
        }
        else if (strcmp (argv[argv_index], "-s") == 0) {
            /* We've got a '-s', set the standalone flag */
            standalone_flag = TRUE;
            argc--;
        }
        else {
            /* Copy down the argument */
            argv[new_index] = argv[argv_index];
            new_index++;
        }

        argv_index++;
    }

    /* Initialize dcecp commands */
    mcp_initInterp(interp);
    
    /* If -s was specified, skip contacting the security server */
    if (!standalone_flag) {
        /* check to see if an initial login context exists */    
        if (check_initial_auth(interp) == TCL_ERROR) {
            printf("Error in getting initial login context.\n");
        }
    }

    /* If -c exists process accordingly if a #! process as a shell 
     * script, otherwise enter the command line interpreter. */
    if (command_flag) {
        check_visible_pw = TRUE;
        /* A command line dcecp command was issued. */
        one_command = Tcl_Concat(argc, argv);
        result = Tcl_Eval(interp, one_command);
        free(one_command);
        
        if (result != TCL_OK) {
            if (result == TCL_ERROR) {
                printf("Error");
            } else {
                printf("Error %d", result);
            }
            if (interp->result != NULL) {
                printf(": %s\n", interp->result);
            } else {
                printf("\n");
            }
            exit(1);
            /* NOTREACHED */
        }
        else if (result == TCL_OK) {
            if (interp->result != NULL) {

                /* 
                 * We are not using printf() here because it has a limit
                 * (at least on OSF/1) of how much it can print at once.
                 * fwrite() and fputs() have the same problem as printf().
                 */
                p = interp->result;
                while(*p != '\0') {
                    putchar(*p);
                    p++;
                }
                printf("\n");
            }
        }
        
        exit(0);
    }

    return TCL_OK;
}


void
init_mcp_svc(void)
{
    error_status_t	        st;
    
    /* Load message table; ignore errors. */
    dce_msg_define_msg_table(mcp_msg_table,
                             sizeof mcp_msg_table / sizeof mcp_msg_table[0],
                             &st);
    if (st != msg_s_ok) {
        (void)fprintf(stderr,
                      "Cannot register dcp msg table, error 0x%lx\n",
                      st);
        exit(1);
        /* NOTREACHED */
    }    
    
    mcp_svc_handle = dce_svc_register(mcp_svc_table, (idl_char *)"dcp", &st);
    if (mcp_svc_handle == NULL) {
        (void)fprintf(stderr, "Cannot register svc table, error 0x%lx\n", st);
        exit(1);
        /* NOTREACHED */
    }
}

