/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1996 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 */
/*
 * HISTORY
 * $Log: rpc.cds.3_defs.h,v $
 * Revision 1.1.98.2  1996/02/18  23:07:44  marty
 * 	Update OSF copyright years
 * 	[1996/02/18  22:29:37  marty]
 *
 * Revision 1.1.98.1  1995/12/11  22:42:46  root
 * 	Submit OSF/DCE 1.2.1
 * 
 * 	HP revision /main/HPDCE02/2  1994/08/09  19:27 UTC  bissen
 * 	merge from HPDCE01
 * 	[1995/12/11  22:19:58  root]
 * 
 * Revision 1.1.96.2  1994/06/10  20:50:03  devsrc
 * 	cr10872 - fixed copyright
 * 	[1994/06/10  17:19:32  devsrc]
 * 
 * Revision 1.1.96.1  1993/12/22  20:51:22  mhickey
 * 	no_changes
 * 	[1993/12/22  20:50:29  mhickey]
 * 
 * 	Added macros to convert authz, auth, and protection level
 * 	numbers to strings, and added the typedef for the data
 * 	structure that identifies a string.
 * 	[1993/12/20  19:52:42  mhickey]
 * 
 * Revision 1.1.8.1  1993/10/20  19:36:52  ohara
 * 	svr4 ref port
 * 	[1993/10/20  19:35:53  ohara]
 * 
 * Revision 1.1.2.3  1993/03/12  18:55:58  mhickey
 * 	Fixing bsubmit mystery meat
 * 	[1993/03/12  18:51:11  mhickey]
 * 
 * Revision 1.1.1.3  1993/01/29  19:21:41  mhickey
 * 	Initial check in for the rpc.cds.3 system test.
 * 
 * Revision 1.1.1.2  1992/12/22  04:47:37  mhickey
 * 	Initial checkin for rpc.cds.3.
 * 
 * $EndLog$
 */

/*---*
 *---* rpc.cds.3_defs.h - values, data structures, etc. for the rpc.cds.3 
 *---*                    system test.
 *---*
 *---* ASSOCIATION
 *---*    This file is part of the rpc.cds.3 DCE System Test
 *---*
 *---*    The rpc.cds.3 system test corresponds to test rpc.cds.3 in the 
 *---*    DCE1.0.2 Core Component System Test plan.  For more information on 
 *---*    the operation and goals of the rpc.cds.3 system test, see the test 
 *---*    plan, or the README file in this directory.
 *---*
 *---* FUNCTION
 *---*    Define values, data structures, and macros for the rpc.cds.3 
 *---*    binaries.  Note that if your platform does not support the 
 *---*    getclock() system call, you will have to change the value of
 *---*    NSECS_PER_SEC to reflect the fact that the granularity of the clock
 *---*    (presumably from gettimeofday()) is in milliseconds.
 *---* 
 *---* CALLED BY
 *---*    rpc.cds.3_runtest.sh - (the driver for running the test program)
 *---* 
 *---* CALLS INTO 
 *---*    Nothing
 *---*
 *---* PREREQUISITES
 *---*    Assumes that the rpc_cds_3.h file has been generated by running
 *---*    the IFL compiler on rpc_cds_3.idl.
 *---*/


/*---* 
 *---* we need the idl generated include file for the calndr_data_t def 
 *---*/
#include <pthread.h>
#include <rpc_cds_3.h>

#include <err_track.h>    /*---* error tracking data structs *---*/
#include <ctime_nonl.h>   /*---* macro for non-newline terminated ctime *---*/
#include <rdconf.h>       /*---* return values from rdconf *---*/

#include <sys/timers.h>

/*---------------------------------------------------------*
 *---------------------------------------------------------*
 *---*            General defines                      *---*
 *---------------------------------------------------------*
 *---------------------------------------------------------*
 *---* 
 *----------------------------------------*
 *---*    Configuration Parameters    *---*
 *----------------------------------------*
 *---* default configuration file name 
 *---*/
#ifdef SNI_SVR4
#define TIMEOFDAY 0
#define getclock(command, address)  gettimeofday(address)
#endif /* SNI_SVR4 */

#ifndef RPCCDS3_CONF_FN
#  define RPCCDS3_CONF_FN "rpc.cds.3.conf"
#endif /*---* ifndef RPCCDS3_CONF_FN *---*/

/*---*
 *---* Macros for accessing the elements of the array returned from rd_conf.
 *---* Note that to use these, the caller code must declare an enum variable 
 *---* named param_i, the elements of which correspond to the values being 
 *---* read from the config file.  For example, if the specifiers for the 
 *---* values being read from the config file are "val1", "val2", "val3",
 *---* the caller code would declare 
 *---*   enum {val1, val2, val3} param_i;
 *---*/
#define PSPEC(parray,index) (parray[(param_i=index)].param_spec)
#define PVAL(parray,ivar,index) (parray[(ivar=index)].param_val)
/*---* 
 *---* macro to convert parameter from a string to a integer and return 
 *---* 0 = success in stat, or print a message and return 1 = failure in stat
 *---*/ 
#define int_from_PVAL(var_p,parray,ivar,index,desc_str,stat) { \
           if (!isdigit(*(PVAL(parray, ivar, index)))) \
           { \
              printf( \
               " Server: non-numeric value (%s) for %s in conf file.\n", \
                                       PVAL(parray, ivar, index), desc_str); \
              stat=1; \
           } \
           else \
	   { \
              sscanf(PVAL(parray, ivar, index), "%d", var_p); \
              stat=0; \
	   } \
	}

/*----------------------------------------*
 *---*     Data Type Management       *---*
 *----------------------------------------*
 *---*
 *---* structures that compose the array of calendars
 *---*/
typedef struct {
   uuid_t cal_uuid;
   calndr_data_p_t cal_data;
} cal_entry_t, *cal_entry_p_t;


/*---* 
 *---* structure that points to a thread and a label 
 *---*/
typedef struct {
   pthread_t *thd_id;
   char      *thd_label;
} thd_tbl_entry_t, thd_tbl_entry_p_t;

/*---*
 *---* USE_PTHREAD(thd_tbl, thd_arry, thd_num) - assign the thread in position
 *---*                                           thd_num in the thd_arry to 
 *---*                                           the pointer part of the struct
 *---*                                           in position thd_num in the
 *---*                                           thd_tbl.
 *---*/
#define USE_PTHREAD(thd_tbl, thd_arry, thd_num) \
	 thd_tbl[thd_num].thd_id = &(thd_arry[thd_num]);

/*----------------------------------------*
 *---*        Timing Package          *---*
 *----------------------------------------*
 *---*
 *---* Macros for operations on timeval structs
 *---*/
/*---* 
 *---* TVAL_SETMIN(min, new) takes two timeval structs as args, and sets the
 *---*                       first to equal the second if the second is less
 *---*                       than the first.
 *---*/
#define  TVAL_SETMIN(min, new) \
  (min) = ((min).tv_sec || (min).tv_nsec)     ? \
          (((min).tv_sec  > (new).tv_sec )? new :  \
           (((min).tv_sec == (new).tv_sec && (min).tv_nsec > (new).tv_nsec)?\
               new : min)) : new

/*---*
 *---* TVAL_SETMAX (max, new) same as above, but sets first arg equal to 
 *---*                        second if second arg is greater than first arg.
 *---*/
#define  TVAL_SETMAX(max, new) \
  (max) = ((max).tv_sec < (new).tv_sec)? new: \
           (((max).tv_sec == (new).tv_sec && (max).tv_nsec < (new).tv_nsec)?\
              new: max)

/*---*
 *---* TVAL_SUB(t1,t2) subtracts timeval struct t2 from timeval struct t1, 
 *---*                 result is in timeval struct t1.
 *---*/
/*---* we define NSEC_PER_SEC  to avoid a call to pow(3m). *---*/
#ifdef SNI_SVR4
/*
 * new value because gettimeofday() really returns micro-seconds, not
 * nano-seconds
 */
#define  NSECS_PER_SEC 0xf4240
#else
#define  NSECS_PER_SEC 0x3b9aca00
#endif /* SNI_SVR4 */

#define  TVAL_SUB(t1, t2) \
    {\
       int ___secadj = 0;\
       (t1).tv_nsec = \
              ((t1).tv_nsec + ((___secadj = ((t1).tv_nsec < (t2).tv_nsec)) ?\
                                    (long)NSECS_PER_SEC: 0)) - (t2).tv_nsec;\
       t1.tv_sec  = \
                ((t1).tv_sec - ___secadj) - (t2).tv_sec;\
    }

/*---* 
 *---* TVAL_ADD(t1, t2) Adds timeval struct t2 to timeval struct t1, result
 *---*                  is returned in timeval struct t1.
 *---*/
#define  TVAL_ADD(t1, t2) \
    {\
       long ___secadj = 0, ___nsum = (t1).tv_nsec + (t2).tv_nsec;\
       (t1).tv_nsec = \
          (___secadj = (___nsum > NSECS_PER_SEC)) ? (___nsum - NSECS_PER_SEC):\
          ___nsum;\
       (t1).tv_sec  =  (t1).tv_sec + (t2).tv_sec + ___secadj;\
    }
  

/*--------------------------------------------*
 *---*    Protection Level Translation    *---*
 *--------------------------------------------*
 *---*
 *---* SET_PROT_LEVEL(prot_str, prot_val, who)
 *---*     
 *---*     Assigns the constant value for the protection level indicated by
 *---*     prot_str to the variable prot_val.  Uses the string who to identify
 *---*     the caller if the prot_str value is not recognized.
 *---*/
#define SET_PROT_LEVEL(prot_str, prot_val, who) \
   if (!strcmp(prot_str, "none")) \
      prot_val = rpc_c_protect_level_none; \
   else if (!strcmp(prot_str, "conn")) \
      prot_val = rpc_c_protect_level_connect; \
   else if (!strcmp(prot_str, "call")) \
      prot_val = rpc_c_protect_level_call; \
   else if (!strcmp(prot_str, "pkt")) \
      prot_val = rpc_c_protect_level_pkt; \
   else if (!strcmp(prot_str, "integ")) \
      prot_val = rpc_c_protect_level_pkt_integ; \
   else if (!strcmp(prot_str, "priv")) \
      prot_val = rpc_c_protect_level_pkt_privacy; \
   else \
   { \
      printf(" %s: protection level %s unknown.\n", who, prot_str); \
      printf(" %s: %s\n", who, usage); \
      exit (1); \
   } 

/*---*
 *---*
 *---* SET_PROT_LEVEL_STR(prot_str, prot_val, who)
 *---*     
 *---*     Assigns the string value for the protection level indicated by
 *---*     prot_val to the variable prot_str.  Uses the string who to identify
 *---*     the caller if the prot_val value is not recognized.
 *---*/
#define SET_PROT_LEVEL_STR(prot_str, prot_val, who) \
   if (prot_val == rpc_c_protect_level_none) \
      prot_str = "none"; \
   else if (prot_val == rpc_c_protect_level_connect) \
      prot_str = "conn"; \
   else if (prot_val == rpc_c_protect_level_call) \
      prot_str = "call"; \
   else if (prot_val == rpc_c_protect_level_pkt) \
      prot_str = "pkt"; \
   else if (prot_val == rpc_c_protect_level_pkt_integ) \
      prot_str = "integ"; \
   else if (prot_val == rpc_c_protect_level_pkt_privacy) \
      prot_str = "priv"; \
   else \
   { \
      printf(" %s: protection level %d unknown.\n", who, prot_val); \
   } 

/*---*
 *---*
 *---* SET_AUTHN_SVC_STR(athn_str, athn_val, who)
 *---*     
 *---*     Assigns the string value for the authentication service indicated by
 *---*     athn_val to the variable athn_str.  Uses the string who to identify
 *---*     the caller if the athn_val value is not recognized.
 *---*/
#define SET_AUTHN_SVC_STR(athn_str, athn_val, who) \
   if (athn_val == rpc_c_authn_none) \
      athn_str = "none"; \
   else    if (athn_val == rpc_c_authn_dce_secret) \
      athn_str = "dce secret"; \
   else    if (athn_val == rpc_c_authn_dce_public) \
      athn_str = "dce public"; \
   else if (athn_val == rpc_c_authn_default) \
      athn_str = "default"; \
   else \
   { \
      printf(" %s: authentication service %d unknown.\n", who, athn_val); \
   } 

/*---*
 *---*
 *---* SET_AUTHZ_SVC_STR(athz_str, athz_val, who)
 *---*     
 *---*     Assigns the string value for the authorization service indicated by
 *---*     athz_val to the variable athz_str.  Uses the string who to identify
 *---*     the caller if the athz_val value is not recognized.
 *---*/
#define SET_AUTHZ_SVC_STR(athz_str, athz_val, who) \
   if (athz_val == rpc_c_authz_none) \
      athz_str = "none"; \
   else    if (athz_val == rpc_c_authz_name) \
      athz_str = "name based"; \
   else    if (athz_val == rpc_c_authz_dce) \
      athz_str = "DCE PAC based"; \
   else \
   { \
      printf(" %s: authorization service %d unknown.\n", who, athz_val); \
   } 

/*---------------------------------------------------------*
 *---------------------------------------------------------*
 *---*            Client Specific Defines              *---*
 *---------------------------------------------------------*
 *---------------------------------------------------------*/
/*---*
 *---* Operation type defs
 *---*/
#define rpccds3_op_is_nop 0
#define rpccds3_op_is_send_cal 1

/*---------------------------------------------------------*
 *---------------------------------------------------------*
 *---*             Server Specific Defines             *---*
 *---------------------------------------------------------*
 *---------------------------------------------------------*/
/*---------------------------------------------------------*
 *---* Server Return value defines
 *---------------------------------------------------------*/
/*---*
 *---* Definitions for return values from rpccds3_nop()
 *---*/
#define rpccds3_nop_ok 0              /*---* no errors        *---*/
#define rpccds3_nop_err_odd 1         /*---* odd arg passed   *---*/
#define rpccds3_nop_err_oth 2         /*---* some other error *---*/


/*---*
 *---* Definitions for return values from authorization validation routine
 *---*/
#define rpccds3_srv_auth_accept          7  /*---* successful a13n *---*/
#define rpccds3_srv_auth_bad_srv         8  /*---* bad server principle *--*/
#define rpccds3_srv_auth_unsup_authz     9  /*---* unsupp. authzn srvice *-*/
#define rpccds3_srv_auth_unsup_authn    10  /*---* unsupp. authnn srvice *-*/
#define rpccds3_srv_auth_bad_cli        11  /*---* bad client principal  *-*/
#define rpccds3_srv_auth_unsup_lvl      12  /*---* unsupp protectn level *-*/
#define rpccds3_srv_auth_cant_get_info  13  /*---* can't get auth info *---*/


/*---*
 *---* Definitions for return values from rpccds3_parse_cal_spec() 
 *---*/
#define rpccds3_parse_cal_spec_ok        0 /*---* no problem         *---*/
#define rpccds3_parse_cal_spec_no_spec   1 /*---* no cal spec passed *---*/
#define rpccds3_parse_cal_spec_no_space  2 /*---* no space for ????  *---*/
#define rpccds3_parse_cal_spec_bad_file  3 /*---* problem reading file *---*/
#define rpccds3_parse_cal_spec_bad_data  4 /*---* file okay, data bad *---*/
#define rpccds3_parse_cal_spec_other     5 /*---* unknown error *---*/

/*---*
 *---* defines for return statuses from rpccds3_set_cal_uuid()
 *---*/
#define rpccds3_set_cal_uuid_ok          0 /*---* all is well *---*/
#define rpccds3_set_cal_uuid_bad_name    1 /*---* bad calendar name  *---*/
#define rpccds3_set_cal_uuid_create      2 /*---* couldn't create uuid *---*/
#define rpccds3_set_cal_uuid_ns_err      3 /*---* err looking for uuid *---*/
#define rpccds3_set_cal_uuid_no_spc      4 /*---* no space for uuid_vec *--*/
#define rpccds3_set_cal_uuid_other       5 /*---* unknown error *---*/

/*---*
 *---* defines for values returned in the uuid_from arg to
 *---*  rpccds3_set_cal_uuid
 *---*/
#define uuid_from_both               0 /*---* cds & cal uuids match *--*/
#define uuid_from_cds                1 /*---* from the cds entry  *---*/
#define uuid_from_cal                2 /*---* newly created       *---*/
#define uuid_from_uuidgen            3 /*---* from calendar entry *---*/

/*---*
 *---* defines for values returned from rpccds3_send_cal()
 *---*/
#define rpccds3_send_cal_ok          0 /*---* found calendar for uuid *---*/
#define rpccds3_send_cal_bad_h       1 /*---* bad handle passed       *---*/
#define rpccds3_send_cal_no_uuid     2 /*---* no uuid in handle       *---*/
#define rpccds3_send_cal_unknown     3 /*---* unspecified error       *---*/
#define rpccds3_send_cal_bad_uuid    4 /*---* bad uuid in handle      *---*/
#define rpccds3_send_cal_no_cal      5 /*---* couldn't match passed uuid *-*/

