#
# @OSF_COPYRIGHT@
# COPYRIGHT NOTICE
# Copyright (c) 1990, 1991, 1992, 1993, 1994, 1996 Open Software Foundation, Inc.
# ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
# the full copyright text.
# 
# 
# HISTORY
# $Log: cellalias.dcp,v $
# Revision 1.1.8.3  1996/03/09  23:06:30  marty
# 	Update OSF copyright year
# 	[1996/03/09  22:25:21  marty]
#
# Revision 1.1.8.2  1995/12/08  21:23:55  root
# 	Submit OSF/DCE 1.2.1
# 
# 	HP revision /main/HPDCE02/14  1995/10/17  14:52 UTC  kevins
# 	Merge chfts15887 into HPDCE02
# 
# 	HP revision /main/HPDCE02/kevins_chfts15887/1  1995/10/17  14:41 UTC  kevins
# 	Need to modify the method for setting script debuging variable.
# 
# 	HP revision /main/HPDCE02/13  1995/07/27  19:36 UTC  truitt
# 	Merge changes.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts44/1  1995/07/27  19:34 UTC  truitt
# 	CHFts14292: Fix loser coding errors.
# 
# 	HP revision /main/HPDCE02/12  1995/07/26  19:09 UTC  truitt
# 	Merge script changes.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts43/1  1995/07/26  19:07 UTC  truitt
# 	CHFts15849: Catch errors from the attrlist command during create.
# 
# 	HP revision /main/HPDCE02/11  1995/06/27  15:57 UTC  truitt
# 	Merge disable of cdsalias set command.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts36/1  1995/06/27  15:56 UTC  truitt
# 	CHFts15407: Disable cellalias set for now.
# 
# 	HP revision /main/HPDCE02/10  1995/05/30  15:42 UTC  truitt
# 	Merge cellalias enhancements.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts32/1  1995/05/30  15:41 UTC  truitt
# 	Further enhancements.
# 
# 	HP revision /main/HPDCE02/9  1995/05/23  18:58 UTC  truitt
# 	Merge.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts30/1  1995/05/23  18:57 UTC  truitt
# 	CHFts15239: More cellalias work.
# 
# 	HP revision /main/HPDCE02/8  1995/05/15  17:52 UTC  truitt
# 	Merge cellalias work.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts29/1  1995/05/15  17:51 UTC  truitt
# 	CHFts15239: An incorrect replica name is sometimes being
# 	used when an alias is created.
# 
# 	HP revision /main/HPDCE02/7  1995/05/01  18:40 UTC  truitt
# 	Merge pe_site file changes.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts26/2  1995/05/01  18:39 UTC  truitt
# 	CHFts15153: Set up the alias bindings in pe_site correctly
# 	this time.
# 
# 	HP revision /main/HPDCE02/6  1995/04/19  23:13 UTC  truitt
# 	Merge pe_site work.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts26/1  1995/04/19  23:13 UTC  truitt
# 	CHFts15086: Make sure the pe_site file is created correctly.
# 
# 	HP revision /main/HPDCE02/5  1995/03/31  18:53 UTC  truitt
# 	Merge message work.
# 
# 	HP revision /main/HPDCE02/truitt_mothra_chfts24/1  1995/03/31  18:51 UTC  truitt
# 	CHFts14890: Change the operations message.
# 
# 	HP revision /main/HPDCE02/4  1995/02/15  20:39 UTC  dnguyen
# 	Merge cellalias error handling fix
# 
# 	HP revision /main/HPDCE02/dnguyen_mothra/2  1995/02/14  18:51 UTC  dnguyen
# 	Synchronize /.: after undo cdsalias operation
# 
# 	HP revision /main/HPDCE02/dnguyen_mothra/1  1995/02/13  18:11 UTC  dnguyen
# 	Making script more robust in case of failure.
# 
# 	HP revision /main/HPDCE02/3  1995/02/01  15:14 UTC  rps
# 	fix early return out of loops
# 	fix "set" to *swap* the names, not tromp on them
# 
# 	HP revision /main/HPDCE02/rps_hc/1  1995/01/31  01:09 UTC  rps
# 	fix early return out of loops
# 	fix "set" to *swap* the names, not tromp on them
# 
# 	HP revision /main/HPDCE02/2  1994/11/18  15:18 UTC  truitt
# 	Merge unintegrated
# 	[1995/12/08  17:57:41  root]
# 
# Revision 1.1.4.2  1994/10/19  17:55:53  kevins
# 	OT 12660 Modified the way 'set' manipulates the dce_cf.db file.
# 	[1994/10/19  17:55:36  kevins]
# 
# Revision 1.1.4.1  1994/10/13  17:15:54  kevins
# 	OT 12585 modified error trapping in create command
# 	[1994/10/13  17:13:50  kevins]
# 
# 	HP revision /main/HPDCE02/1  1994/11/15  20:11 UTC  truitt
# 	Initial HPDCE02 branch.
# 
# 	HP revision /main/truitt_dcecp_01/1  1994/11/15  20:09 UTC  truitt
# 	Fix help and error messages.
# 
# Revision 1.1.2.3  1994/09/29  17:44:46  melman
# 	uncommented debugging code
# 	[1994/09/29  17:42:37  melman]
# 
# Revision 1.1.2.2  1994/09/23  21:50:28  melman
# 	finished implementation.
# 	[1994/09/23  21:50:10  melman]
# 
# Revision 1.1.2.1  1994/09/02  19:37:57  melman
# 	implement cellalias
# 	[1994/09/02  19:35:56  melman]
# 
# $EndLog$
#
# cellalias: Used to create new alias names and set a primary name.
#

if { [ info globals CELLALIAS_DEBUG ] == "" } {
    set CELLALIAS_DEBUG 0
}

proc cellalias { args } {
    set arg_table {
        {catalog command function_call _dcp_catalog_cellalias
            "Returns the cell alias names currently in use."}
        {create command function_call _dcp_create_cellalias
            "Creates a new alias name for the local cell."}
        {help help help_list
            "Prints a summary of command-line options."}
        {operations operations operation_list
            "Returns a list of the valid operations for this command."}
    }

    set local_args $args

    set verbose_prose \
"This object is used to create new alias names within a local cell.
It is also used to get a summary of the alias names currently in
use.  The argument is the alias name to use.  If no argument is
provided, an error message is generated.  The user must be valid
and authorized to perform these operations."

    parseargs $arg_table local_args -found_one

    if {[info local help_prose] > 0} {
        return $help_prose
    }

    if {[info local function_call] > 0} {
        return [$function_call local_args]
    } else {
        error "\"cellalias\" object requires a verb to form a command."
    }
}

proc _dcp_catalog_cellalias {local_args} {
    set result {}
    upvar 1 local_args cargs 
    set local_args $cargs

    parseargs "" local_args -no_leftovers

    if {[info local help_prose] > 0} {
        return
    }

    if {[llength $local_args] > 1} {
        error "Unrecognized argument [lindex $local_args 0]."  
    } elseif {[llength $local_args] == 0} {
        set hname [exec hostname]
    } else {
        set hname $local_args
    }

    set hosts_prefix [string range $hname 0 4]
    if {"$hosts_prefix" == "hosts"} {
        set hd /.:/$hname/config/hostdata
    } else {
        set hd /.:/hosts/$hname/config/hostdata
    }

    _dcp_cellalias_debug "Call the hostdata show command to get the current cell name."
    if {[catch {set hd_sh_cn [hostdata show $hd/cell_name]} msg] != 0} {
        if {$msg == "Bad or invalid dce attr schema object name(s)"} {
            error "Unable to access the $hd/cell_name dced object"
        } else {
            error $msg
        }
    }

    _dcp_cellalias_debug "Call the hostdata show command to get the alias list."
    if {[catch {set hd_sh_al [hostdata show $hd/cell_aliases]} msg] != 0} {
        if {$msg == "Bad or invalid dce attr schema object name(s)"} {
            error "Unable to access the $hd/cell_aliases dced object"
        } else {
            error $msg
        }
    }

    set val1 [attrlist getvalues $hd_sh_cn -type hostdata/data]
    set val2 [attrlist getvalues $hd_sh_al -type hostdata/data]
    if {[string length $val1] != 0} {
        puts $val1
    }
    foreach v $val2 {
        if {[string length $v] != 0} {
            puts $v
        }
    }

    return $result
}

proc _dcp_create_cellalias {local_args} {
    set result {}
    upvar 1 local_args cargs 
    set local_args $cargs
    set force_flag 0

    set arg_table {
        {-force boolean force_flag
            "Ignore errors where appropriate and complete the command."}
    }

    parseargs $arg_table local_args -no_leftovers

    if {[info local help_prose] > 0} {
        return
    }

    if {[llength $local_args] > 1} {
        error "Unrecognized argument [lindex $local_args 1]."  
    } elseif {[llength $local_args] == 0} {
        error "Must enter a cell alias name as an argument."
    } else {
        set alias $local_args
    }

    #
    # Check that the cell alias name is in the correct format.
    #
    set alias_prefix [string range $alias 0 4]
    if {"$alias_prefix" != "/.../"} {
        error "The alias name $alias does not have the correct '/.../' prefix."
    }

    #
    # 1st tell secd
    #
    _dcp_cellalias_debug "Tell secd about cell alias by creating a new principal for"
    _dcp_cellalias_debug "the given alias.  Use the same uid as the cell principal."
    set tmp [principal show krbtgt/[string range [name expand /.:] 5 end]]
    set uid_val [attrlist getval $tmp -type uid]
    set alias_short [string range $alias 5 end]
    if {[catch {principal create krbtgt/$alias_short -alias yes -uid $uid_val} msg] != 0} {
        #
        # The principal create command failed, report an
        # error if the force flag has not been set.
        #
        if {!$force_flag} {
            error $msg
        }
    }

    #
    # Add a check to make sure that the new principal exists.  If not,
    # regardless of the force flag setting, don't do anything else.
    #
    if {[catch {principal show krbtgt/$alias_short} msg2] != 0} {
        #
        # The principal does not exist.  Do not continue.
        #
        if {$msg2 == "Registry object not found"} {
            error "Unable to create principal 'krbtgt/$alias_short' due to '$msg'"
        }
    }
    registry verify

    #
    # 2nd tell cdsd
    #
    _dcp_cellalias_debug "Tell cds about cell alias by using the cdsalias create"
    _dcp_cellalias_debug "command, passing in the new alias name as the argument."
    if {[catch {cdsalias create $alias} msg] != 0} {
        #
        # The cdsalias create command failed, back out principal
        # if the force flag has not been set.
        #
        if {!$force_flag} {
            _dcp_cellalias_debug "Failed creating cdsalias: $msg"
            _dcp_cellalias_debug "Remove the principal name that was just created."
            catch {principal delete krbtgt/$alias_short}
            error $msg
        }
    }
    if {!$force_flag} {
        directory synchronize /.:
    } else {
        catch {directory synchronize /.:}
    }

    #
    # 3rd tell all the clients: dce_cf.db and pe_site
    #
    _dcp_cellalias_debug "Tell all the clients about cell alias."
    set error_found 0
    foreach h [directory list /.:/hosts -directories] {
        lappend h_done $h
        set hd $h/config/hostdata

        #
        # Update the dce_cf.db file
        #
        _dcp_cellalias_debug "Update the dce_cf.db file on host '$h' by"
        _dcp_cellalias_debug "changing the data part of the cell_aliases dced object."
        set hd_sh_al ""
        if {[catch {set hd_sh_al [hostdata show $hd/cell_aliases]} msg] != 0} {
            #
            # We are unable to use the hostdata command to show information
            # about cell aliases.  If the hostdata error is consistent with
            # that found when no dced support is available on a host, just
            # skip this host and go on to the next one.
            #
            if {$force_flag || $msg == "Bad or invalid dce attr schema object name(s)"} {
                continue
            } else {
                set error_found 1
                break
            }
        }
        if {[catch {set val [attrlist getvalues $hd_sh_al -type hostdata/data]} msg] != 0} {
            if {$force_flag} {
                set val ""
            } else {
                set error_found 1
                break
            }
        }

        #
        # See if the alias being created is already the primary.  If
        # so, and the force flag is set, skip to the next host.  If
        # not, report an error.
        #
        set hd_sh_cn ""
        if {[catch {set hd_sh_cn [hostdata show $hd/cell_name]} msg] != 0} {
            #
            # We hit an error reading the cell_name object.  If the force
            # flag is not set, report an error.  Otherwise, carry on.
            #
            if {!$force_flag} {
                set error_found 1
                break
            }
        }
        if {[catch {set cn_val [attrlist getvalues $hd_sh_cn -type hostdata/data]} msg] != 0} {
            if {$force_flag} {
                set cn_val ""
            } else {
                set error_found 1
                break
            }
        }
        if {"$cn_val" == "$alias"} {
            #
            # The alias name being entered is already the same as
            # the primary name.  If the force flag is set, continue.
            #
            if {$force_flag} {
                continue
            } else {
                set error_found 1
                break;
            }
        }

        #
        # If the alias we are trying to create already exists in the
        # hostdata object, flag an error if the force flag has not
        # been set, quietly skip the modify otherwise.
        #
        set match_found 0
        foreach v $val {
            if {"$v" == "$alias"} {
                _dcp_cellalias_debug "Found a matching alias in the cell_aliases object."
                set match_found 1
                if {!$force_flag} {
                    set msg "Alias already exists in cell_aliases object."
                    set error_found 1
                }
                break;
            }
        }
        if {$error_found} {
            break;
        }

        if {!$match_found} {
            lappend val $alias
            if {[catch {hostdata modify $hd/cell_aliases -data $val} msg] != 0} {
                #
                # The hostdata modify command failed.  If the force flag
                # has not been set, report an error.
                #
                if {!$force_flag} {
                    set error_found 1
                    break
                }
            }
        }

        #
        # Update the pe_site file
        #
        _dcp_cellalias_debug "Update the pe_site file on host '$h' by"
        _dcp_cellalias_debug "changing the data part of the pe_site dced object."
        set hd_sh_pe ""
        if {[catch {set hd_sh_pe [hostdata show $hd/pe_site]} msg] != 0} {
            #
            # The hostdata show command failed.  If the force flag
            # has not been set, report an error.  We do not have to
            # check again here for no dced support.
            #
            if {!$force_flag} {
                set error_found 1
                break
            }
        }
        if {[catch {set val [attrlist getvalues $hd_sh_pe -type hostdata/data]} msg] != 0} {
            if {$force_flag} {
                set val ""
            } else {
                set error_found 1
                break
            }
        }

        #
        # If the alias we are trying to create already exists in the
        # hostdata object, flag an error if the force flag has not
        # been set, quietly skip the modify otherwise.
        #
        set match_found 0
        foreach v $val {
            set v2 [lindex $v 0]
            if {"$v2" == "$alias"} {
                _dcp_cellalias_debug "Found a matching alias in the pe_site object."
                set match_found 1
                if {!$force_flag} {
                    set msg "Alias already exists in pe_site object."
                    set error_found 1
                }
                break;
            }
        }
        if {$error_found} {
            break;
        }

        if {!$match_found} {
            set newval $val
            set cellname [name expand /.:]
            foreach v $val {
                set cname [lindex $v 0]
                if {$cname == $cellname} {
                    set binding [lindex $v 1]
                    set secrep [lindex $v 2]
                    lappend newval [concat $alias " " $binding " " $secrep]
                }
            }
            if {[catch {hostdata modify $hd/pe_site -data $newval} msg] != 0} {
                #
                # The hostdata modify command failed.  If the force flag
                # has not been set, report an error.
                #
                if {!$force_flag} {
                    set error_found 1
                    break
                }
            }
        }
    }

    #
    # We've looped through each of the clients.  If an error was found
    # and the force flag is not set, then the error message is stored
    # in the variable "msg".  Back out any changes made and return
    # the original error message.
    #
    if {$error_found} {
        _dcp_cellalias_debug "Failed telling client '$h': $msg"
        _dcp_cellalias_debug "Back out all the changes already made."
        catch {principal delete krbtgt/$alias_short}
        catch {cdsalias delete $alias}
        catch {directory synchronize /.:}
        catch {
            foreach h $h_done {
                set hd $h/config/hostdata

                #
                # Reset the dce_cf.db file
                #
                set hd_sh_al [hostdata show $hd/cell_aliases]
                set val [attrlist getvalues $hd_sh_al -type hostdata/data]
                set idx [lsearch -exact $val $alias]
                set nval [lreplace $val $idx $idx]
                hostdata modify $hd/cell_aliases -data $nval

                #
                # If nval is empty, we need to also do the following
                # to remove the alias from the file.  Just the above
                # hostdata modify won't do it.
                #
                if {[llength $nval] == 0} {
                    set hd_sh_cf [hostdata show $hd/dce_cf.db]
                    set val [attrlist getvalues $hd_sh_cf -type hostdata/data]
                    set idx [lsearch -regexp $val cellaliases.*$alias]
                    if {$idx != -1} {
                        set val [lreplace $val $idx $idx]
                        hostdata modify $hd/dce_cf.db -data $val
                    }
                }

                #
                # Reset the pe_site file
                #
                set hd_sh_pe [hostdata show $hd/pe_site]
                set val [attrlist getvalues $hd_sh_pe -type hostdata/data]
                set nval {}
                foreach V $val {
                    if {[string first $alias $V] == -1} {
                        lappend nval $V
                    }
                }
                hostdata modify $hd/pe_site -data $nval
            }
        }
        error $msg
    }
    return $result
}

proc _dcp_set_cellalias {local_args} {
    set result {}
    upvar 1 local_args cargs 
    set local_args $cargs
    set force_flag 0

    set arg_table {
        {-force boolean force_flag
            "Ignore errors where appropriate and complete the command."}
    }

    parseargs $arg_table local_args -no_leftovers

    if {[info local help_prose] > 0} {
        return
    }

    if {[llength $local_args] > 1} {
        error "Unrecognized argument [lindex $local_args 1]."  
    } elseif {[llength $local_args] == 0} {
        error "Must enter a cell alias name as an argument."
    } else {
        set alias $local_args
    }

    #
    # Check that the cell alias name is in the correct format.
    #
    _dcp_cellalias_debug "Check the format of the alias name."
    set alias_prefix [string range $alias 0 4]
    if {"$alias_prefix" != "/.../"} {
        error "The alias name $alias does not have the correct '/.../' prefix."
    }

    #
    # If the force option is not set, take a quick peek at the principal
    # information of the new alias name.  If security thinks it is already
    # the primary name, then report an error without having to go each host.
    #
    if {!$force_flag} {
        _dcp_cellalias_debug "Check if the new alias is already the primary."
        set alias_short [string range $alias 5 end]
        if {[catch {set pr_show [principal show krbtgt/$alias_short]} msg] == 0} {
            set al_value [attrlist getvalues $pr_show -type alias]
            if {$al_value == "no"} {
                error "The alias name $alias is already the primary cell name."
            }
        }
    }

    #
    # 1st tell secd
    #
    _dcp_cellalias_debug "Tell secd about the new cell name by modifying the principal"
    _dcp_cellalias_debug "of the given alias to show it is now the primary name."
    set alias_short [string range $alias 5 end]
    if {[catch {principal modify krbtgt/$alias_short -alias no} msg] != 0} {
        #
        # The principal modify command failed, report an
        # error if the force flag has not been set.
        #
        if {$msg == "Registry object not found"} {
            #
            # Since the new cellname the user is trying to set does
            # not exist in security, there is no point in continuing,
            # even if the force flag is set.  Forcing from here on
            # will do nothing but cause problems.
            #
            _dcp_cellalias_debug "The principal for the new cell name does not exist."
            _dcp_cellalias_debug "Don't even bother to try and continue."
            error $msg
        }
        #
        # Some other error came up (meaning the principal at least
        # exists).  Go ahead and continue if the force flag has been set.
        #
        if {!$force_flag} {
            error $msg
        }
    }
    registry verify

    #
    # 2nd tell cdsd
    #
    _dcp_cellalias_debug "Tell cds about the new alias by using the cdsalias set"
    _dcp_cellalias_debug "command, passing in the new alias name as the argument."
    if {[catch {cdsalias set $alias} msg] != 0} {
        #
        # The cdsalias set command failed, back out principal
        # modify if the force flag has not been set.
        #
        if {!$force_flag} {
            _dcp_cellalias_debug "Failed setting cdsalias: $msg"
            _dcp_cellalias_debug "Change the original principal name back to primary."
            catch {principal modify krbtgt/[string range [name expand /.:] 5 end] -alias no}
            error $msg
        }
    }
    if {!$force_flag} {
        directory synchronize /.:
    } else {
        catch {directory synchronize /.:}
    }

    #
    # 3rd tell all the clients: dce_cf.db
    #
    _dcp_cellalias_debug "Tell all the clients about the new primary."
    set error_found 0
    foreach h [directory list /.:/hosts -directories] {
        lappend h_done $h
        set hd $h/config/hostdata

        #
        # Need to ensure the old value will still be an alias.
        #
        _dcp_cellalias_debug "Update the dce_cf.db file on host '$h' by changing"
        _dcp_cellalias_debug "the data part of the cell_name and cell_aliases dced objects."
        set hd_sh_cn ""
        if {[catch {set hd_sh_cn [hostdata show $hd/cell_name]} msg] != 0} {
            #
            # We are unable to use the hostdata command to show information
            # about cell aliases.  In this case, regardless of the reason why,
            # report an error and back out any changes made up to this point.
            #
            if {!$force_flag} {
                set error_found 1
                break
            }
        }
        if {[catch {set val [attrlist getvalues $hd_sh_cn -type hostdata/data]} msg] != 0} {
            if {$force_flag} {
                set val ""
            } else {
                set error_found 1
                break
            }
        }

        #
        # Check that the user is not trying to enter the current
        # primary name as the new primary name.  If so, this is an error. 
        #
        _dcp_cellalias_debug "Make sure the new primary name on host '$h'"
        _dcp_cellalias_debug "is not the same as the old primary name."
        if {"$val" == "$alias"} {
            #
            # The user entered the cell primary name as the new alias.
            # If the force flag is not set, report an error.  If the
            # force flag is set, skip to the next host.
            #
            if {!$force_flag} {
                set msg "The alias name $alias on host $h is already the primary cell name."
                set error_found 1
                break
            } else {
                continue
            }
        }

        set hd_sh_al ""
        if {[catch {set hd_sh_al [hostdata show $hd/cell_aliases]} msg] != 0} {
            #
            # The hostdata show command failed.  If the force flag
            # has not been set, report an error.
            #
            if {!$force_flag} {
                set error_found 1
                break
            }
        }
        if {[catch {set aliases [attrlist getvalues $hd_sh_al -type hostdata/data]} msg] != 0} {
            if {$force_flag} {
                set aliases ""
            } else {
                set error_found 1
                break
            }
        }
        set aliasidx [lsearch $aliases $alias]

        if {$aliasidx == -1} {
            #
            # Add the old primary.
            #
            lappend aliases $val
        } else {
            #
            # Swap old alias with new primary.
            #
            set aliases [lreplace $aliases $aliasidx $aliasidx $val]
        }

        #
        # Set new list of cell aliases in the cell_aliases object
        #
        if {[catch {hostdata modify $hd/cell_aliases -data $aliases} msg] != 0} {
            #
            # The hostdata modify command failed.  If the force flag
            # has not been set, report an error.
            #
            if {!$force_flag} {
                set error_found 1
                break
            }
        }

        #
        # Set new primary name in the cell_name object
        #
        if {[catch {hostdata modify $hd/cell_name -data $alias} msg] != 0} {
            #
            # The hostdata modify command failed.  If the force flag
            # has not been set, report an error.
            #
            if {!$force_flag} {
                set error_found 1
                break
            }
        }
    }

    #
    # We've looped through each of the clients.  If an error was found
    # and the force flag is not set, then the error message is stored
    # in the variable "msg".  Back out any changes made and return
    # the original error message.
    #
    if {$error_found} {
        _dcp_cellalias_debug "Failed setting alias on client '$h': $msg"
        _dcp_cellalias_debug "Back out all the changes already made."
        set badhost $h
        catch {principal modify krbtgt/[string range [name expand /.:] 5 end] -alias no}
        catch {cdsalias set [name expand /.:]}
        catch {directory synchronize /.:}
        catch {
            foreach h $h_done {
                set hd $h/config/hostdata

                set hd_show_ca [hostdata show $hd/cell_aliases]
                set aliases [attrlist getvalues $hd_show_ca -type hostdata/data]
                set oldvalidx [lsearch $aliases [name expand /.:]]
                if {$aliasidx == -1} {
                    #
                    # Remove old value from aliases.
                    #
                    set aliases [lreplace $aliases $oldvalidx $oldvalidx]
                } else {
                    #
                    # Swap old value with alias.
                    #
                    set aliases [lreplace $aliases $oldvalidx $oldvalidx $alias]
                }
                hostdata modify $hd/cell_aliases -data $aliases

                #
                # If aliases is empty, need to do the following to remove the
                # alias from dce_cf.db.  Just the above hostdata modify won't do.
                #
                if {[llength $aliases] == 0} {
                    set hd_show_db [hostdata show $hd/dce_cf.db]
                    set val [attrlist getvalues $hd_show_db -type hostdata/data
                    set idx [lsearch -regexp $val cellaliases.*[name expand /.:]]
                    if {$idx != -1} {
                        set val [lreplace $val $idx $idx]
                        hostdata modify $hd/dce_cf.db -data $val
                    }
                }

                #
                # Reset old value as primary name
                #
                hostdata modify $hd/cell_name -data [name expand /.:]
            }
        }
        if {$msg == "Bad or invalid dce attr schema object name(s)"} {
            error "Older client '$badhost' exists and would be unable to use new cellname."
        } else {
            error $msg
        }
    }
    return $result
}

proc _dcp_cellalias_debug {args} {
    global CELLALIAS_DEBUG

    if {$CELLALIAS_DEBUG != 0} {
        puts stderr "DEBUG: [lindex [info level [expr [info level] - 1]] 0]:\
                            [string range $args 1 \
                            [expr [string length $args] - 2]]"
    }
}
