# @OSF_COPYRIGHT@
# COPYRIGHT NOTICE
# Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
# ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
# the full copyright text.
# 
# HISTORY
# $Log: README,v $
# Revision 1.1.82.1  1996/10/02  17:26:28  damon
# 	Newest DFS from Transarc
# 	[1996/10/01  18:33:20  damon]
#
# $EndLog$
# README -- overview of rcx directory.
# $Header: /u0/rcs_trees/dce/rcs/file/episode/rcx/README,v 1.1.82.1 1996/10/02 17:26:28 damon Exp $
# Copyright (C) 1993, 1990 Transarc Corporation - All rights reserved

The scripts in this directory exist for the purpose of doing recovery
testing (RCX means ReCovery eXcerciser). All of these scripts are perl
scripts. You will need perl 4.0 or later, available by anonymous ftp
from, for example, ftp.uunet.com. Perl is part of the GNU software
distribution.

This directory contains three scripts: all_tests, runrcx, and rcx.
all_tests is a wrapper for runrcx which invokes the latter with a
series of different tests. Runrcx, in turn, is a wrapper for the basic
recovery excerciser script, rcx.

NOTE: This program has never been run on any other than an AIX 3.1 or
3.2 platform. There is at least one dependency on AIX: the runrcx
script tries to unmount any filesets that have been left mounted by
previous incarnations of the script that may have broken. This uses
the platform-dependent output from /bin/df to determine which filesets
are mounted.

To run either all_tests or runrcx, you will need:

1. Build this directory (episode/rcx)

2. Change dir to the object dir for episode/rcx

3. Need to change the first line in scripts runrcx, rcx, all_tests,
   stress_tests, all_simple_tests to point to where perl is installed
   in your environment.

4. An Episode kernel. On an AIX system this generally means having
   a kernel extension that supports Episode. This must be loaded
   before running these tests.

5. A set of Episode utilities, which should include:

	sautils/efts		standalone episode utility command suite
	anode/newaggr		create a new aggregate
	utils/epimount		mount a fileset
	util/epiunmount	unmount a fileset
	salvage/salvage		salvage an aggregate
	anode/findlog		find the log in an aggregate
	sautils/asdb		async debug tool, for freezing an aggregate.
	anode/calcLogSize	calculates log size for an aggregate
    rcx/copyaggr    	freeze aggregate, copy aggregate, unfreeze aggreate.

   These utilties should either be available on your execution path
   (i.e. on $PATH), or you can set the environment variable RCX_EPIBIN,
   as described below.

   Also you need the "chftids" perl program that is based on the scavenger
   tool. This can be built from the src/file/episode/scavenge dir. Chtfids
   relies on efs, efs_query and util perl scripts built from the same dir. The
   environment variable RCX_PERLINC should specify the path to these perl
   scripts.
   
   To debug problems, you will also be likely to need the readlog program.

6. Three device partitions or logical volumes of SAME SIZE. 

   For HP/UX, on which there is only one partition per disk, we have
   specially tweaked RCX to allow partitions of different sizes.  The
   smallest one must be the first one listed below (RCX_DEV1).  Also see
   item 9 below.

   By default, these are assumed to be called /dev/epircxa,
   /dev/epircxb, and /dev/epircxc. Any of these may be overridden,
   however, by defining the environment variables RCX_DEV1, RCX_DEV2,
   and RCX_DEV3, respectively. The env variables should not be set to
   "/dev/hd1" but just "hd1". On SunOS5 and HP-UX, they should not be
   set to "/dev/dsk/c0t1d0s4" but just "c0t1d0s4". Each partition
   should be a minimum of four megabytes in size for the correct
   functioning of the all_tests program. THESE PARTITIONS WILL BE
   OVERWRITTEN BY THESE TESTS.

7. A log directory, NOT IN EPISODE, which will be created as a subset of
   the current directory and called "runlog", unless the environment
   variable RCX_LOGDIR is defined.  That should name the directory
   relative to the current directory or as an absolute pathname.  You
   will need a fairly large amount of space in this directory, to
   contain all the log files generated by runrcx, and to contain
   compressed copies of aggregates in the event that recovery fails.
   For very long runs a large size is good; try 100MB.

8. To be root, since the runrcx program creates, mounts, and unmounts
   aggregates.

9. The following additional tweaks FOR HP/UX ONLY:

   If your three partitions are not exactly the same size, do the
   following:

    - To disable checksumming, which reads all the bits on the whole
      partition, define environment variable COPYAGGR_NOCHECKSUM to 1,
   
	- To cause aggregate comparison to examine only as many bytes as
      there are in the whole aggregate, rather than in the whole
      partition, define environment variable RCX_ONE_PARTITION_PER_DISK
	  to 1.

10. perl must be in your PATH as it will be invoked explicitly.

11. To track suspected anode layer aggregate reference counts problems, you
    can use the traverseAggrs program that will retrieve the necessary
    information from the kernel and print it out. The traverseAggrs.c
    program is located in src/file/episode/anode/traverseAggrs.c. 
    To use this, first build the program using standard ODE mechanisms
    and then set the environment variable RCX_AGGR_REFS_PROG to point
    to the binary before running the RCX tests.

    CAUTION: The traverseAggrs program has only been tested to work on
    Solaris. It may need minor work on other systems.

To run all_tests, simply type:

	all_tests

in the current directory.  To use runrcx on a single test, type:

	runrcx testname

where testname is the name of a test file, minus the .rs extension. More
details on runrcx are provided below.

INTERPRETING OUTPUT

The output from all_tests/runrcx consists of a simple indication of
which test is currently running, and whether it fails or succeeds.
More detail is provided in the appropriate log file in the runlog
directory. Logfiles are assigned numbers stamped with the current date
(month and day), a run number, and a cycle number.  The run number is
the runrcx run number, so multiple calls to runrcx by all_tests will
generate multiple run numbers. The cycle number is the internal
runrcx test cycle number.

There will be an error summary at the end of the log file. Types of errors
include failures of any program to run, failure of an aggregate to
verify after recovery, failure of the salvager, failure of rcx -r to find
that a particular fileset is in a state consistent with the states allowable
for a given test.

You may also want to check for other indicators of good health in the
system.  For example, you may wish to check that the salvager finds
errors in the aggregates in at least some cases before recovery, and
also that recovery affects the numbers of files or directories found
on the aggregate. You may wish to check the recovery statistics provided
on recovery--how many log blocks tend to be read? Is a reasonable
proportion of the log, on average, being used?
------------------------------------------------------------------------------
The other programs provided in this directory are described below.
You should not have to read further in order to successfully run
these tests.
------------------------------------------------------------------------------
Rcx is a script which allows you to create simple test scripts that
modify file system meta data (such as mkdir, create file, rename,
etc.), and then to check a directory that rcx was previously run in to
determine if it and its subdirectories are in a state that can
normally be entered by the associated script. This is used to
determine if file system recovery has worked correctly. It doesn't
detect all failure modes, and should be used in conjunction with the
episode salvager in verify mode.

Rcx is invoked as follows:

    rcx [-x] [-c|-r] script directory
	 -r Check recovery based on hash-coded script (use script.rech)
 	 -c Compile script.rs to script.rc and script.rh
	 -x Echo lines as executed.

An rcx script (which should have the name script.rs) and a directory
to work in must always be specified. If the -c option is specified,
the script is "compiled" into two additional files, script.rc and
script.rh.  The script.rc file is an expanded version of script.rs.
This includes a single operation on each line (multiple operation
commands in script.rs are expanded), and additional commands to undo
the operations defined by the script to leave the directory empty at
the completion of one cycle of the script. In addition, each line is
prefixed by a 32-bit checksum which represents the state of the file
system at that point in the script. The script.rh file includes one
line for each state that each of the files and directories that are
created during the test can get into. The state is described by a
string giving key information about the file, such as its owner,
length, and name. A 32-bit hash code is associated with each state.
The state of the entire directory (and it's subdirectories) is given
by the xor of the hash codes of the states of all of the files
currently existing in that directory.

If no options are specified, the compiled form of the script is simply
executed iteratively. The underlying file system is expected to
serialize these operation with respect to recovery.

If the -r operation is specified, the specified directory is scanned
to determine the states of all the files in the subtree, and a 32-bit
checksum of the entire directory is calculated, based upon the hash
codes in script.rh.  The compiled script, script.rc, is then searched
for this checksum. If the checksum exists in the script, then there is
a strong liklihood that the recovery process left the directory in a
state consistent with the ordering of operations in the script.

When testing Episode, multiple filesets may be tested simultaneously
by running multiple rcx processes, one for each directory. This is
necessary because Episode does not guarantee serialization across
filesets.

Rcx requires that the directory specified either be non-existent (for
-c, only) or that it have the file .recovery_test_dir be in an
existing directory. This is to prevent accidental scribbling on a
directory (when rcx first creates the directory, it creates this
file).

The format of the test scripts can be determined by inspection of an
existing script (compare the script .rs file with the compiled output,
.rc for further information), and by looking at the individual support
routines in the rcx script, itself.
------------------------------------------------------------------------------
Runrcx, as the name implies, is a script which will run one or more
copies of the rcx script to test the Episode file system.

It is run by typing:

	runrcx testname

where testname is the name (minus the .rs extension) of an rcx test script,
as described above.

A number of options may be provided in environment variables (yeah,
this is really kludgy). Probably you should just look at the beginning
of the script to find out what these are. Other options can only be
set by editing the script. Most of these options were introduced for
various reasons in the course of looking for bugs that were causing
recovery to fail in various interesting ways (so it was necessary to
have options to go into single step I/O mode, etc.). These are not
easy to generalize, so we haven't attempted to do so. Most of the
options are simply disabled.  If the max concurrent transaction limit
changes for Episode, modify $MAX_CONCURRENT_TRANS_NUM to the new
value.
------------------------------------------------------------------------------

10-30-92 - RA

RCX Script Language
===================

mkdir [mode] dir ...
mkdirs count [mode] dir

rmdir dir ...
rmdir count dir

create path ...
createfiles count path 

rm [forceflag] file ...
rcx_rmfiles count [forceflag] file ...

mv path1 path2
mvpaths count path1 path2

chmod mode path ....
chmodpaths count mode path

chown owner path ....
chownpaths count owner path

chgrp group path ....
chgrppaths count group path

symlink target source ...
symlinkpaths count target source 
****NOTE******
Symlinks are not created in one transaction but 2 and hence do 
not use RCX to test symlinks for now.

link target source ...
linkpaths count target source 

truncate length [forceflag] path ...
truncatepaths length [forceflag] path

write char length offset whence [forceflag] file ...
writefiles count char length offset whence [forceflag] file
****NOTE****
With VM integration on AIX the timing of the updates to a file's
metadata caused by a write can not be controlled.  Thus tests using
these commands may lead to rcx checksum errors on VM integrated systems.

9/17/92 - RA

Implementation Details of RCX
=============================

Assumptions in RCX:
Each operation only acts on one filesystem object directly.

1. Generate possible file system states "rcx -c "

	initialise system state checksum ;
	for ( each operation to be done ) {
		perform operation on object ;
		determine "new" signature of object ;
		if ( object has previous checksum ) {
			undo effect of this previous checksum on 
			 state checksum ;	
			remove this previous checksum for object;
		}
		if ( object still exists ) {
			calculate new checksum for object;
			store <object new checksum, object new signature> 
			 into SIG table;
			update system state checksum with object new checksum;
			store <system state checksum, operation done> into
   			 EXEC table
		}
	}
	
2. Run filesystem operations only - "rcx" without -r or -c. 
   Need compiled script with .rc extension

   	for ( each operation specified in EXEC table ) {
		perform operation
	}

3. Check if file system is in consistent state "rcx -r"

	initialise system state checksum;
	for ( each filesystem object )	{
		form signature string;
		if ( signature not in SIG table ) {	
			# invalid signature -> object in inconsistent state
			generate error;
		}
		else {
			map signature to object checksum using  SIG table;
			update system state checksum with object checksum;
		}
	}
	if ( system state checksum  not in EXEC table ) {
		# System is in inconsistent state
		generate error
	}
	else {
		SWEET SUCCESS !
	}


Implementation Algorithm for runrcx
===================================

Basic:
	Input: File containing rcx operations to be done

	compile rcx operations script [ rcx -c ] to generate individual
     rcx file system operations and to determine valid system states
	start rcx tests in run mode [ rcx without -c or -r options ]
	freeze aggregate at some point
	make copy of aggregate
	unfreeze orignal aggregate.
	run recovery on aggregate copy.
	verify aggregate system state for consistency [ rcx -r ] 

Detailed:
	Input: 	File containing rcx operations to be done
			Number of processes [ assmpn. one process/fileset]
			
	initialise aggregate ;
	for ( each process ) { 
		create fileset ;
		mount fileset ;
	}
	compile rcx operations script [ rcx -c ] to generate individual
     rcx file system operations and to determine valid system states
	for ( each process ) {
		start rcx tests in run mode on corresponding fileset 
		 [ rcx without -c or -r options ];
	}	
	freeze aggregate, make copy of aggregate, unfreeze aggregate;
	if ( recovery on aggregate copy fails ) {
		error handling;
		if ( salvage on aggregate copy fails ) { 
			error handling;			
		}
		else {
			if ( salvager verification of aggregate copy fails ) {
				error handling;
			}
			else {
				verify aggregate system state for consistency [ rcx -r ]; 
			}
		}
	}
	else {
		verify aggregate system state for consistency [ rcx -r ]; 		
	}

	if ( aggregate system state inconsistent ) {
		save aggregate copy for future analysis;
		generate error;
	}
	else {
		SWEET SUCCESS!
	}	

RCX and OSF1
============

The solution decided in OT 7386 has been implemented. A global
variable is set when an aggregate is frozen. OSF/1 on seeing that this
variable is set, would not recycle episode vnodes.

The previous solution suggested of marking each episode vnode as
frozen, would limit one to only one aggregate being frozen in a
system. This is due to unavoidable interactions with vnode
phantomization unless the vnode dephantomization code is modified to
deal with frozen vnodes. To adopt this solution, the async and vnops
layers have to compiled with FREEZE_AGGR_OSF_1 defined to cc.

RCX and Solaris DNLC
====================
To prevent recycling of dnlc entry for a episode vnode from causing
deadlock, we have reduced the window between aggregate freeze and
unfreeze to be just across a private implementation of "dd(1)" in
copyaggr.c.

# Emacs settings for this file follow.
# Local Variables:
# tab-width:4
# End:
	
