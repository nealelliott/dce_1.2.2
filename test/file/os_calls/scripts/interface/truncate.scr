*
* ID: $Id:
*
* ORIGINS: Transarc Corp.
*
* (C) COPYRIGHT Transarc Corp. 1992
* All Rights Reserved
* Licensed Materials - Property of Transarc
*
* US Government Users Restricted Rights - Use, duplication or
* disclosure restricted by GSA ADP Schedule Contract with Transarc Corp
*

*
* @OSF_COPYRIGHT
*
* HISTORY
* $Log$
* $EndLog$
*

*
*  truncate.scr --
*	This script checks the small cache size (128k) and test truncate
*       system calls.


* Usage: file_test -I truncate.scr
*        file_test -I truncate.scr -D
*        or
*        file_test <truncate.scr
*        or
*        See file_test -help


* Note:
*  1. When interrupted the cache size could be 128k in stead of the size set
*     initially.
*  2. Has to be cell_admin.

*  Terminology:
*  PASSED -- no problem for the testings.
*  FAILED -- failed when doing basic checks.
*  WARNING-- skip a check point.
*  XXXXXX -- needs to be enhanced.
*

*
*  Errors: 15
*

*
* Have common variables and procedures set.
*
include common2.env
* Create such number of files to fill up the cache entries.
set numFiles 100

echo
echo Running truncate.scr
echo

**********************************************************************o*
!*                  BASIC CHECKING
************************************************************************

*
* Get the current cache size by pioctl file interface function.
* v1 is cache size permitted and v2 is the size used and v3 is the place
* of the cache (0 in disk);
*
set cacheSize 128
get_cache_size oldCacheSize v2 v3
if ( $v3 != 0 ) {
  echo The current cache is in memory. This test will not change the size of it.
}

umask 0
chdir $testDir
*
* Get patterns to compare.
*
exec getVector "0x00000000000000000000" 20 VECTOR200BZERO
exec getVector $NULL256B 2 VECTOR512BZERO
exec getVector $VECTOR512BZERO 2 VECTOR1KZERO
exec getVector $VECTOR1KZERO 2 VECTOR2KZERO
exec getVector $VECTOR2KZERO 2 VECTOR4KZERO
exec getVector $VECTOR4KZERO 2 VECTOR8KZERO
exec getVector $VECTOR8KZERO 8 VECTOR64KZERO

!* Open a file and do the truncations.

set junk vector 0x0

open $testFile ($O_CREAT|$O_RDWR) 0777 fId
write $fId $NUMVEC64K
assert ($CommandResult == $CONST64K )

* Truncate the file to 0.
*ftruncate $fId 0
truncate $testFile 0
stat $testFile var
assert ( $var.st_size == 0 )

* Truncate the file to next chunk. 
truncate $testFile ($CONST64K * 2 + 8)
*ftruncate $fId ($CONST64K * 2 + 8)
stat $testFile var
if ( $var.st_size != ($CONST64K * 2 + 8) ) {
  set errorMessage "FAILED: Truncate to an offset does not work. --E1"
  exec err_Process
}

* Read all the zeros filled up by truncate.
lseek $fId $SEEK_SET 0
read $fId $CONST64K junk
assert ( $CommandResult == $CONST64K )
echo $junk
echo $VECTOR64KZERO

* May be the data generated by truncation  is not guanteed zeros XXXXX.
* The following assertion may failed on pmax (a db filed).
assert ( $junk == $VECTOR64KZERO )

* Growing the file by cerntain numbers.

*ftruncate $fId 0
truncate $testFile 0

* Set the different offsets.

set offset[0] $CONST64K
set offset[1] 8192
set offset[2] 4096
set offset[3] 2048
set offset[4] 1024
set offset[5] 512
set offset[6] 200
set offset[7] 0

 
*
!* Growing the file by truncatings.
*
set junk vector 0x0
set numLoops 20
set fileSize ( $numLoops * ($CONST64K+8192+4096+2048+1024+512+200))
set origSize int 0
loop x 0 1 7
  loop y 1 1 $numLoops
    ftruncate $fId ($origSize + $offset[$x] )
    stat $testFile var
    assert ($var.st_size == ( $offset[$x]  + $origSize ) ) 
    lseek $fId $SEEK_CUR (-$offset[$x])
    if ( $offset[$x] != 0 ) {
      read $fId $offset[$x] junk
    }
    else {
      set junk vector 0x0
    }
    if ( $x == 0 ) {
      if ( $junk != $VECTOR64KZERO ) {
	set errorMessage "FAILED: Truncate does not fill the region with zeros. --E2"
	exec err_Process
      }
    }
    if ( $x == 1 ) {
      if ( $junk != $VECTOR8KZERO ) {
	set errorMessage "FAILED: Truncate does not fill the region with zeros. --E3"
	exec err_Process
      }
    }
    if ( $x == 2 ) {
      if ( $junk != $VECTOR4KZERO ) {
	set errorMessage "FAILED: Truncate does not fill the region with zeros. --E4"
	exec err_Process
      }
    }
    if ( $x == 3 ) {
      if ( $junk != $VECTOR2KZERO ) {
	set errorMessage "FAILED: Truncate does not fill the region with zeros. --E5"
	exec err_Process
      }
    }
    if ( $x == 4 ) {
      if ( $junk != $VECTOR1KZERO ) {
	set errorMessage "FAILED: Truncate does not fill the region with zeros. --E6"
	exec err_Process
      }
    }
    if ( $x == 5 ) {
      if ( $junk != $VECTOR512BZERO ) {
	set errorMessage "FAILED: Truncate does not fill the region with zeros. --E7"
	exec err_Process
      }
    }
    if ( $x == 6 ) {
      if ( $junk != $VECTOR200BZERO ) {
	set errorMessage "FAILED: Truncate does not fill the region with zeros. --E8"
	exec err_Process
      }
    }
    if ( $x == 7 ) {
      if ( $junk != 0x0 ) {
	set errorMessage "FAILED: Truncate does not fill the region with zeros. --E9"
	exec err_Process
      }
    }
    set origSize $var.st_size
  endloop
endloop

stat $testFile oldVar
assert ( $oldVar.st_size == $fileSize )  

fsync $fId
close $fId

set commd ("ls -l "+$testFile)
shellexec commd

flush_file $testFile

set commd ("ls -l "+$testFile)
shellexec commd

stat $testFile oldVar
assert ( $oldVar.st_size == $fileSize )  

*
!* Check the file after the flush.
*
open $testFile $O_RDWR 0 fId
read $fId $CONST64K junk
if ( $junk != $VECTOR64KZERO ) {
  set errorMessage "FAILED: The file after flush has wrong data in the first chunk. --E10"
  exec err_Process
}

stat $testFile var
if ( $var.st_size != $oldVar.st_size ) {
  set errorMessage "FAILED: The file after flush has wrong size. --E11"
  exec err_Process
}

!* Check the zero region by read.

lseek $fId $SEEK_SET $CONST64K
read $fId 256 junk
assert ( $junk == $NULL256B )

lseek $fId $SEEK_END -256
read $fId 256 junk
assert ( $junk == $NULL256B )

*
!* Shrinking the file by truncatings.
*

set origSize $oldVar.st_size
loop x 0 1 7
  loop y 1 1 $numLoops
    ftruncate $fId ($origSize - $offset[$x] )
    stat $testFile var
    assert ($var.st_size == ( $ origSize - $offset[$x] ) ) 
    set origSize $var.st_size
  endloop
endloop

stat $testFile var
if ( $var.st_size != 0 ) {
  set errorMessage "FAILED: The file shinked has wrong file size. --E12"
  exec err_Process
}

fsync $fId
close $fId

set commd ("ls -l "+$testFile)
shellexec commd

* Check the flushed file.
flush_file $testFile

set commd ("ls -l "+$testFile)
shellexec commd

stat $testFile var
if ( $var.st_size != 0 ) {
  set errorMessage "FAILED: The file flushed has wrong size. --E13"
  exec err_Process
}

*
!* Check small cache size (128k).
*

!* Create small files to fill up the cache and cache entries.
loop x 1 1 $numFiles
  set fileName ($testFile + $x)
  open $fileName ($O_CREAT|$O_RDWR) 0777 fileNameId[$x]
  write $fileNameId[$x] $NUMVEC256B
endloop

!* Read a big file to check the small cache.

open "../onemegabin" $O_RDONLY 0 fId
read $fId $CONST64K junk

* Shrink chache to 128 k (128 is the minimun cache size).
* If the cache is in local disk.
if ( $v3 == 0 ) {
  set_cache_size $cacheSize
  echo Set cache size to $cacheSize
}

loop x 1 1 14
  read $fId $CONST64K junk
  if ( $junk != $NUMVEC64K ) {
    set errorMessage "FAILED: The big file content has been changed since cache'sshrinking. --E14"
    exec err_Process
  }
endloop


* Check that if we lost the information because the cache shrinking.
!* Close the small files here to stress CM.
loop x 1 1 64
  close $fileNameId[$x]
endloop

!* Check if CM did right things.
* We want to read to see anything wrong.
loop x 1 1 64
  set fileName ($testFile + $x)
  open $fileName ($O_CREAT|$O_RDWR) 0777 fileNameId[$x]
  read $fileNameId[$x] 256 junk
  if ( $junk != $NUMVEC256B ) {
    set errorMessage "FAILED: The file content has been changed since cache'sshrinking. --E15"
    exec err_Process
  }
  close $fileNameId[$x]
endloop

* Close the big file.
close $fId




************************************************************************
!* Cleaning up.
************************************************************************
*
*

* Set cache size back to original.
if ( $v3 == 0 ){
  set_cache_size $oldCacheSize
  echo Set cache size back to $oldCacheSize
}

remove $testFile

* Remove the small files.
loop x 1 1 $numFiles
  set fileName ($testFile + $x)
  remove $fileName
endloop

chdir $currentDir
exec clearDir_Proc $testDir
*rmdir $testDir
exec report_Proc "truncate.scr" $errorCounter
echo
quit
