# @OSF_COPYRIGHT@
# COPYRIGHT NOTICE
# Copyright (c) 1990, 1991, 1992, 1993, 1994, 1996 Open Software Foundation, Inc.
# ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for 
# the full copyright text.
# 
# 
# HISTORY
# $Log: host.dcp,v $
# Revision 1.1.11.3  1996/03/09  23:06:35  marty
# 	Update OSF copyright year
# 	[1996/03/09  22:25:25  marty]
#
# Revision 1.1.11.2  1995/12/08  21:24:14  root
# 	Submit OSF/DCE 1.2.1
# 
# 	HP revision /main/HPDCE02/17  1995/10/10  14:56 UTC  truitt
# 	Merge message changes.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts49/1  1995/10/06  13:51 UTC  truitt
# 	CHFts16537: Make sure all help messages fit in the eighty character limit.
# 
# 	HP revision /main/HPDCE02/16  1995/07/31  14:25 UTC  jrr
# 	Fix binary path for HP-UX 10 machines.
# 	Make sure that local config files are created correctly.
# 	Fix host unconfig.
# 
# 	HP revision /main/HPDCE02/jrr_mothra_pure/2  1995/07/31  13:25 UTC  jrr
# 	Fix binary path for HP-UX 10 machines.
# 	Make sure that local config files are created correctly.
# 	Fix host unconfig.
# 
# 	HP revision /main/HPDCE02/14  1995/07/24  20:37 UTC  jrr
# 	# Add -force to unconfigure
# 	# [1995/07/24  20:36 UTC  jrr  /main/HPDCE02/jrr_mothra_pure/1]
# 
# 	HP revision /main/HPDCE02/13  1995/06/21  16:43 UTC  jrr
# 	# Fix creation of .../self RPC entry (CHFts15466).
# 	# [1995/06/21  15:58 UTC  jrr  /main/HPDCE02/jrr_dcecp_chfts15466/1]
# 
# 	HP revision /main/HPDCE02/12  1995/05/15  17:50 UTC  truitt
# 	Merge.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts29/1  1995/05/15  17:49 UTC  truitt
# 	CHFts15237: Correct order of help configure options.
# 
# 	HP revision /main/HPDCE02/11  1995/05/01  18:43 UTC  truitt
# 	Merge bin compat changes.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts26/2  1995/05/01  18:42 UTC  truitt
# 	CHFts14653: Add new variables for binary compat.
# 
# 	HP revision /main/HPDCE02/10  1995/04/19  23:12 UTC  truitt
# 	Merge pe_site work.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts26/1  1995/04/19  23:11 UTC  truitt
# 	CHFts15086: Make sure the pe_site file is created correctly.
# 
# 	HP revision /main/HPDCE02/9  1995/03/31  18:50 UTC  truitt
# 	Merge message work.
# 
# 	HP revision /main/HPDCE02/truitt_mothra_chfts24/1  1995/03/31  18:49 UTC  truitt
# 	CHFts14890: Change the operations message.
# 
# 	HP revision /main/HPDCE02/8  1995/03/27  16:38 UTC  jrr
# 	Make host config work like dce_config (CHFts14681).
# 
# 	HP revision /main/HPDCE02/jrr_dcp_host/2  1995/03/27  16:13 UTC  jrr
# 	Make host config work like dce_config (CHFts14681).
# 
# 	HP revision /main/HPDCE02/7  1995/03/22  16:35 UTC  truitt
# 	Merge changes.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts21/1  1995/03/22  16:34 UTC  truitt
# 	Remove reference to registry being called "master".
# 
# 	HP revision /main/HPDCE02/6  1995/03/06  15:12 UTC  jrr
# 	Finish host config -client.
# 
# 	HP revision /main/HPDCE02/jrr_dcp_host/1  1995/03/06  15:09 UTC  jrr
# 	Finish implementing the 'host configure -client' command.
# 
# 	HP revision /main/HPDCE02/jrr_dcp_host/1  1995/03/06  15:06 UTC  truitt
# 	Finish implementing the 'host configure -client' command.
# 
# 	HP revision /main/HPDCE02/5  1995/02/02  15:39 UTC  truitt
# 	Merge.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts07/1  1995/02/02  15:38 UTC  truitt
# 	Correct bad error message.
# 
# 	HP revision /main/HPDCE02/4  1995/02/01  19:14 UTC  dnguyen
# 	Change /opt/dcelocal references to $dcelocal_path
# 
# 	HP revision /main/HPDCE02/dnguyen_mothra/1  1995/01/31  17:20 UTC  dnguyen
# 	Change /opt/dcelocal references to $dcelocal_path
# 
# 	HP revision /main/HPDCE02/3  1995/01/18  15:50 UTC  truitt
# 	Merge.
# 
# 	HP revision /main/HPDCE02/truitt_dcecp_chfts01/1  1995/01/18  15:48 UTC  truitt
# 	Part of CHFts14059.  Host ping should check for the
# 	/self tag at the end of the host requested, and if
# 	it isn't there, append it.
# 
# 	HP revision /main/HPDCE02/2  1994/11/18  15:22 UTC  truitt
# 	Merge unintegrated
# 	[1995/12/08  17:57:50  root]
# 
# Revision 1.1.7.1  1994/10/26  20:48:51  coren
# 	Miscellaneous improvements to _dcp_host_configure_client (CR 12330),
# 	but not quite enought to get it working.
# 	[1994/10/26  20:08:43  coren]
# 
# 	HP revision /main/HPDCE02/1  1994/11/15  20:12 UTC  truitt
# 	Initial HPDCE02 branch.
# 
# 	HP revision /main/truitt_dcecp_01/1  1994/11/15  20:11 UTC  truitt
# 	Fix help and error messages.
# 
# Revision 1.1.2.6  1994/09/30  21:04:38  coren
# 	Added verbose help text (CR 12337).
# 	Made "show" accept fully-qualified host name (CR 12444).
# 	[1994/09/30  20:54:53  coren]
# 
# Revision 1.1.2.5  1994/09/27  22:27:05  coren
# 	Made "start" start cdsadv on local host. Fixed tests for
# 	already-running servers.
# 	[1994/09/27  17:03:44  coren]
# 
# Revision 1.1.2.4  1994/09/19  22:53:22  coren
# 	Changed to use -s flag with uname.
# 	[1994/09/19  22:51:08  coren]
# 
# 	Undid merge damage (extra line of ===), and patched up PSARGS stuff
# 	in _dcep_server_running.
# 	[1994/09/19  21:26:09  coren]
# 
# Revision 1.1.2.3  1994/09/15  22:42:45  coren
# 	Merged with changes from 1.1.2.2
# 	[1994/09/15  22:42:38  coren]
# 
# 	Upgraded start, stop, and show, merged with incomplete configure code.
# 	[1994/09/15  22:12:40  coren]
# 
# 	Added start, stop, and show operations.
# 	[1994/08/18  20:00:12  coren]
# 
# Revision 1.1.2.2  1994/08/03  21:00:40  kevins
# 	OT 11478 Reworked help sub-processing
# 	[1994/08/03  20:42:47  kevins]
# 
# Revision 1.1.2.1  1994/07/19  19:51:17  rousseau
# 	Initial version.
# 	[1994/07/19  19:51:04  rousseau]
# 
# $EndLog$

#
# The 'host' task script.
#
# This script will perform DCE host configuration management, start and 
# stop servers, and show the current status of specified hosts.
#

#
# Globals
#

# The allows the user to set HOST_DEBUG both before and after source'ing
# this script without having the source stomp the value. The default is
# no debugging output.
if {[info global HOST_DEBUG] == ""} {
    set HOST_DEBUG 0
}

# The default protocol sequence
set DEFAULT_PROTSEQ ncacn_ip_tcp

# Set up OS_NAME and OS_REV
set OS_NAME [exec uname]
set os_rev [exec uname -r]
if {$OS_NAME == "HP-UX"} {
    regexp -- {.+\.(.+)\..+} $os_rev dummy OS_REV
} else {
    set OS_REV $os_rev
}
unset os_rev

# Set up DCE file paths
if {($OS_NAME == "HP-UX") && ($OS_REV >= 10)} {
    set DCE_BIN "/opt/dce/bin"
    set DCE_DAEMONS "/opt/dce/sbin"
    set DCE_VAR "/var/opt/dce"
    set RC_DCE "/sbin/init.d/dce"
    set RC_DFS "/sbin/init.d/dfs"
    set DCE_LIB "/usr/lib"
    set DCE_ETC "/etc/opt/dce"
    set DCE_CONF "/etc/rc.config.d/dce"
} else {
    set DCE_BIN "$dcelocal_path/etc"
    set DCE_DAEMONS "$dcelocal_path/bin"
    set DCE_VAR "$dcelocal_path/var"
    set DCE_LIB "$dcelocal_path/lib"
    set DCE_ETC "$dcelocal_path/etc"
    set DCE_CONF "/etc/rc.dce"
    set RC_DFS "/etc/rc.dfs"
}

# Set up DCE CDS paths
set SUBSYS_DIR subsys/dce

#
# host --
#     This is the entry point for all of the 'host' task script functions.
#

proc host {args} {

    set arg_table {
	{catalog command function_call _dcp_host_catalog
	    "Returns a list of configured hosts in the cell."}
	{configure command function_call _dcp_host_configure
            "Configures a host into the cell as a client or server."}
	{ping command function_call _dcp_host_ping
            "Determines if DCE is responding on the specified host."}
	{show command function_call _dcp_host_show
            "Returns all DCE processes configured on the specified host."}
	{start command function_call _dcp_host_start
            "Starts DCE on the specified host."}
	{stop command function_call _dcp_host_stop
            "Stops DCE on the specified host."}
	{unconfigure command function_call _dcp_host_unconfigure
            "Removes the host from the name and security databases."}
	{help help help_list        
	    "Prints a summary of command-line options."}
	{operations operations operation_list 
	    "Returns a list of the valid operations for this command."}
    }

    set verbose_prose \
"This object allows remote configuration and control of hosts within a
cell.  The argument is a single relative or fully-qualified DCE host
name.  A host may be configured only as a client.  Starting or
stopping a host starts or stops those servers that have been created
as server configuration objects stored in dced.  A remote host can be
started only if dced is already running on that host.  To start any
host, a security server and a CDS server must be running on some host
in the cell.  The configure and unconfigure operations require w and i
permissions on the srvrconf directory of the host; the start, stop,
and show operations require r access to both the srvrconf and srvrexec
directories.  Permission for the start, stop, and show operations also
depends on the ACLs of each of the server objects.  The start
operation requires x permission on the srvrconf objects, the show
operation requires r permission on the srvrconf and srvrexec objects,
and the stop operation requires s permission on the srvrexec objects.
In addition, to configure, unconfigure, start, or stop the local host,
you must be able to start privileged processes."

    _dcp_host_debug "args is '$args'"

    set local_args $args

    parseargs $arg_table local_args -found_one

    if {[info local help_prose] > 0} {
        return $help_prose
    }


    if {[info local function_call ] > 0} {
        _dcp_host_debug "Calling '$function_call' with '$local_args'"
	return [$function_call local_args]
    } else {
	error "The \"host\" object requires a verb to form a command."
    }
}


#
# _dcp_host_catalog --
#     Return a list of names of hosts in the specified cell. All names are
# fully qualified unless the '-simplename' option is given, in which case
# they are cell relative.
#

proc _dcp_host_catalog {local_args} {

    upvar local_args cargs
    set local_args $cargs

    _dcp_host_debug "Received args '$local_args'"

    set arg_table {
	{-simplename boolean simple_flag
            "Display host names in cell relative format."}
    }

    # Parse the argument list
    parseargs $arg_table local_args -no_leftovers
    
    # Check for help
    if {[info local help_prose] > 0} {
        return $help_prose
    }
    
    # Check for extra arguments, and handle the one optional argument.
    if {[llength $local_args] > 1 } {
	error "Unrecognized argument [lindex $local_args 1]."  
    } elseif {[llength $local_args] == 0 } { 
	set cell_name "/.:"
    } else { 
	# Do some error checking on the cell name here
	set cell_name $local_args 
    }
    
    _dcp_host_debug "Generating hosts list..."

    set hostnames [directory list $cell_name/hosts -directories]
    set result ""
    foreach i $hostnames {
	if {[info local simple_flag] > 0} {
	    # Print out the simple name
	    set result [concat $result [lindex [name parse $i] 1]]
	} else {
	    # Print out the FQ'ed name
	    set result [concat $result $i]
	}
    }

    regsub -all " " $result "\n" fmt_result
    return $fmt_result
}


# 
# _dcp_host_configure --
#     
#   The monster host configuration script. 
#

proc _dcp_host_configure {args} {
    global dcelocal_path dce_hostname cell_name SUBSYS_DIR OS_NAME OS_REV 
    global DCE_DAEMONS DCE_VAR OS_NAME OS_REV

    upvar local_args cargs
    set local_args $cargs

    _dcp_host_debug "In configure with args: '$local_args'"
    
    set client_flag 0
    set server_flag 0
    set admin_name ""
    set cell_name ""
    set cds_host ""
    set sec_host ""
    set password ""

    set arg_table {
	{-admin string admin_name
            "The name of the cell administrator principal."}
	{-cds string cds_host
	    "The hostname of a CDS server in the cell."}
	{-cell string cell_name
            "The name of the cell to configure into."}
	{-client boolean client_flag
	    "Configure specified machine as a client."}
	{-password string password
            "The password of the cell administrator principal."}
	{-secmaster string sec_host
            "The hostname of the security master in the cell."}
	{-server boolean server_flag
	    "Configure specified machine as a server."}
    }

    # Parse the argument list
    parseargs $arg_table local_args -no_leftovers

    # Check for help
    if {[info local help_prose] > 0} {
	return 
    }

    # Make sure that the user specified -client or -server
    if {(!$server_flag) && (!$client_flag)} {
        error "You must specify either '-client' or '-server'."
    }

    # Prune out -server and let the user know that it's unimplemented
    if {$server_flag} {
        error "Server configuration is currently not supported."
    }

    # Check for extra arguments, and handle the one required argument.
    if {[llength $local_args] > 1} {
	error "Unrecognized argument [lindex $local_args 1]."  
    } elseif {[llength $local_args] == 0 } { 
	error "The command requires the name of a host to configure."
    } elseif {($cds_host == "") || ($sec_host == "")} {
	error "Both the '-cds' and '-secmaster' options are required."
    } elseif {$cell_name == ""} {
	error "The '-cell' option is required."
    }

    # Check if the cell_name is a fully qualified name
    if {[string first "/.../" $cell_name] != 0} {
        error "The entry '$cell_name' is not a fully qualified cell name."
    }

    _dcp_host_debug "setting dce_hostname, local_args = $local_args"
    set dce_hostname $local_args
    # Check if the hostname is of hosts/hostname format
    if {[string first "hosts/" $dce_hostname] != 0} {
        error "The hostname '$dce_hostname' must in the format of 'hosts/<hostname>'."
    }

    # Check that we are configuring our own host
    set hostname [exec hostname]
    set index_of_dot [string first . $hostname]
    if {$index_of_dot == -1} {
        set simplehost $hostname
    } else {
        set simplehost [string range $hostname 0 [expr $index_of_dot - 1]]
    }
    
    if { ![string match $dce_hostname hosts/$simplehost] } {
        error "You can only configure the local host. `$dce_hostname' is invalid."
    }

    # Arg checking
    if {$admin_name == ""} {
	set admin_name "cell_admin"
    }
    _dcp_host_debug "admin_name is $admin_name"
    
    if {$password == ""} {
	error "Specifying the password for '$admin_name' with\
                '-password' is required."
    }


    # Check to see if DCE is installed
    if {[file exists $DCE_DAEMONS/dced] == 0} {
	error "DCE needs to be installed on this machine before configuring."
    }

    # Create the timezone link and the dce_cf.db file
    _dcp_host_set_timezone
    _dcp_host_create_cf_db $sec_host

    # Fix the perms on /dev/lan0 (UX9) or /dev/dlpi (UX10) for HP's
    if {($OS_NAME == "HP-UX") && ($OS_REV >= 10)} {
        _dcp_host_debug "Setting perms on /dev/dlpi"
        exec chmod a+rw /dev/dlpi
    } else {
        _dcp_host_debug "Setting perms on /dev/lan*"
        foreach x [glob /dev/lan*] {
            exec chmod a+r $x
        }
    }
    
    # Initialize dced
    if {[file exists $DCE_VAR/dced/Acl.db] == 0} {
	_dcp_host_debug "Initializing dced (dced -i)"
	if {[catch {exec $DCE_DAEMONS/dced -i} msg] != 0} {
	    error "DCED initialization failed: $msg"
	}
    }

    # Start dced
    _dcp_host_debug "Starting dced (dced -b)"
    if ![_dcp_host_server_running dced] {
        if {[catch {exec $DCE_DAEMONS/dced -b &} msg] != 0} {
	   error "DCED failed to start: $msg"
        }
        _dcp_host_debug "Started dced"
        _dcp_host_update_rcfile dced
    }

    # Check (and fix if need be) the time against the security server
    _dcp_host_checktime $sec_host

    # Create the pe_site file
    _dcp_host_debug "Creating pe_site file"
    _dcp_host_create_pe_site $sec_host

    # Create /krb5/krb.conf
    _dcp_host_create_krb5 $cell_name $sec_host

    # Modify /etc/services
    _dcp_host_debug "Checking if /etc/services needs updating"
    if {[_dcp_host_modify_etc_services] != 0} {
        error "Unable to update /etc/services."
    }

    # Login 
    _dcp_host_debug "Performing login"
    if {[catch {login $admin_name -p $password} msg] != 0} {
	error "Unable to login to the DCE security service: $msg"
    }

    # Create registry entries
    _dcp_host_debug "Creating registry entries"
    if {[catch {principal create $dce_hostname/self
    group add none -member $dce_hostname/self
    organization add none -member $dce_hostname/self
    account create $dce_hostname/self -gr none -org none -mypwd $password \
            -passw $password} msg] != 0} {
        error "Unable to create registry entries: $msg"
    }

    _dcp_host_debug "Creating keytab using rgy_edit"

    # This (will | better | needs to | really should) go away when keytab works
    # See the comment block below.
    if {[catch {exec rgy_edit -up << "ktadd -p $dce_hostname/self -pw \
            $password"} msg] != 0} {
        error "Unable to create keytab: $msg"
    }
    if {[catch {exec rgy_edit -up << "ktadd -p \
            $dce_hostname/self -a -r"} msg] != 0} {
        error "Unable to create keytab: $msg"
    }

# # This is closer to reality than before. What we are waiting on is the 
# # ability to do keytab commands with string bindings so that we can 
# # contact dced before the nameservice is available.
# 
#     # Create the machine identity's keytab file.
#     _dcp_host_debug "Creating keytab file"
#     if {[catch {keytab create /.:/$dce_hostname/config/keytab/self \
#             -annotation "Machine identity" \
#             -storage /krb5/v5srvtab \
#             -local \
#             -data \
#             {/.../$cell_name/$dce_hostname/self plain 1 $password}} msg] != 0} {
#         error "Unable to create keytab file: $msg"
#     }
# 
#     # Randomize the machine identity's password
#     _dcp_host_debug "Randomizing password in keytab file"
#     if {[catch {keytab add -storage /krb5/v5srvtab \
#             -local \
#             -random \
#             -member /.../$cell_name/$dce_hostname/self} msg] != 0} {
#         error "Unable to create keytab file: $msg"
#     }

    # Check for (and start if need be) the secval service.
    _dcp_host_start_secval_service $cell_name $sec_host

    # Wait for node self-id to be established
    
    set credfile $DCE_VAR/security/creds/dcecred_ffffffff
    set creddata $DCE_VAR/security/creds/dcecred_ffffffff.data
    set id_found 0
    for { set i 0 } { $i < 15 } { incr i 1 } {
        if {[file isfile $credfile] && [expr [file size $credfile] > 0] &&
            [file isfile $creddata] && [expr [file size $creddata] > 0]} {
            set id_found 1
            _dcp_host_debug "Found creds files"
            break
        } else {
     	   _dcp_host_debug "sleeping 5"
           exec sleep 5
        }
    }

    if { ! $id_found } {
       error "Machine identity not established within time limit."
    }

    # Name space initialization.
    _dcp_host_init_ns $cell_name $cds_host $dce_hostname

    # Create namespace entries
    _dcp_host_create_ns_entries $dce_hostname

    # Set namespace ACL's
    _dcp_host_set_ns_acls $dce_hostname

    # Kick off a dtsd clerk
    _dcp_host_debug "starting dtsd -c"
    if {[catch {exec $DCE_DAEMONS/dtsd -c} msg] != 0} {
        _dcp_host_debug "Start of dtsd failed: $msg"
        error "Could not start dtsd clerk: $msg"
    }
    _dcp_host_update_rcfile dtsd "-c"

    # Kick off a dtstimed on pre HP-UX 10.0 machines
    if {($OS_NAME == "HP-UX") && ($OS_REV < 10)} {
        _dcp_host_debug "running on a pre HP-UX 10.0 machine"
        _dcp_host_debug "starting dtstimed"
        if {[catch {exec $DCE_DAEMONS/dtstimed} msg] != 0} {
            _dcp_host_debug "Start of dtstimed failed: $msg"
            error "Could not start dtstimed: $msg"
        }
        _dcp_host_update_rcfile dtstimed
    }

    _dcp_host_debug "Exiting happily :-)"
}


#
# _dcp_host_ping --
#     Test if DCE processes are available from the specified host.
# Contacts dced or rpcd on the remote host. Returns '1' if the host
# responds, '0' if not.
#

proc _dcp_host_ping {args} {

    upvar local_args cargs
    set local_args $cargs

    set arg_table {
    }

    # Parse the argument list
    parseargs $arg_table local_args -no_leftovers

    # Check for help
    if {[info local help_prose] > 0} {
        return $help_prose
    }

    # Check for extra arguments, and handle the one required argument.
    if {[llength $local_args] > 1} {
        error "Unrecognized argument [lindex $local_args 1]."  
    } elseif {[llength $local_args] == 0 } { 
        error "The command requires the name of a host to ping."
    } else { 
        set host_name $local_args 
    }

    # Put 'self' on the end of the hostname if necessary.
    if {[string match *hosts* $host_name] &&
        ![string match *self $host_name] &&
        ![string match *profile $host_name] &&
        ![string match *config $host_name] &&
        ![string match *cds-clerk $host_name] &&
        ![string match *dts-entity $host_name] &&
        ![string match "{" [string range $host_name 0 0]] &&
        ![string match "}" [string range $host_name 0 0]]} {
        set new_name [format "%s/self" $host_name]
    } else {
        set new_name $host_name
    }

    return [server ping $new_name]
}


# 
# _dcp_host_unconfigure --
#     Unconfigure a host from a cell.
#

proc _dcp_host_unconfigure {args} {
    global _p _n DCE_VAR
    
    upvar local_args cargs
    set local_args $cargs

    if { [info local help_prose ] > 0 } { return }

    _dcp_host_debug "Received args '$local_args'"

    set arg_table {
	{-force boolean force
            "Forcibly remove configuration, ignoring errors."}
    }

    set force 0

    # Parse the argument list
    parseargs $arg_table local_args -no_leftovers
    
    # Check for help
    if {[info local help_prose] > 0} {
        return $help_prose
    }
    
    # Check for extra arguments, and handle the one required argument.
    if {[llength $local_args] > 1} {
	error "Unrecognized argument [lindex $local_args 1]."  
    } elseif {[llength $local_args] == 0 } { 
	error "The command requires the name of a host to unconfigure."
    } elseif {[string first "hosts/" $local_args] != 0} {
	error "'$local_args' is not a fully qualified host name."
    }

    set parsed_args [name parse $local_args]
    set cell_name [lindex $parsed_args 0]
    set host_name [lindex $parsed_args 1]

    # Delete CDS namespace entries
    _dcp_host_debug "Deleting CDS namepsace entries"
    if {[catch {directory delete $cell_name/$host_name -tree -force} msg] != 0} {
        _dcp_host_debug "Directory delete -tree -force of $cell_name/$host_name failed: $msg"
        if {$force == 0} {
            error "Directory delete of $cell_name/$host_name failed: $msg"
        }
        _dcp_host_debug "... Running with -force. Continuing."
    }

    # Playing dirty...
    set _n $cell_name/$host_name
    set sync_dir $_p
    if {[catch {directory synchronize $sync_dir} msg] != 0} {
        _dcp_host_debug "Directory sync of $sync_dir failed: $msg"
        if {$force == 0} {
            error "Directory sync of $sync_dir failed: $msg"
        }
        _dcp_host_debug "...running -force. Continuing."
    }
    

    # Delete principals
    # If we ever want to do this for foreign cells, we will need to 
    # set _s(sec) to point to the foreign sec server. 
    _dcp_host_debug "Looking for principals to delete..."
    foreach princ [principal catalog -simplename] {
	if {[string match $host_name [string range $princ 0 \
            [expr [string length $host_name] - 1]]] == 1} {
	    _dcp_host_debug "Deleting principal '$princ'"
	    if {[catch {principal delete $princ} msg] != 0} {
                _dcp_host_debug "Principal delete $princ failed: $msg"
                if {$force == 0} {
                    error "Could not delete principal $princ: $msg"
                }
                _dcp_host_debug "...running -force. Continuing."
	    }
	}
    }

    # Remove dced databases
    _dcp_host_debug "Removing dced databases"
    set file_list [glob -nocomplain $DCE_VAR/dced/*.db]
    _dcp_host_debug "dced database list is $file_list"
    foreach x $file_list {
        if {[catch {exec rm $x} msg] != 0} {
            _dcp_host_debug "Delete of dced databases failed: $msg"
            if {$force == 0} {
                error "Delete of dced databases failed: $msg"
            }
            _dcp_host_debug "...running -force. Continuing."
        }
    }
}


#
# _dcp_host_show --
#     Return a list of servers configured to run on the specified
#     host, along with an indication for each of whether it is
#     currently running or not.
#

proc _dcp_host_show {local_args} {

    upvar local_args cargs
    set local_args $cargs

    _dcp_host_debug "Received args '$local_args'"

    set arg_table {
    }

    # Parse the argument list
    parseargs $arg_table local_args -no_leftovers
    
    # Check for help
    if {[info local help_prose] > 0} {
        return $help_prose
    }
    
    # Check for extra arguments, and handle the one optional argument.
    if {[llength $local_args] > 1 } {
	error "Unrecognized argument [lindex $local_args 1]."  
    } elseif {[llength $local_args] == 0 } { 
	set host_name hosts/[exec hostname]
    } else { 
	# Do some error checking on the host name here
	set host_name $local_args 
    }
    if {[string match /* $host_name]} {
        set full_hostname $host_name
    } else {
        set full_hostname /.:/$host_name
    }
    set hlist [split $full_hostname /]
    set simple_hostname [lindex $hlist [expr {[llength $hlist] - 1}]]

    set return_list ""

    _dcp_host_debug "Getting list of configured servers"

    set conf_servers [server catalog $host_name -simplename]

    _dcp_host_debug "Getting list of running servers"

    set run_servers [server catalog $host_name -simplename -executing]

    set first 1
    foreach name $conf_servers {
        if {[lsearch $run_servers $name] != -1} {
	    set this_server "$name running"
# assumes server name corresponds to program name
            if {$name == "dtsd"} {

                # get server-type of dtsd on target host

		if {[llength $local_args] == 0} {

                # local host is easy

		    set attrib [dts show]
		} else {

		# hopefully this will work

		    set attrib [dts show $full_hostname/dts-entity]
		}
                set this_server [linsert $this_server 2 [attrlist getvalues $attrib -type type]]
            } elseif {$name == "secd"} {

	        # similarly for secd
	        set reg_list [registry catalog]

                # registry servers usually have host name in their names

		set hindex [lsearch $reg_list *$simple_hostname*]
                if {[expr {$hindex == -1}]} {
		    error "Unable to find registry server on $host_name."
		}
		set attrib [registry show [lindex $reg_list $hindex] -replica]
                set this_server [linsert $this_server 2 [attrlist getvalues $attrib -type type]]
            }
        } else {
            set this_server "$name notrunning"
        }

	_dcp_host_debug [format "this_server: %s (%s)" $this_server [llength $this_server]]
        if {$first != 0} {
            set return_list [list $this_server]
            set first 0
        } else {
            set return_list [format "%s\n%s" $return_list [list $this_server]]
        }
    }

    return $return_list
}


#
# _dcp_host_start --
#     Start all configured servers on the specified host (actually,
#     those that are configured with a "starton" attribute of "boot"
#     or "explicit"). If no host is specified, start dced on the local
#     host first; otherwise, dced must be running on the specified
#     host.


proc _dcp_host_start {local_args} {
    global dcelocal_path

    upvar local_args cargs
    set local_args $cargs

    _dcp_host_debug "Received args '$local_args'"

    set arg_table {
    }

    # Parse the argument list
    parseargs $arg_table local_args -no_leftovers
    
    # Check for help
    if {[info local help_prose] > 0} {
        return $help_prose
    }
    
    # Check for extra arguments, and handle the one optional argument.
    if {[llength $local_args] > 1 } {
	error "Unrecognized argument [lindex $local_args 1]."  
    } elseif {[llength $local_args] == 0 } { 
	set host hosts/[exec hostname]
        set host_name /.:/hosts/[exec hostname]
    } else { 
	# Do some error checking on the host name here
        set host $local_args
	set host_name $local_args 
    }

    if {[llength $local_args] == 0} {
        if {![_dcp_server_running dced]} {
           _dcp_host_debug "Starting dced on local host"
           if {[catch {exec $dcelocal_path/bin/dced &} msg] !=0} {
              error "Error starting dced: $msg"
           } else {
              _dcp_host_debug "dced started"
           }
        }
        if {![_dcp_server_running cdsadv]} {
           _dcp_host_debug "Starting cdsadv on local host"
           if {[catch {exec $DCE_DAEMONS/cdsadv &} msg] !=0} {
              error "Error starting cdsadv: $msg"
           } else {
              _dcp_host_debug "cdsadv started"
              # Give cds a chance to get initialized
              exec sleep 5
           }
        }
    }

    _dcp_host_debug "Getting list of configured servers"
    if {[catch {set server_list [server catalog $host]} msg] != 0} {
        error "Unable to catalog servers on $host_name: $msg"
    }

# now rearrange the list so that servers are started in the right
# order. Remove dced first of all.

    _dcp_host_debug "Removing dced from list"
    set found [lsearch $server_list *dced]
    if {$found != -1} {
        set server_list [lreplace $server_list $found $found]
    }

# on local host, remove cdsadv, as it's been started already

    if {[llength $local_args] == 0} {
       _dcp_host_debug "Removing cdsadv from list"
       set found [lsearch $server_list *cdsadv]
       if {$found != -1} {
           set server_list [lreplace $server_list $found $found]
       }
    }

# Find entries for DCE's own servers, and put them at the beginning,
# in appropriate order.

    _dcp_host_debug "Rearranging server list"
    set position 0
    foreach d {secd cdsadv cdsd dtsd auditd} {
        set found [lsearch $server_list *$d]
#       skip if this server isn't configured
        if {$found != -1} {
#           don't bother if it's in the right position already

            if {$found != $position} {
                set copy [lindex $server_list $found]
                set server_list [lreplace $server_list $found $found]
                set server_list [linsert $server_list $position $copy]
                _dcp_host_debug "Moved $d"
            }
            incr position 1
        }
    }

# deactivate/reactivate secval. Don't care if the deactivate fails

    catch {secval deactivate $host}
    if {[catch {secval activate $host} msg] != 0} {
	error "Unable to activate secval: $msg"
    }

    set running_servers [server catalog $host -executing -simplename]

    foreach server $server_list {

        if {[catch {set attributes [server show $server]} msg] != 0} {
            error "Unable to show $server: $msg"
        }

#       if server is already running, don't try to start it

        set plist [split $server /]
	set servname [lindex $plist [expr {[llength $plist] - 1}]]
        if {[lsearch $running_servers *$servname] == -1} {
            set starton [attrlist getvalues $attributes -type starton]
            if {[llength $starton] == 0} {
                error "starton not found for $server."
            }

            if {[expr {[lsearch $starton "boot"] != -1}] || [expr {[lsearch $starton "explicit"] != -1}]} {
                 _dcp_host_debug "Starting $server"
	         if {[catch {server start $server} msg] != 0} {
                     error "Could not start $server: $msg"
                 }
            }
        }
    }
}


#
# _dcp_host_stop --
#     Stop all running servers on the specified host (or the local
#     host if none specified).  If no host is specified, stop dced on
#     the local host when finished; otherwise, dced must be running on
#     the specified host.
#     Takes a -force option to forcibly stop any servers that fail to
#     stop normally.

proc _dcp_host_stop {local_args} {

    upvar local_args cargs
    set local_args $cargs

    _dcp_host_debug "Received args '$local_args'"

    set arg_table {
	{-force boolean force_flag
            "Forcibly stop servers that fail to stop normally."}
    }

    set force_flag 0

    # Parse the argument list
    parseargs $arg_table local_args -no_leftovers]
    
    # Check for help
    if {[info local help_prose] > 0} {
        return $help_prose
    }
    
    # Check for extra arguments, and handle the one optional argument.
    if {[llength $local_args] > 1 } {
	error "Unrecognized argument [lindex $local_args 1]."  
    } elseif {[llength $local_args] == 0 } { 
        set host hosts/[exec hostname]
	set host_name /.:/hosts/[exec hostname]
    } else { 
	# Do some error checking on the host name here
        set host $local_args
	set host_name $local_args 
    }

    _dcp_host_debug "Getting list of running servers"
    if {[catch {set server_list [server catalog $host -executing]} msg] != 0} {
        error "Unable to catalog servers on $host_name: $msg"
    }

#   Rearrange list of servers so that DCE's own servers are stopped last,
#   in the correct order

    _dcp_host_debug "Rearranging server list"
    foreach d {auditd dtsd cdsd secd cdsadv dced} {
        set found [lsearch $server_list *$d]
        if {$found != -1} {
            set copy [lindex $server_list $found]
            set server_list [lreplace $server_list $found $found]
            if {[expr {[llength $local_args] == 0}] || [expr {$d != "dced"}]} {
                set server_list [linsert $server_list [llength $server_list] $copy]
            _dcp_host_debug "Moved $d to end"
            }
        }
    }

    _dcp_host_debug "server_list: $server_list"
    foreach server $server_list {
#       put in special-case for dtsd here
        set namelist [split $server /]
        if {[lindex $namelist [expr [llength $namelist] -1]] == "dtsd"} {
# Alternative 1
             _dcp_host_debug "Stopping $server"
             if {[catch {server stop $server -method soft} msg] != 0} {
                 error "Could not stop $server: $msg"
             }

# Alternative 2 (not available until "name" attribute works)

#            set dtsname [attrlist getvalues [server show $server] -type entryname]
#            if {[catch {dts stop $dtsname} msg] != 0} {
#                error "Could not stop $dtsname: $msg"
#            }

# End alternatives
        } else {
             _dcp_host_debug "Stopping $server"
             if {[catch {server stop $server} msg] != 0} {
                 error "Could not stop $server: $msg"
             }
#            In case server hasn't registered with dced, try to stop
#            it with TERM signal

             if {[catch {server show $server -executing}] == 0} {
                 _dcp_host_debug "Stop $server -method soft"
                 if {[catch {server stop $server -method soft} msg] != 0} {
                     error "Could not stop $server -method soft: $msg"
                 }
             }
        }
    }

#   if -force, make sure servers above really stopped

    if {$force_flag} {
        _dcp_host_debug "Getting list for force"
        set server_list [server catalog $host -executing]
        _dcp_host_debug "server_list: $server_list"
        if {[expr {[llength $server_list] > 0}]} {
            foreach server $server_list {
                _dcp_host_debug "Stopping $server -method hard"
                server stop $server -method hard
            }
        }
    }

    if {[expr {[llength $local_args] == 0}] && [_dcp_server_running cdsadv]} {
        puts stderr "cdsadv still running on local host"
    }

}





## 
##  host script utilities
##

#
# _dcp_host_set_timezone
#     Set up the localtime file on the local machine. The user of the
# script must be root (of have sufficient privs on the local filesystem)
# to do this.
#

proc _dcp_host_set_timezone {} {
    global DCE_ETC
    global env

    if {[file exists $DCE_ETC/zoneinfo/localtime] == 0} {
	switch {$env(TZ)} {
            MEZ-1MESZ {set TZfile "MET"}
            MET-1METDST {set TZfile "MET"}
            GMT0BST {set TZfile "GB-Eire"}
            PST8PDT {set TZfile "US/Pacific"}
            EST5EDT {set TZfile "US/Eastern"}
            CST6CDT {set TZfile "US/Central"}
            MST7MDT {set TZfile "US/Mountain"}
            AST4ADT {set TZfile "Canada/Atlantic"}
            NST3:30NDT {set TZfile "Canada/Newfoundland"}
            EST5CDT {set TZfile "US/East-Indiana"}
            AST10ADT {set TZfile "US/Aleutian"}
            YST9YDT {set TZfile "Canada/Yukon"}
            WET0WETDST {set TZfile "GB-Eire"}
            PWT0PST {set TZfile "WET"}
            SAST-2SADT {set TZfile "GMT+2"}
            CST-9:30CDT {set TZfile "Australia/Yancowinna"}
            EST-10EDT {set TZfile "Australia/NSW"}
            NZST-12NZDT {set TZfile "NZ"}
            EST-10EDT#Tasmania {set TZfile "Australia/NSW"}
            PST8PDT#Canada {set TZfile "Canada/Pacific"}
            MST7MDT#Canada {set TZfile "Canada/Mountain"}
            CST6CDT#Canada {set TZfile "Canada/Central"}
            EST5EDT#Canada {set TZfile "Canada/Eastern"}
            EST6CDT {set TZfile "US/East-Indiana"}
            default {set TZfile "GMT"}
	}
	
	exec ln -s $TZfile $DCE_ETC/zoneinfo/localtime
	_dcp_host_debug "Created link to '$TZfile' from '$DCE_ETC/zoneinfo/localtime'"
    }
}


#
# _dcp_host_create_cf_db
#    Create the $dcelocal_path/dce_cf.db file on the local filesystem.
# The user of this script must be root (or have sufficient privs on
# the local filesystem) to do this.

proc _dcp_host_create_cf_db {sec_host} {
    global cell_name dce_hostname dcelocal_path DEFAULT_PROTSEQ

    _dcp_host_debug "sec_host is $sec_host"

    set ip [exec getip $sec_host]
    _dcp_host_debug "${sec_host}'s IP address is $ip"

    # Get the cell name info from the dced on the master
    if {[catch {attrlist getvalues [hostdata show $DEFAULT_PROTSEQ:$ip -ifname cell_name] -type hostdata/data} new_cell] != 0} {
        _dcp_host_debug "Hostdata show (cell_name if) on $ip failed: $new_cell..."
        _dcp_host_debug "Using supplied value of $cell_name as the cell name"
        set real_cell_name $cell_name
    } else {
        set real_cell_name $new_cell
    }

    # Create the $dcelocal_path/dce_cf.db file
    set fd [open "$dcelocal_path/dce_cf.db" w]
    _dcp_host_debug "Writing dce_cf.db file"
    puts $fd "cellname $real_cell_name"
    puts $fd "hostname $dce_hostname"
    puts $fd "krb5_ccache_vno 1"
    puts $fd "krb5_kt_vno 1"
    puts $fd "gen_v1_pac true"
    close $fd
}


#
# _dcp_host_create_pe_site
#    Create the $DCE_ETC/security/pe_site file on the local 
# filesystem. The user of this script must be root (or have sufficient 
# privs on the local filesystem) to do this.
# Start by using hostdata show -iftype pe_site on the master. This will 
# give us a list of ALL security servers in the cell. If this fails, 
# use endpoint show to get the info for the master. The pe_site thread in
# dced should update the file later.
#

proc _dcp_host_create_pe_site {sec_host} {
    global cell_name dcelocal_path SUBSYS_DIR DCE_ETC DEFAULT_PROTSEQ

    _dcp_host_debug "sec_host is $sec_host"

    set ip [exec getip $sec_host]
    _dcp_host_debug "${sec_host}'s IP address is $ip"

    if {[catch {attrlist getvalues [hostdata show $DEFAULT_PROTSEQ:$ip -ifname pe_site] -type hostdata/data} eps] != 0} {
        _dcp_host_debug "Hostdata show (pe_site if) on $ip failed: $eps..."
        _dcp_host_debug "using endpoint show instead."

        if {[catch {set eps [endpoint show "$DEFAULT_PROTSEQ:$ip" \
                -interface {4C8782805000.0D.00.02.87.14.00.00.00 1.0}]} msg] != 0} {
            _dcp_host_debug "endpoint lookup on '$sec_host' failed: $msg"
            error "Could not access endpoint map on '$sec_host': $msg"
        }

        _dcp_host_debug "Endpoints are:\n$eps"

        # Create the $DCE_ETC/security/pe_site file
        set fd [open "$DCE_ETC/security/pe_site" w]
        foreach ep $eps {
            _dcp_host_debug "Working on $ep..."
            set obj_uuid [attrlist getvalues $ep -type object]
            _dcp_host_debug "obj_uuid is $obj_uuid"
            set protseq [lindex [lindex [attrlist getvalues $ep -type binding] 0] 0]
            _dcp_host_debug "protseq is $protseq"
            puts $fd "$cell_name $obj_uuid@$protseq:$ip\[\] $SUBSYS_DIR/sec/$sec_host"
            _dcp_host_debug "Wrote\n$cell_name $obj_uuid@$protseq:$ip\[\] $SUBSYS_DIR/sec/$sec_host\nto pe_site file"
            close $fd 
        }
    } else {
        # Hostdata show worked.
        _dcp_host_debug "Endpoints are:\n$eps"

        # Create the $DCE_ETC/security/pe_site file
        set fd [open "$DCE_ETC/security/pe_site" w]
        foreach ep $eps {
            puts $fd "$ep"
            _dcp_host_debug "Wrote\n$ep\nto pe_site file"
        }
        close $fd 
    }
}


#
# _dcp_host_checktime
#     Checktime synchronizes current node's system time with the server node's.
# It will update the current node's system time if the time difference is
# greater than $clock_skew_min, and we do not synchronize clocks if the 
# difference is greater than $clock_skew_max.
#

proc _dcp_host_checktime {sec_host} {
    global cell_name dcelocal_path

    _dcp_host_debug "sec_host is $sec_host"

    # Fix time if over 60 seconds and fail if over 20 minutes
    set clock_skew_min "+0-00:00:30.000I-----"
    set clock_skew_max "+0-00:20:00.000I-----"

    # Get the time from the $sec_server by trying:
    #   dtsd, dced and inetd in order.
    if {[catch {clock show -dced $sec_host} ref_time] != 0} {
        if {[catch {clock show -inetd $sec_host} ref_time] != 0} {
            error "Could not get time from '$sec_host'."
        }
    }

    _dcp_host_debug "ref time is $ref_time"

    # Get our time. dts isn't up, so just try dced and inetd.
    if {[catch {clock show -dced localhost} our_time] != 0} {
        if {[catch {clock show -inetd localhost} our_time] != 0} {
            error "Could not get local time."
        }
    }
    _dcp_host_debug "our time is $our_time"

    switch -- [utc compare $ref_time $our_time -noinaccuracy] {
        1 {set diff_time [utc subtract $ref_time $our_time]}
        -1 {set diff_time [utc subtract $our_time $ref_time]}
        0 {set diff_time +0-00:00:00.000I-----}
    }
    
    _dcp_host_debug "diff_time is $diff_time"

    # Figure out what to do depending on the skew
    switch -- [utc compare $diff_time $clock_skew_min -noinaccuracy] {
        -1 {return 0}
        1 {
            if {[utc compare $diff_time $clock_skew_max -noinaccuracy] == 1} {
                error "Time difference is greater than allowed skew\
                        of '$clock_skew_max'"
            }
        }
        0 {return 0}
    }
    
    # Fix the time
    if {[catch {clock synchronize -inetd $sec_host} msg] != 0} {
        if {[catch {clock synchronize -dced $sec_host} msg] != 0} {
            if {[catch {clock synchronize $sec_host} msg] != 0} {
                error "clock syncronization failed: $msg"
            }
        }
    }
}


#
# _dcp_host_create_krb5
#
# Creates /krb5 files.
# 

proc _dcp_host_create_krb5 {cell_name sec_host} {
    global DEFAULT_PROTSEQ

    _dcp_host_debug "sec_host is $sec_host"

    # Create /krb5/krb.conf file
    _dcp_host_debug "Creating /krb5/krb.conf"
    if {[file isdirectory /krb5] == 0} {
	exec mkdir /krb5
    }

    set ip [exec getip $sec_host]
    _dcp_host_debug "${sec_host}'s IP address is $ip"

    # Get the cell name info from the dced on the master
    if {[catch {attrlist getvalues [hostdata show $DEFAULT_PROTSEQ:$ip -ifname cell_name] -type hostdata/data} new_cell] != 0} {
        _dcp_host_debug "Hostdata show (cell_name if) on $ip failed: $new_cell..."
        _dcp_host_debug "Using supplied value of $cell_name as the cell name"
        set real_cell_name $cell_name
    } else {
        set real_cell_name $new_cell
    }

    set real_cell_name [string range $real_cell_name 5 end]

    set fd [open "/krb5/krb.conf" w]
    puts $fd "$real_cell_name"
    puts $fd "$real_name $sec_host"
    close $fd
}


#
# _dcp_host_start_secval_service
#
# Check for the secval service. Start it if it isn't running.
# 

proc _dcp_host_start_secval_service {cell_name sec_host} {
    global DCE_VAR

    _dcp_host_debug "In start secval service"

    set binding_file "$DCE_VAR/security/sec_clientd.binding"

    _dcp_host_debug "Waiting for $binding_file to be created"
    for {set i 0} {$i < 20} {incr i} {
        if {[file exists $binding_file] == 1} {
            _dcp_host_debug "Found binding file"
            break
        }
        exec sleep 5
    }

    if {$i >= 20} {
        error "secval binding file $binding_file was not created within time limit."
    }

    set fd [open $binding_file]
    set secval_binding [gets $fd]
    close $fd
    _dcp_host_debug "secval_binding is $secval_binding"
    
    if {[catch {secval status {$secval_binding}} msg] == 0} {
        if ($msg == "1") {
            # Service is running
            _dcp_host_debug "secval service is already running"
            return 0;
        }
    }

    # Configure secval service
    _dcp_host_debug "Starting secval service"
    _dcp_host_debug "Trying secval start with binding = $secval_binding"
    if {[catch {secval activate $secval_binding} msg] != 0} {
        _dcp_host_debug "secval start with binding failed: $msg"
        error "Unable to start secval service: $msg"
    }
    _dcp_host_update_rcfile activate_secval
}


#
# _dcp_host_modify_etc_services
#
# Add a line to the /etc/services file for kerberos.
# Returns 0 on success, 1 on failure
# 

proc _dcp_host_modify_etc_services {} {
    
    if {[catch {exec grep "kerberos5" /etc/services} msg] == 0} {
	# Kerberos line already in the file
        _dcp_host_debug "/etc/services has correct kerberos entry."
	return 0
    }

    _dcp_host_debug "Adding required kerberos line to /etc/services"
    if {[file writable "/etc/services"] == 1} {
	set fd [open "/etc/services" a]
	puts $fd "kerberos5\t88/udp\t\tkdc"
	close $fd
	return 0
    }
    return 1
}


#
# _dcp_host_init_ns -- 
#     Do all the gyrations to get the namespace up and running.
#

proc _dcp_host_init_ns {cell_name cds_host dce_hostname} {
    global DCE_DAEMONS

    # Start cdsadv
    _dcp_host_debug "Starting cdsadv"
    if ![_dcp_host_server_running cdsadv] {
        if {[catch {exec $DCE_DAEMONS/cdsadv &} msg] != 0} {
	    error "cdsadv failed to start: $msg"
        }
        _dcp_host_update_rcfile cdsadv
        _dcp_host_debug "Started cdsadv"
    }

    # Spin around a cdscp dump clerk cache until the advertiser is happy. 
    # We may want to do something more intelligent here. cdscache dump 
    # doesn't quite do what we want.
    set done 0
    for { set i 0 } { $i < 15 } { incr i 1 } {
        if {[catch {exec cdscp dump clerk cache | grep $cell_name >/dev/null} msg] == 0} {
            set done 1
            break
        } else {
            _dcp_host_debug "cdscp dump clerk cache failed (try $i): $msg"
            exec sleep 5
        }
    }

    # See if it worked. If not, take a crack at 'cdscache create'
    if {$done != 1} {
        _dcp_host_debug "cdsadv could not find a cdsd, trying 'cdscache create'"
    
        set ip [exec getip $cds_host]

        if {[catch {cdscache create $cds_host -binding $DEFAULT_PROTSEQ:$ip} msg] != 0} {
            error "cdsadv can't find a cdsd, and 'cdscache create' failed: $msg"
        }
    }

    # Try to create the /.:/hosts/<hostname> directory for a while, hopefully
    # CDS will wakeup....
    set done 0
    for { set i 0 } { $i < 15 } { incr i 1 } {
        if {[catch {directory create /.:/$dce_hostname} msg] == 0} {
            set done 1
            break
        } else {
            _dcp_host_debug "directory create failed (try $i): $msg"
            exec sleep 5
        }
    }

    # See if the dri create worked...
    if {$done != 1} {
        error "Could not create /.:/hosts/$dce_hostname"
    }

    _dcp_host_debug "Created '/.:/$dce_hostname'"

    # Synch the /.:/hosts directory
    _dcp_host_debug "Synching '/.:/hosts' directory"

    if {[catch {directory synchronize /.:/hosts} msg] != 0} {
        _dcp_host_debug "dir synch of '/.:/hosts' failed: $msg"
        error "Could not synchronize directory '/.:/hosts': $msg"
    }
}


#
# _dcp_host_create_ns_entries --
#    Create namespace entries
#

proc _dcp_host_create_ns_entries {dce_hostname} {
    global DEFAULT_PROTSEQ

    # Create the objects under $dce_hostname
    if {[catch {object create /.:/$dce_hostname/self \
            -attribute {{CDS_Class RPC_Entry} {CDS_ClassVersion 1.0}}
    object create /.:/$dce_hostname/cds-clerk \
            -attribute {{CDS_Class RPC_Entry} {CDS_ClassVersion 1.0}}
    object create /.:/$dce_hostname/profile \
            -attribute {{CDS_Class RPC_Profile} {CDS_ClassVersion 1.0}}} msg] != 0} {
        error "Unable to create objects under '/.:/$dce_hostname': $msg"
    }

    # Export the clerk DACL manader UUID
    if {[catch {rpcentry export \
            -interface {000cf72e-0688-1acb-97ad-08002b12b8f8 1.0} \
            -b $DEFAULT_PROTSEQ: \
            -o dc8c6fc0-6143-11ca-b4b9-08002b1bb4f5 \
            /.:/$dce_hostname/cds-clerk} msg] != 0} {
        error "Export of clerk DACL manager failed: $msg"
    }

    # Export the endpoint mapper host binding
    if {[catch {rpcentry export \
            -interface {e1af8308-5d1f-11c9-91a4-08002b14a0fa 3.0} \
            -b $DEFAULT_PROTSEQ:[exec getip [exec hostname]]\[135\] \
            /.:/$dce_hostname/self} msg] != 0} {
        error "Export of endpoint mapper binding failed: $msg"
    }


    # Add /.:/cell-profile to /.:/$dce_hostname/profile
    if {[catch {rpcprofile add /.:/$dce_hostname/profile \
            -member /.:/cell-profile -default} msg] != 0} {
        error "Could not add '/.:/cell-profile' to '/.:/$dce_hostname/profile': $msg"
    }
}


#
# _dcp_host_set_ns_acls --
#    Create namespace entries
#

proc _dcp_host_set_ns_acls {dce_hostname} {
    if {[catch {acl modify /.:/$dce_hostname -add user:$dce_hostname/self:rwdtcia
    acl modify /.:/$dce_hostname/self -e -add user:$dce_hostname/self:rwdtc
    acl modify /.:/$dce_hostname/cds-clerk -e -add user:$dce_hostname/self:rwt
    acl modify /.:/$dce_hostname/profile -e -add user:$dce_hostname/self:rwt} msg] != 0} {
        error "Update of ACL's on objects in '/.:/$dce_hostname' failed: $msg".
    }
}


#
# _dcp_host_update_rcfile
#
# Uncomment the startup line for the specified daemon. An optional second 
# argument specifies any options to be added to the line in the rc file.
#

proc _dcp_host_update_rcfile {daemon args} {
    global OS_NAME OS_REV DCE_CONF 
    
    if {[file exists $DCE_CONF] == 0} {
        error "File $DCE_CONF does not exist."
    }

    _dcp_host_debug "Updating $DCE_CONF file for $daemon"

    set ifd [open $DCE_CONF r]
    set pid [exec sh -c {(:)& echo $!}]
    set ofd [open /tmp/host_config.$pid w]

    set got_match 0
    while {![eof $ifd]} {
        set line [gets $ifd]
        set updaemon [string toupper $daemon]
        
        # Look for the correct line (OS specific)
        if {($OS_NAME == "HP-UX") && ($OS_REV >= 10)} {    
            if {[string first $updaemon $line] != 0} {
                puts $ofd $line
                continue
            } else {
                regsub -- "=0" $line "=1" newline
                if {[string length $args] > 0} {
                    set newline "$newline $args"
                }
                puts $ofd $newline
                set got_match 1
            } 
        } else {
            if {([regexp -nocase -- "^#?.*DCELOCAL/bin/$daemon" $line] == 0) && \
                ([regexp -nocase -- "^#?$daemon$" $line] == 0)} {
                puts $ofd $line
                continue
            } else {
                if {[regsub -- "^#" $line "" newline] == 0} {
                    # Line is already uncommented
                    set newline $line
                }
                if {[string length $args] > 0} {
                    set newline "$newline $args"
                }
                puts $ofd $newline
                set got_match 1
            }
        }
    }

    close $ifd
    close $ofd

    if {$got_match == 0} {
        error "File $DCE_CONF is corrupt."
    }

    # Install the new file
    if {[catch {exec cp /tmp/host_config.$pid $DCE_CONF} msg] != 0} {
        error "Unable to install rc file: $msg"
    }
    
    _dcp_host_debug "Succesfully updated $DCE_CONF for $daemon"

    catch {exec rm /tmp/host_config.$pid} msg
    return 0
}


# 
# _dcp_host_server_running --
#     Check to see if the specified server is running. Return 1 if it
# is, 0 if not.
#

proc _dcp_host_server_running {server} {
    
    # This needs to be expanded to include all platforms
    set PS_ARGS "axo pid,comm"

    set os [exec uname -s]

    switch $os {
	OSF1 {
           set PS_ARGS "-eo pid,comm"
        }
	HP-UX {
           set PS_ARGS "-e"
	}

        # add other platforms here

	default {
	   set PS_ARGS "-eo pid,comm""
	}
    }
    if {[catch {exec ps $PS_ARGS | grep -q $server}] != 0} {
	_dcp_host_debug "Did not find server '$server' running."
	return 0
    } else {
	_dcp_host_debug "Found server '$server' running."
	return 1
    }
}

    
#
# _dcp_host_debug
#     Output text passed as an argument to stderr if DEBUG is
# turned on.
#

proc _dcp_host_debug {args} {
    global HOST_DEBUG

    if {$HOST_DEBUG != 0} {
	puts stderr "DEBUG: [lindex [info level [expr [info level] - 1]] 0]:\
                             [string range $args 1 \
                             [expr [string length $args] - 2]]"
    }
}
