/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1996 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
 * src directory for the full copyright text.
 */
/*
 * HISTORY
 * $Log: d20fattr.c,v $
 * Revision 1.1.10.2  1996/02/18  19:38:45  marty
 * 	Update OSF copyright years
 * 	[1996/02/18  18:19:43  marty]
 *
 * Revision 1.1.10.1  1995/12/08  15:11:38  root
 * 	Submit OSF/DCE 1.2.1
 * 	[1995/12/08  14:49:50  root]
 * 
 * Revision 1.1.8.2  1994/03/23  15:02:57  keutel
 * 	March 1994 code drop
 * 	[1994/03/21  16:02:16  keutel]
 * 
 * Revision 1.1.8.1  1994/02/22  15:56:20  marrek
 * 	Code drop for dce1.1.
 * 	[1994/02/08  09:14:23  marrek]
 * 
 * Revision 1.1.6.2  1993/08/10  08:40:00  marrek
 * 	July 1993 code drop.
 * 	[1993/07/30  08:09:17  marrek]
 * 
 * Revision 1.1.4.3  1992/12/31  17:45:17  bbelch
 * 	Embedding copyright notice
 * 	[1992/12/31  12:58:42  bbelch]
 * 
 * Revision 1.1.4.2  1992/11/27  13:39:38  marrek
 * 	November 1992 code drop
 * 	[1992/11/16  14:35:30  marrek]
 * 
 * Revision 1.1.2.3  1992/06/30  20:53:25  melman
 * 	GDS drop of 6/16/92
 * 	[1992/06/30  20:31:56  melman]
 * 
 * Revision 1.1.2.2  1992/06/01  21:30:54  zeliff
 * 	New version of file from GDS drop
 * 	[1992/05/28  19:07:47  zeliff]
 * 
 * $EndLog$
 */
#if !defined(lint) && defined(GDS_RCS_ID)
static char rcsid[] = "@(#)$RCSfile: d20fattr.c,v $ $Revision: 1.1.10.2 $ $Date: 1996/02/18 19:38:45 $";
#endif

/****************************************************************************
*                                                                           *
*         COPYRIGHT  (C)  SIEMENS NIXDORF INFORMATIONSSYSTEME AG 1991       *
*                                ALL RIGHTS RESERVED                        *
*                                                                           *
****************************************************************************/

/*daton	***************************************************************/
/*								      */
/* TYPE         : MODUL                                               */
/*								      */
/* NAME         : d20fattr.c                                          */
/*								      */
/* AUTHOR       : R. Horn, D AP 11                                    */
/* DATE         : 10.05.88                                            */
/*								      */
/* COMPONENT    : DS                                                  */
/*								      */
/* DOC.-NR.     : Directory-Design-Specification                      */
/*			.					      */
/*			.					      */
/*								      */
/* PRD#/VERS.   :                                                     */
/*								      */
/* DESCRIPTION  :                                                     */
/*								      */
/* SYSTEM DEPENDENCIES: COMMON                                        */
/*								      */
/* HISTORY      :                                                     */
/*								      */
/* Vers.Nr. |  Date   |  Updates                       | KZ | CR# FM# */
/*          |         |                                |    |         */
/*datoff **************************************************************/

/*exon ***********************************************************************/
/*                                                                           */
/*  FUNCTION:  ds4_b02_fill_attr ()                                          */
/*                                                                           */
/*  SHORT DESCRIPTION:                                                       */
/*      The function converts one or more attributes, given in a format      */
/*      used by the administration, into the 'queue'- resp. 'list'-format    */
/*      used at the IAPL-interface of the directory system V2. The caller    */
/*      is able to control the way in which the conversion is done by a      */
/*      special parameter.                                                   */
/*                                                                           */
/*  INPUT-PARAMETER:                                                         */
/*      optype      = Operation mode:                                        */
/*                    The operation mode is controlled by a 'bit field'-     */
/*                    mask, where a specific mask can be generated by ORing  */
/*                    the following 'bit field'-values:                      */
/*                    D20_ASTART     = Initialize attribute output queue     */
/*                                     resp. attribute output list.          */
/*                    D20_AINSERT    = Insert given attribute informations   */
/*                                     into attribute output queue resp.     */
/*                                     attribute output list.                */
/*                    D20_ATYPE_ONLY = Insertion should be done on the       */
/*                                     attribute output list (only attribute */
/*                                     types are inserted in the list).      */
/*                    D20_AEND       = Terminate attribute output queue.     */
/*                                                                           */
/*                    Typical function call sequences are:                   */
/*                    *  D20_ASTART | D20_AINSERT | D20_AEND                 */
/*                       (conversion is done by using only one function call)*/
/*                                                                           */
/*                    *  D20_ASTART | D20_AINSERT                            */
/*                       ... D20_AINSERT ...                                 */
/*                       D20_AINSERT | D20_AEND                              */
/*                       (conversion is done by using several function calls)*/
/*                                                                           */
/*      attr_ent    = Pointer to an array containing the informations about  */
/*                    the convertible attributes (attribute type, attribute  */
/*                    value, length of the attribute value).                 */
/*                    Note: An attribute is converted as a recurring attri-  */
/*                    bute, if continuous entries in the array contain the   */
/*                    same attribute type (means, the information of each    */
/*                    of this entries corresponds to one attribute value     */
/*                    of the recurring attribute).                           */
/*                                                                           */
/*      no_attr     = No. of convertible attributes.                         */
/*                                                                           */
/*  OUTPUT-PARAMETER:                                                        */
/*      info        = Converted attribute(s).                                */
/*                                                                           */
/*  RETURN-VALUE:                                                            */
/*                    None                                                   */
/*                                                                           */
/* ------------------------------------------------------------------------- */
/*  AUTHOR: R.Horn                                        DATE: 4.3.88       */
/*exoff **********************************************************************/

#include <gds.h>
#include <stdio.h>

#include <dce/d2dir.h>
#include <gdsext.h>
#include <d2adm.h>
#include <d2info.h>
#include <d2spec_msk.h>
#include <d20proto.h>

/* --------------------   declaration of funktions ------------------------- */

/* -------------------- declaration of global data ------------------------- */

extern Ds_v2_info	info ;	/* common IAPL-interface parameter block */

 D2_a_value       *d20_avptr ;
 Octet_string     d20_valptr ;

 signed32        d20_idx;
 D2_ttxid        array_ttxid[D2_AT_MAX];
 D2_T61_seq      array_t61seq[D2_AT_MAX];
 D2_str          array_str[D2_AT_MAX][D20_MAX_NB_ITEM];
 D2_str_list     array_str_list[D2_AT_MAX][D20_MAX_NB_ITEM];
 D2_faxnumber    array_fax[D2_AT_MAX];
 D2_telex_number array_telex[D2_AT_MAX];

/* ------------------------------------------------------------------------- */

 void ds4_b02_fill_attr (
   signed16     optype,
   Ds_at_entry *attr_ent,
   signed16      no_attr)
{
	static Bool		first_entry ;
	static D2_a_info	*d20_aiptr ;
	static D2_a_type	*d20_typeptr; 
	static D2_a_type        last_type ;
	register signed16       i;
	unsigned16              rep;

	if ((optype & D20_ASTART) == D20_ASTART) {
		d20_idx = -1;
		if ((optype & D20_ATYPE_ONLY) == D20_ATYPE_ONLY) {
			/* initialize attribute type list */
			info.reqinfo.d2_r_no_at = 0 ;
			d20_typeptr = info.reqinfo.d2_r_type_at ;
		} else {
			/* initialize attribute entry queue */
			d20_aiptr = info.attrinfo ;
			d20_avptr = info.avalinfo ;
			d20_valptr = info.avalues ;
			first_entry = TRUE ;
		}
	}
	if ((optype & D20_AINSERT) == D20_AINSERT) 
		{
		if ((optype & D20_ATYPE_ONLY) == D20_ATYPE_ONLY) 
			{
			/* insert information into attribute type list */
			for (i = 0; i < no_attr; i++, attr_ent++) 
				{
				d20_typeptr->d2_type = 
				    attr_ent->attr_id.d2_type;
				d20_typeptr->d2_typ_len = 
				    attr_ent->attr_id.d2_typ_len;
				d20_typeptr++;
				info.reqinfo.d2_r_no_at++ ;
				}
			}
		else 
			{
			/* insert information into attribute entry queue */
			for (i = 0; i < no_attr; i++, attr_ent++) 
				{
				d20_idx++;
				if ((!first_entry) && 
				     (!d20_cmp_objid(&(attr_ent->attr_id),
						 last_type.d2_typ_len+1, 
						 last_type.d2_type))) 
					{
					/* new attribute -> go to next attribute entry */
					d20_aiptr->d2_a_next = d20_aiptr + 1 ;
					d20_aiptr++ ;
					}

				if ((!first_entry) && 
				     (d20_cmp_objid(&(attr_ent->attr_id),
						 last_type.d2_typ_len+1, 
						 last_type.d2_type))) 
					d20_aiptr->d2_a_no_val++ ;
				else 
					{
					/* insert attribute information */
					d20_aiptr->d2_a_type.d2_type =
					    attr_ent->attr_id.d2_type;
					d20_aiptr->d2_a_type.d2_typ_len =
					    attr_ent->attr_id.d2_typ_len;

					last_type.d2_type = 
					    attr_ent->attr_id.d2_type;
					last_type.d2_typ_len = 
					    attr_ent->attr_id.d2_typ_len;

					d20_aiptr->d2_a_no_val = 1 ;
					d20_aiptr->d2_a_val = d20_avptr ;
					first_entry = FALSE ;
					}

				rep = d20_avptr->d2_a_rep = 
					attr_ent->a_val.d2_a_rep;

				if (rep != D2_T61_LIST  && rep != D2_T61_PR_LIST
				    && rep != D2_FAXNR_STX 
				    && rep != D2_TLXNR_STX && 
				    rep != D2_TTXID_STX && rep != D2_GUIDE && 
				    rep != D2_INTEGER && rep != D2_BOOLEAN)
				       d20_avptr->d2_a_v_len = 
					attr_ent->a_val.d2_a_v_len ;
				else
				       d20_avptr->d2_a_v_len = 0;

				d20_copy_val(attr_ent);
				d20_avptr++;
				}
			}	
		}

	if ((optype & (D20_AEND | D20_ATYPE_ONLY)) == D20_AEND) {
		/* terminate attribute entry queue */
		if (first_entry)
			/* mark empty attribute queue */
			d20_aiptr->d2_a_val = (D2_a_value *) NULL ;
		else
			d20_aiptr->d2_a_next = (D2_a_info *) NULL ;
	}
}


 signed32 d20_copy_val(
   Ds_at_entry *attr_ent)
{
D2_ttxid           *ttx_id;
D2_T61_seq         *t61_seq;
D2_str_list	   *str_list_ptr;
D2_faxnumber       *fax;
D2_telex_number    *telex;
D2_str             *str;
D2_str             *str_cp;
signed32            i;

switch ((int) attr_ent->a_val.d2_a_rep) {
    case D2_GUIDE:
		    break;
    case D2_MHS_ORADR_STX:
		    d20_avptr->d2_at_value.d2_or_addr_av = 
			attr_ent->a_val.d2_at_value.d2_or_addr_av;
		    break;
    case D2_MHS_ORNAME_STX:
		    d20_avptr->d2_at_value.d2_or_name_av = 
			attr_ent->a_val.d2_at_value.d2_or_name_av;
		    break;
    case D2_MHS_DLSP_STX:
		    d20_avptr->d2_at_value.d2_dl_s_p_av = 
			attr_ent->a_val.d2_at_value.d2_dl_s_p_av;
		    break;
    case D2_TTXID_STX:
		    d20_avptr->d2_at_value.d2_ttxid_a_v = &array_ttxid[d20_idx];
		    ttx_id = attr_ent->a_val.d2_at_value.d2_ttxid_a_v;
		    str = &ttx_id->d2_terminal;
		    str_cp = &d20_avptr->d2_at_value.d2_ttxid_a_v->d2_terminal;
		    str_cp->d2_value = d20_valptr;
		    d20_copy_hex(str->d2_size, str->d2_value, attr_ent->hex_use);
		    d20_avptr->d2_at_value.d2_ttxid_a_v->d2_terminal.d2_size = str->d2_size;

		    str = &ttx_id->d2_controls;
		    if (str->d2_size != 0)
			{
			str_cp = &d20_avptr->d2_at_value.d2_ttxid_a_v->d2_controls;
			str_cp->d2_value = d20_valptr;
			d20_copy_hex(str->d2_size, str->d2_value, attr_ent->hex_use);
			}
		    d20_avptr->d2_at_value.d2_ttxid_a_v->d2_controls.d2_size = str->d2_size;

		    str = &ttx_id->d2_graphics;
		    if (str->d2_size != 0)
			{
			str_cp = &d20_avptr->d2_at_value.d2_ttxid_a_v->d2_graphics;
			str_cp->d2_value = d20_valptr;
			d20_copy_hex(str->d2_size, str->d2_value, attr_ent->hex_use);
			}
		    d20_avptr->d2_at_value.d2_ttxid_a_v->d2_graphics.d2_size = str->d2_size;

		    str = &ttx_id->d2_miscel;
		    if (str->d2_size != 0)
			{
			str_cp = &d20_avptr->d2_at_value.d2_ttxid_a_v->d2_miscel;
			str_cp->d2_value = d20_valptr;
			d20_copy_hex(str->d2_size, str->d2_value, attr_ent->hex_use);
			}
		    d20_avptr->d2_at_value.d2_ttxid_a_v->d2_miscel.d2_size = str->d2_size;

		    str = &ttx_id->d2_pages;
		    if (str->d2_size != 0)
			{
			str_cp = &d20_avptr->d2_at_value.d2_ttxid_a_v->d2_pages;
			str_cp->d2_value = d20_valptr;
			d20_copy_hex(str->d2_size, str->d2_value, attr_ent->hex_use);
			}
		    d20_avptr->d2_at_value.d2_ttxid_a_v->d2_pages.d2_size = str->d2_size;

		    str = &ttx_id->d2_privates;
		    if (str->d2_size != 0)
			{
			str_cp = &d20_avptr->d2_at_value.d2_ttxid_a_v->d2_privates;
			str_cp->d2_value = d20_valptr;
			d20_copy_hex(str->d2_size, str->d2_value, attr_ent->hex_use);
			}
		    d20_avptr->d2_at_value.d2_ttxid_a_v->d2_privates.d2_size = str->d2_size;
		    break;
    case D2_TLXNR_STX:
		    d20_avptr->d2_at_value.d2_tlxnr_a_v = &array_telex[d20_idx];
		    telex = attr_ent->a_val.d2_at_value.d2_tlxnr_a_v;
		    str = &telex->d2_t_number;
		    str_cp = &d20_avptr->d2_at_value.d2_tlxnr_a_v->d2_t_number;
		    str_cp->d2_value = d20_valptr;
		    d20_copy_hex(str->d2_size, str->d2_value, attr_ent->hex_use);
		    d20_avptr->d2_at_value.d2_tlxnr_a_v->d2_t_number.d2_size = str->d2_size;

		    str = &telex->d2_c_code;
		    str_cp = &d20_avptr->d2_at_value.d2_tlxnr_a_v->d2_c_code;
		    str_cp->d2_value = d20_valptr;
		    d20_copy_hex(str->d2_size, str->d2_value, attr_ent->hex_use);
		    d20_avptr->d2_at_value.d2_tlxnr_a_v->d2_c_code.d2_size = str->d2_size;

		    str = &telex->d2_answer;
		    str_cp = &d20_avptr->d2_at_value.d2_tlxnr_a_v->d2_answer;
		    str_cp->d2_value = d20_valptr;
		    d20_copy_hex(str->d2_size, str->d2_value, attr_ent->hex_use);
		    d20_avptr->d2_at_value.d2_tlxnr_a_v->d2_answer.d2_size = str->d2_size;
		    break;
    case D2_FAXNR_STX:
		    d20_avptr->d2_at_value.d2_faxnr_a_v = &array_fax[d20_idx];
		    fax = attr_ent->a_val.d2_at_value.d2_faxnr_a_v;
		    str = &fax->d2_tel_nr;
		    str_cp = &d20_avptr->d2_at_value.d2_faxnr_a_v->d2_tel_nr;
		    str_cp->d2_value = d20_valptr;
		    d20_copy_hex(str->d2_size, str->d2_value, attr_ent->hex_use);
		    d20_avptr->d2_at_value.d2_faxnr_a_v->d2_tel_nr.d2_size = str->d2_size;

		    d20_avptr->d2_at_value.d2_faxnr_a_v->d2_par_defined = fax->d2_par_defined;
		    if (fax->d2_par_defined == TRUE)
			d20_avptr->d2_at_value.d2_faxnr_a_v->d2_par = fax->d2_par;
		    break;
    case D2_T61_LIST:
		    d20_avptr->d2_at_value.d2_t61lst_a_v = &array_t61seq[d20_idx];
		    t61_seq = attr_ent->a_val.d2_at_value.d2_t61lst_a_v;
		    d20_avptr->d2_at_value.d2_t61lst_a_v->d2_nb_item = t61_seq->d2_nb_item;
		    d20_avptr->d2_at_value.d2_t61lst_a_v->d2_t61_item = array_str[d20_idx];
		    str_cp = d20_avptr->d2_at_value.d2_t61lst_a_v->d2_t61_item;
		    for (i=0; i < t61_seq->d2_nb_item; i++, str_cp++) {
			     str_cp->d2_value = d20_valptr;

			     /* don't change the value of d2_t61_item pointer.*/
			     str = t61_seq->d2_t61_item + i;
			     str_cp->d2_size = str->d2_size;
			     d20_copy_hex(str->d2_size, str->d2_value, attr_ent->hex_use);
		    }
		    break;
    case D2_T61_PR_LIST:
		    d20_avptr->d2_at_value.d2_post_a_v =
						&array_str_list[d20_idx][0];
		    str_list_ptr = attr_ent->a_val.d2_at_value.d2_post_a_v;
		    i = 0;
		    while (str_list_ptr != (D2_str_list *)NULL)
			{
			array_str_list[d20_idx][i].d2_next =
					&array_str_list[d20_idx][i + 1];
			array_str_list[d20_idx][i].d2_rep =str_list_ptr->d2_rep;
			array_str_list[d20_idx][i].d2_str.d2_size = 
						str_list_ptr->d2_str.d2_size;
			array_str_list[d20_idx][i].d2_str.d2_value = d20_valptr;
		        d20_copy_hex(str_list_ptr->d2_str.d2_size, 
		        str_list_ptr->d2_str.d2_value, attr_ent->hex_use);
			i++;
			str_list_ptr = str_list_ptr->d2_next;
			}

		    array_str_list[d20_idx][i - 1].d2_next = 
							(D2_str_list *)NULL;

		    break;
    case D2_ACCL:
    case D2_OCTET:
		    d20_avptr->d2_at_value.d2_oct_a_v = d20_valptr ;
		    d20_copy_hex(attr_ent->a_val.d2_a_v_len,
				 attr_ent->a_val.d2_at_value.d2_oct_a_v,
				 attr_ent->hex_use);
		    break;
    case D2_IA5:
		    d20_avptr->d2_at_value.d2_ia5_a_v = (IA5_string)d20_valptr;
		    d20_copy_hex(attr_ent->a_val.d2_a_v_len,
				 (Octet_string) attr_ent->a_val.d2_at_value.d2_ia5_a_v,
				 attr_ent->hex_use);
		    break;
    case D2_ASN1:
		    d20_avptr->d2_at_value.d2_asn1_a_v =(Asn1_string)d20_valptr;
		    d20_copy_hex(attr_ent->a_val.d2_a_v_len,
				 attr_ent->a_val.d2_at_value.d2_asn1_a_v,
				 attr_ent->hex_use);
		    break;
    case D2_DISTNAME:
		    d20_avptr->d2_at_value.d2_obj_name_a_v = d20_valptr ;
		    d20_copy_hex(attr_ent->a_val.d2_a_v_len,
				 attr_ent->a_val.d2_at_value.d2_obj_name_a_v,
				 attr_ent->hex_use);
		    break;
    case D2_OBJ_IDENT:
		    d20_avptr->d2_at_value.d2_obid_a_v = d20_valptr;
		    d20_copy_hex(attr_ent->a_val.d2_a_v_len,
				 attr_ent->a_val.d2_at_value.d2_obid_a_v,
				 attr_ent->hex_use);
		    break;
    case D2_PSAP_STX:
		    d20_avptr->d2_at_value.d2_psap_a_v = d20_valptr ;
		    d20_copy_hex(attr_ent->a_val.d2_a_v_len,
				 attr_ent->a_val.d2_at_value.d2_psap_a_v,
				 attr_ent->hex_use);
		    break;
    case D2_PRINTABLE:
		    d20_avptr->d2_at_value.d2_prt_a_v =(Print_string)d20_valptr;
		    d20_copy_hex(attr_ent->a_val.d2_a_v_len,
				 (Octet_string) attr_ent->a_val.d2_at_value.d2_prt_a_v,
				 attr_ent->hex_use);
		    break;
    case D2_T61:
		    d20_avptr->d2_at_value.d2_t61_a_v = d20_valptr ;
		    d20_copy_hex(attr_ent->a_val.d2_a_v_len,
				 attr_ent->a_val.d2_at_value.d2_t61_a_v,
				 attr_ent->hex_use);
		    break;
    case D2_NUMERIC:
		    d20_avptr->d2_at_value.d2_num_a_v = 
						(Numeric_string)d20_valptr ;
		    d20_copy_hex(attr_ent->a_val.d2_a_v_len,
				 (Octet_string) attr_ent->a_val.d2_at_value.d2_num_a_v,
				 attr_ent->hex_use);
		    break;
    case D2_TIME:
		    d20_avptr->d2_at_value.d2_utc_a_v = 
						(UTC_time_string)d20_valptr ;
		    d20_copy_hex(attr_ent->a_val.d2_a_v_len,
				 (Octet_string) attr_ent->a_val.d2_at_value.d2_utc_a_v,
				 attr_ent->hex_use);
		    break;
    case D2_INT_LIST:
		    d20_avptr->d2_at_value.d2_intlist_a_v =
						(signed32 *)d20_valptr;
		    d20_copy_hex(attr_ent->a_val.d2_a_v_len,
				 (Octet_string) attr_ent->a_val.d2_at_value.d2_intlist_a_v,
				 attr_ent->hex_use);
		    break;
    case D2_INTEGER:
		    d20_avptr->d2_at_value.d2_int_a_v =
				 attr_ent->a_val.d2_at_value.d2_int_a_v;
		    break;
    case D2_BOOLEAN:
		    d20_avptr->d2_at_value.d2_bool_a_v =
				 attr_ent->a_val.d2_at_value.d2_bool_a_v;
		    break;
    case D2_CERTIFICATE:
		    d20_avptr->d2_at_value.d2_cert_a_v = 
			attr_ent->a_val.d2_at_value.d2_cert_a_v;
		    break;
    case D2_CERT_PAIR:
		    d20_avptr->d2_at_value.d2_ctpair_a_v = 
			attr_ent->a_val.d2_at_value.d2_ctpair_a_v;
		    break;
    case D2_CERT_LIST:
		    d20_avptr->d2_at_value.d2_ctlist_a_v = 
			attr_ent->a_val.d2_at_value.d2_ctlist_a_v;
		    break;
}
}


 signed32 d20_copy_hex(
   unsigned16   len,
   Octet_string val,
   Bool         hex_use)
{

	register Octet_string	p, p1 ;
	register unsigned16     j ;

	/* insert attribute value (in ASCII or Hex-format) */
	if (hex_use) {
		for (p = val; sscanf ((char *)p, "%2x", (int *) d20_valptr) > 0;
		     p += 2, d20_valptr++) ;
	} else {
		for (p = d20_valptr, p1 = val, j = 0; j < len; j++)
			*p++ = *p1++ ;
		d20_valptr += len ;
	}

}

