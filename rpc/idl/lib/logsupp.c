/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1996 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
 * src directory for the full copyright text.
 */
/*
 * HISTORY
 * $Log: logsupp.c,v $
 * Revision 1.1.2.2  1996/03/11  13:25:45  marty
 * 	Update OSF copyright years
 * 	[1996/03/11  13:13:53  marty]
 *
 * Revision 1.1.2.1  1995/12/13  17:24:46  root
 * 	Submit OSF/DCE 1.2.1
 * 
 * 	HP revision /main/dat_xidl2/1  1995/11/17  17:06 UTC  dat
 * 	New file for second XIDL drop for DCE 1.2.1
 * 	[1995/12/13  17:23:53  root]
 * 
 * Revision 1.1.2.1  1995/10/23  01:49:08  bfc
 * 	oct 95 idl drop
 * 	[1995/10/23  01:25:29  bfc]
 * 
 * 	may 95 idl drop
 * 	[1995/10/22  22:58:05  bfc]
 * 
 * $EndLog$
 */
/*
**  NAME:
**
**      logsupp.c
**
**  FACILITY:
**
**      IDL Stub Runtime Support
**
**  ABSTRACT:
**
**      Provides support routines for the RPC event logging facility.  
**      Routines types include: initialization of the facility, remote
**      management of logging, and actual routines to generate events.
**
**  DESIGN:
**
**      This facility is intended to make up, somewhat, for the lack of integration
**      between threads, RPC, and the debuggers.  It is intended to be
**      low-cost, low-risk, while still providing an excellent enhancement to
**      the existing technology.
**
**      The components of this design are as follows:
**
**          1) Addition of the -trace option to the IDL compiler.
**
**              -trace {log_manager | all | errors | calls | context}
**              
**          2) The logsupp.c module of the stub support library (this module).
**
**          3) Modification of the stub support library to log events for
**          context handles and the reporting of errors.
**
**          4) The rpc_ss_lm interface to be built into the runtime to allow
**          remote access to the event log parameters.
**
**          5) The environment variables RPC_LOG_FILE and RPC_EVENTS to control
**          initialization of the facility.
**          
**  DESIGN ISSUES:
**   
**      As it is apparent that debugging even a single RPC call is not straight
**      forward, this facility attempts to address this difficulty by
**      providing support for a low-level debugging tool to aid programmers in
**      understanding the behavior of their RPC-based distributed application.
**
**      There are several important issues that this design attempts to
**      address.  The primary issues and how they are addressed by this design
**      are as follows:
**
**          1) Minimal performance impact when facility is not in use.
**
**              This issue is addressed by generating a limited number events
**              in the runtime library (currently only context handle
**              manipulation and errors).  A single global boolean is checked
**              before doing any processing related to the debugging facility
**              to minimize effort even further.  The balance of events are
**              generated into the stub under control of the -trace option. 
**
**          2) No changes are required of the application to utilize this
**          debugging tool.
**
**              Currently, all control of the facility is through the -trace
**              command options to the IDL compiler, and two environment
**              variables.
**
**          3) Enable merging of event logs generated on multiple host machines.
**
**              The events generated by this facility are done in a fixed
**              format.  Multiple log files may be appended together and
**              processed by the system-provided sort utility to merge them
**              into a single global event log.
**
**          4) Allow remote start/stop/modification of the debugging facility
**          without having to restart the server.
**
**              Under control of the -trace log_manager command option to the
**              IDL compiler, the stub registers the rpc_ss_lm server interface
**              with the runtime which will enable direct access to all event
**              log parameters at runtime from a command utility.
**
**  ENVIRONMENT:
**
**      This facility is controlled via two environtment variables.  Their
**      names, purpose and usage are described below.
**
**
**      RPC_LOG_FILE
**
**          The environment variable RPC_LOG_FILE controls initialization of
**          the event logging facility.  It must be defined to utilze the
**          facility.  RPC_LOG_FILE should be assigned a file name into which
**          events are to be written.  If the specified file does not exist, it
**          is created.  If it exists, it is overwritten.  If RPC_LOG_FILE is
**          defined, but has the value "" then events are generated to the
**          standard terminal output for the process (stdout).
**
**      RPC_EVENTS
**
**          This is an optional variable used to control which events are
**          logged.  The value of RPC_EVENTS is a comma list of event types to
**          be monitored.  The event types that may be in the RPC_EVENTS string
**          are "all", "none", "errors", "context", and "calls".  If RPC_EVENTS
**          is undefined, then all events that have been selected by the -trace
**          option and all of those generated from within the runtime library
**          are written into the log file, if active.
**          
**  FILES USED:
**
**      The event log is a standard text file containing one line per event.
**      The name of the file is inidicated through the environment variable
**      RPC_LOG_FILE.
**      
** INPUT/OUTPUT DATA ELEMENTS:
**
**    Each line entered into the event log describes a particular RPC event.
**    These events are identified by name.  All events have the following
**    fields (although some may be left empty): Event Time, Event Type, Thread
**    ID, Interface and Operation name, and optional Event-specific data field.
**    The time field is first and ordered from most significant first (year)
**    which enable merging of multiple log files via the sort command.
**
**          EventTime:
**
**              Distributed time of event: "1992-01-08:13:58:59.050".
**
**          ThreadId:
**
**              Symbolic, human readable thread identifier including node name,
**              process id, and thread id: "node:78/2".
**
**          InterfaceAndOpName:
**
**              These are the symbolic names from the IDL file "Interface.Operation".
**              
**          EventType:
**
**              The EventType is a string describing the event that occurred
**              (see table below).
**
**          EventData:
**
**              This filed is optionaly filled-in with information which
**              is dependant upon the particular event event.  Some common
**              values are: status codes, error text, string bindings, etc.
**
**    The following table describes each named event generated by this system,
**    any event-specific data presented in the event, and the semantic meaning
**    of the event.
**
**    log_start:
**
**          This event is logging whenever a new log file is created or when
**          event logging is resumed after being suspended due by a user
**          command to managment interface.  The EventData field contains a
**          list of event types being logged.
**
**    log_stop:
**
**          Event logging stopped by management interface.
**
**    log_events:
**
**          Event logging modified by management interface.  The EventData
**          field contains the new set of events being logged.
**          
**    log_file:
**
**          Event logging modified by management interface.  The EventData
**          field contains the new file name for the event log.
**
**    call_start:
**
**          This event is generated in the client stub when the attempting to
**          connect to a server.  The EventData field displays the string
**          binding of the server being contacted.
**
**    rebind:
**
**          This event is generated in the client stub when access to a server
**          fails for an [auto_handle] operation and the client attempts to
**          rebind to next server.
**
**    await_reply:
**
**          This event is generated by the client stub after completing
**          transmission of the input arguments.  It indicates it the
**          client is waiting for the output argments from server.
**    
**    receive:
**
**          This event is generated by the client stub after recieving a reply
**          from the server.  It indicates the start of output argument
**          processing.
**
**    receive_fault:
**
**          The client has recieved a fault indicating a failure on the server.
**          The EventData field contains the RPC status representing the fault.
**          All faults are mapped into one of the fault codes in
**          dce/ncastat.idl.  If the failure is cannot be mapped one of the
**          faults in dce/ncastat.idl, the server event log can be examined
**          for a more precise description of the fault.
**    
**    call_failure:
**
**          A client stub is terminating abnormally either via an exception or
**          failing status.  The EventData field contains the error text
**          associated with the exception of status code.
**    
**    call_end:
**
**          A client call is complete and the client stub is returning to
**          caller.
**
**    activate:
**
**          The server stub has been entered and input arguments are about to
**          be processed.  The EventData field contains the string binding of
**          the client making the call.
**
**    manager_call:
**
**          This event is generated by the server stub immediately before
**          calling the application manager routine.
**    
**    manager_return:
**
**          This event is generated by the server stub immediately after
**          control has returned from the application manager routine.
**    
**    exception:
**
**          An exception has been detected in the server stub.  This will cause
**          the call to terminate.  The EventData field contains a text
**          description of the exception.
**    
**    status_fail:
**
**          A failure status was encountered in the server stub.  The EventData
**          field describes the failure.
**    
**    transmit_fault:
**
**          This event is generated in the server runtime.  It indicates that 
**          fault information is being sent to the client.  The EventData field
**          indicates the name of the fault which is being sent.  The fault
**          information in this field may be less descriptive than the actual
**          error information which should occur earlier in the log.
**    
**    terminate:
**
**          The server thread has completed processing of the call and is
**          terminating.
**
**    context_created:
**
**          This event describes a new context handle on a server returned from
**          the application manager routine.  The EventData field contains the
**          application value of the context handle, and the UUID assigned to
**          represent this context handle.
**
**    context_deleted:
**
**          This event indicates a context handle on a server that has been
**          deleted by the application manager routine (by returning NULL).
**          The EventData field contains the application value of the context
**          handle, and the UUID assigned to represent this context handle.
**
**    context_modified:
**
**          This event describes that a context handle on a server returned
**          from the application manager routine with a different value than it
**          previously had.  The EventData field contains the application value
**          of the context handle, and the UUID assigned to represent this
**          context handle
**
**    context_rundown:
**
**          This event indicate that a context handle on a server is being
**          freed by invoking the context rundown procedure.  The EventData
**          field contains the application value of the context handle, and the
**          UUID assigned to represent this context handle.
**
**    client_ctx_created:
**
**          This event indicates that a client has allocated a  context on a
**          particular server.  The EventData field of this event contains the
**          address representing the context handle in the client address space
**          (an opaque pointer), the UUID which can be used to identify the
**          corresponding context handle on the server, and the string binding
**          on the server on which the actual context resides.
**
**    client_ctx_deleted:
**
**          This event indicates that the client representation of a context
**          handle is being deleted to reflect the deletion of the context
**          handle on the server.  The EventData field of this event contains
**          the address representing the context handle in the client address
**          space (an opaque pointer), the UUID which can be used to identify
**          the corresponding context handle on the server, and the string
**          binding on the server on which the actual context resides.
**
**    client_ctx_destroyed:
**
**          This event indicates that a client has destroyed the client
**          representation of a context handle via the
**          rpc_ss_destroy_client_context routine.  The EventData field of this
**          event contains the address representing the context handle in the
**          client address space (an opaque pointer), the UUID which can be
**          used to identify the corresponding context handle on the server,
**          and the string binding on the server on which the actual context
**          resides.
**
**    internal_error:
**
**          The support routines managing the event log has encountered an
**          unexpected error.  The EventData field should describe the cause
**          of the event.  If the error does not appear to be indicative of an
**          transient network problem or an environmental failure, it should be
**          reported via a Software Performance Report (SPR).
**--
*/

#define LOGSUPP_C
/* The ordering of the following 3 includes should NOT be changed! */
#include <dce/rpc.h>
#include <dce/stubbase.h>
#include <lsysdep.h>


#include <dce/dce_error.h>  /* DCE error text interface */

#ifndef _KERNEL
#include <time.h>       /* Time manipulation and formatting routines */
#else /* _KERNEL */
#include <kern/time.h>
#endif /* _KERNEL */

#include <rpc_ss_lm.h>  /* Remote log manager interface */
#include <errno.h>      /* Access to error information */
#include <string.h>     /* String manipulation interface */
#include <ctype.h>	/* Character manipulation */

/*
** For all platforms but VMS, enable use of UTC for timestamps.
*/
#ifndef _MSDOS
#define UTC
#include <dce/utc.h>
#endif 

#include <stdlib.h> /* Memory management & environment */
#include <stdio.h>  /* File I/O and formatting routines */

/* Hostname & process id routines */
#ifdef VMS
#   include <types.h>
#   include <descrip.h>
#   include <starlet.h>
#   include <unixlib.h>
#elif _MSDOS
#   include <process.h>	       /* getpid() */
#   include <windows.h>
#   define getpid _getpid
#   define fileno _fileno
#   undef  pthread_getunique_np
#   define pthread_getunique_np(self) GetCurrentThreadId()
#   define fsync(fileno) /* Nothing */
#   define gethostname(string,size) (!GetComputerName(string,&size))
#   undef rpc_if_rep_t
#   define rpc_if_rep_t		RPC_CLIENT_INTERFACE
#else
#   include <sys/time.h>       /* Time manipulation and formatting routines */
#   include <sys/types.h>
#endif

/*
** Defintions that control event log facility.
*/
static FILE *rpc_ss_g_log_file = NULL;    /* File into which event are to   */
                                          /* be logged                      */

static idl_ulong_int
    rpc_ss_g_events_to_log = rpc_ss_m_event_all; /* Mask of event types to  */
                                                 /* be written into log     */
                                                 /* file (default = all)    */

static idl_boolean
    rpc_ss_g_lm_initialized = idl_false;   /* Set to true if log managers   */
                                           /* has been initialized and is   */
                                           /* active in the process.        */

static RPC_SS_THREADS_ONCE_T
    lm_once = RPC_SS_THREADS_ONCE_INIT; /* Once block to do log manager     */
                                        /* initialization                   */

static RPC_SS_THREADS_MUTEX_T lm_mutex; /* Mutex created to synchronize     */
                                        /* access to log manager data       */
                                        /* strutures                        */

static idl_char rpc_ss_log_file_name[rpc_ss_c_lm_string_max] = "";
                                        /* Name of currently open log file  */

/*
** Global flag to control event generation
** Global used by stubs and runtime to determine if events should be logged.
*/
#if (defined(VAX) || defined(__vax)) && (defined(VMS) || defined(__VMS))
#if defined(VAXC) && !defined(__DECC)
globaldef {"RPC_SS_G_LOG_ENABLED"} idl_boolean rpc_ss_g_log_enabled = idl_false;
#else
#pragma extern_model save
#pragma extern_model strict_refdef "RPC_SS_G_LOG_ENABLED"
extern idl_boolean rpc_ss_g_log_enabled = idl_false;
#pragma extern_model restore
#endif
#else
globaldef idl_boolean rpc_ss_g_log_enabled = idl_false;
#endif

/*
** STRNCPY(dest,src,size) -- Copies a string up to the specified
** size, making sure the result is NULL terminated.
*/
#define STRNCPY(dest,src,size) {strncpy((char*)dest,(char*)src,size);dest[size-1]='\0';}





/*
** rpc_ss_parse_events
**
** FUNCTIONAL DESCRIPTION:
** 
**      Routine to parse and event string and set the rpc_ss_g_events_to_log
**      variable as specified.
**      
**  PARAMETERS:
**   
**      event_string:
**      
**          [in] String containing comma list of events to have their
**          assoicated set of events set to be logged.
**
** IMPLICIT OUTPUT PARAMETERS:
** 
**      rpc_ss_g_events_to_log: 
**
**          Set corresponding to values indicated by input event_string if
**          event_string contains any valid options.
**
*/
static void rpc_ss_parse_events
#ifdef IDL_PROTOTYPES
(
    char *event_string
)
#else
(event_string)
    char *event_string;
#endif
{
    idl_ulong_int new_event_mask = 0;   /* Mask for new events */
    idl_boolean parse_ok = idl_false;   /* If false, event_string was       */
                                        /* invalid                          */
    char *cp;				/* Used to validate all is not	    */
					/* call, and lowercase command	    */

/* Lowercase the event string */
    for (cp = event_string; *cp != '\0'; cp++)
	if (isalpha(*cp)) *cp = tolower(*cp);

    /* keyword calls */
    if (strstr(event_string,"calls") != NULL)
    {
        parse_ok = idl_true;    
        new_event_mask |= rpc_ss_m_event_calls;
    }

    /* keyword context */
    if (strstr(event_string,"context") != NULL)
    {
        parse_ok = idl_true;    
        new_event_mask |= rpc_ss_m_event_context;
    }

    /* keyword errors */
    if (strstr(event_string,"errors") != NULL)
    {
        parse_ok = idl_true;    
        new_event_mask |= rpc_ss_m_event_errors;
    }

    /* keyword errors */
    if (strstr(event_string,"misc") != NULL)
    {
        parse_ok = idl_true;    
        new_event_mask |= rpc_ss_m_event_misc;
    }

    /* keyword all */
    if ((cp=strstr(event_string,"all")) != NULL)
    {
        /* Don't confuse c"alls" with all */
        if (strncmp("alls",cp,4) != 0)
        {
            parse_ok = idl_true;        
            new_event_mask |= rpc_ss_m_event_all;
        }
    }

    /* keyword none, clear all events */
    if (strstr(event_string,"none") != NULL)
    {
        parse_ok = idl_true;    
        new_event_mask = 0;
    }

    /* If we found any keywords, set rpc_ss_g_events_to_log */
    if (parse_ok)
        rpc_ss_g_events_to_log = new_event_mask;
}





/*
** rpc_ss_get_events_text
**
** FUNCTIONAL DESCRIPTION:
** 
**      Routine to encode a set of event names into a string.
**      
**  PARAMETERS:
**   
**      events_to_log: 
**
**          [in] Set of events to be indicated in the event_string 
**
**      event_string:
**      
**          [out] String allocated by caller containing comma list of events in
**          text form.
**
*/
static void rpc_ss_get_events_text
#ifdef IDL_PROTOTYPES
(
    idl_ulong_int events_to_log,
    char *event_string
)
#else
(events_to_log, event_string)
    idl_ulong_int events_to_log;
    char *event_string;
#endif
{
    idl_boolean add_comma = idl_false;  /* Indicates a comma should be added before next event type */

    event_string[0] = '\0';

    /* If all events enabled, just output all and return */
    if (events_to_log == rpc_ss_m_event_all)
    {
        strcat(event_string,"all");
        return;
    }

    /* If no events enabled, just output none and return */
    if (events_to_log == rpc_ss_m_event_none)
    {
        strcat(event_string,"none");
        return;
    }

    /* Append errors if enabled */
    if (events_to_log & rpc_ss_m_event_errors)
    {
        if (add_comma) strcat(event_string,", ");
        strcat(event_string, "errors");
        add_comma = idl_true;
    }

    /* Append calls if enabled */
    if (events_to_log & rpc_ss_m_event_calls)
    {
        if (add_comma) strcat(event_string,", ");
        strcat(event_string, "calls");
        add_comma = idl_true;
    }

    /* Append context if enabled */
    if (events_to_log & rpc_ss_m_event_context)
    {
        if (add_comma) strcat(event_string,", ");
        strcat(event_string, "context");
        add_comma = idl_true;
    }

    /* Append misc if enabled */
    if (events_to_log & rpc_ss_m_event_misc)
    {
        if (add_comma) strcat(event_string,", ");
        strcat(event_string, "misc");
        add_comma = idl_true;
    }
}




/*
** rpc_ss_log_event
**
** FUNCTIONAL DESCRIPTION:
** 
**      Base routine to log an event.  Calls to this routine are generated
**      in the stub as controlled by the -trace option and in selective
**      locations in the runtime library.  For efficiency, the calls to
**      this routine should be conditional upon the rpc_ss_g_log_file
**      being non-NULL and the value of rpc_ss_g_events_to_log containing
**      the appropriate mask bit to select the event type.
**
** PARAMETERS:
**
**      event_mask:
**
**          [in] Mask describing type of this event
**      
**      event_name:
**
**          [in] String that identifies the event.
**      
**      interface_and_op_name:
**
**          [in] Optional string that shows the interface and operation name.
**          May be specified as NULL.
**
**      event_data:
**
**          [in] String to be printed in EventData data field of the event
**
** IMPLICIT PARAMETERS:
** 
**      rpc_ss_g_log_file:
**
**          [in] identifies file to recieve event
**          
**      Current Thread ID:
**      Process ID:
**      Hostname:
*/
void rpc_ss_log_event
#ifdef IDL_PROTOTYPES
(
    idl_ulong_int event_mask,
    char *event_name,
    char *interface_and_op_name,    
    char *event_data
)
#else
(event_mask, event_name, interface_and_op_name, event_data)
    idl_ulong_int event_mask;
    char *event_name;
    char *interface_and_op_name;
    char *event_data;
#endif
{
#ifdef UTC
#   define event_time_size     UTC_MAX_STR_LEN
#else
#   define event_time_size     50
#endif
#define event_type_size     20
#define event_thread_size   50
#define operation_size      50
#define host_name_size	    20
    idl_ulong_int   host_name_size_var = host_name_size;
    time_t    integer_time; /* Integer version of current time              */

    struct tm *t;           /* Structure with time split into               */
                            /* year/month/day etc.                          */
    pthread_t self;         /* Current thread handle used to get thread id  */
    char      host_name[host_name_size+1];          /* text hostname        */
    char      event_time[event_time_size+1];        /* text event time      */
    char      event_thread[event_thread_size+1];    /* text thread id       */
    int sec_100ths = 0;

    /* Return if event type is not selected */
    if (!(rpc_ss_g_events_to_log & event_mask) && 
        (event_mask != rpc_ss_m_event_all)) return;

#ifdef UTC
    /* Get current time and format for display */
    if (utc_asclocaltime(event_time,event_time_size,(utc_t*)NULL))
#ifdef VMS
    {   /* VMS failover, for UTC before VMS V6.0 */
        unsigned long vmstime[2];
        unsigned long timelen;
        char timetext[15];
        $DESCRIPTOR(time_desc,timetext);
        sys$gettim(&vmstime);
        sys$asctim(NULL,&time_desc,vmstime,1);
        timetext[11] = '\0';

        /* Get current time and format for display */
        time(&integer_time);
        t = localtime(&integer_time); 

        /* TBS -- Note the timezone information is incorrect in the timestamp below */
        sprintf(event_time,"%04d-%02d-%02d:%s0+00:00Iinf",t->tm_year+1900,
            t->tm_mon+1,t->tm_mday,timetext);
    }
#else
        strcpy(event_time,"n/a");
#endif


#else /* Generate a timestamp for system primitives if UTC not available */
    /* Get current time and format for display */
    time(&integer_time);
    t = localtime(&integer_time); 


#ifdef VMS
    {
        unsigned long vmstime[2];
        unsigned long timelen;
        char timetext[15];
        $DESCRIPTOR(time_desc,timetext);
        sys$gettim(&vmstime);
        sys$asctim(NULL,&time_desc,vmstime,1);
        timetext[11] = '\0';
        /* TBS -- Note the timezone information is incorrect in the timestamp below */
        sprintf(event_time,"%04d-%02d-%02d:%s0-5:00Iinf",t->tm_year+1900,
            t->tm_mon+1,t->tm_mday,timetext);
    }
#elif _MSDOS
    {
        /* TBS -- Note the timezone information is incorrect in the timestamp below */
        sprintf(event_time,"%04d-%02d-%02d:%02d:%02d:%02d.%02d0-5:00Iinf",t->tm_year+1900,
            t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec,
            (0 / 10000) % 100);
    }
#else /* ULTRIX */
    {
        struct timeval tval;
        struct timezone tzone;
        gettimeofday(&tval,&tzone);
        /* TBS -- Note the timezone information is incorrect in the timestamp below */
        sprintf(event_time,"%04d-%02d-%02d:%02d:%02d:%02d.%02d0-5:00Iinf",t->tm_year+1900,
            t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec,
            (tval.tv_usec / 10000) % 100);
    }
#endif
#endif /* UTC */

    /* Get thread Id and format for display */
#ifdef VMS
{
    char *node = getenv("SYS$NODE");
    host_name[0] = '\0';
    if (node != NULL) 
    {
        STRNCPY(host_name,node,host_name_size);
        host_name[strlen(host_name)-2]='\0';
    }
}
#else
    if (gethostname(host_name,host_name_size_var)!= 0) host_name[0] = '\0';
#endif
    self = pthread_self();
    sprintf(event_thread,"%s:%d/%d", host_name, (int)getpid(),
            pthread_getunique_np(&self));

    /* If no event data is specified, change it to "" for printf */
    if (event_data == NULL) event_data = "";

    /* Lock the lm mutex to prevent the log file from being closed */
    RPC_SS_THREADS_MUTEX_LOCK(&lm_mutex);
    
    /* Output the event */
    if (rpc_ss_g_log_file != NULL)
        fprintf(rpc_ss_g_log_file,"%-37s %-19s %-24s %-20s %s\n",
            event_time, event_thread, interface_and_op_name, event_name,
            event_data);

    /* Unlock the lm mutex */
    RPC_SS_THREADS_MUTEX_UNLOCK(&lm_mutex);
}





/*
** rpc_ss_log_event_status
**
** FUNCTIONAL DESCRIPTION:
**
**      Convenience routine to log an event into the event log with an
**      exception in the EventData field.  This routine maps the exception
**      into text, and calls rpc_ss_log_event.  Calls to this routine are
**      generated in the stub as controlled by the -trace option and in
**      selective locations in the runtime library.
**
** PARAMETERS:
**
**      event_mask:
**
**          [in] Mask describing type of this event
**      
**      event_name:
**
**          [in] String that identifies the event.
**
**      interface_and_op_name:
**
**          [in] Optional string that shows the interface
**          and operation name.  May be specified as NULL.
**
**      status_value:
**
**          [in] DCE status to be encoded in EventData field
*/
void rpc_ss_log_event_status
#ifdef IDL_PROTOTYPES
(
    idl_ulong_int event_mask,
    char *event_name,
    char *interface_and_op_name,
    error_status_t status_value
)
#else
(event_mask, event_name, interface_and_op_name, status_value)
    idl_ulong_int event_mask;
    char *event_name;
    char *interface_and_op_name;
    error_status_t status_value;
#endif
{
    char message_text[dce_c_error_string_len];  /* DCE error message text */
    int ist;                /* Status from dce_error_inq_text */

    /* Return if event type is not selected */
    if (!(rpc_ss_g_events_to_log & event_mask) && 
        (event_mask != rpc_ss_m_event_all)) return;

    /* Convert the status value to text */
    dce_error_inq_text(status_value,(unsigned char*)message_text,&ist);

    /* If conversion failed, just print hex value */
    if (ist != error_status_ok)
        sprintf(message_text,"Status 0x%X",status_value);

    /* Log the event */
    rpc_ss_log_event(event_mask, event_name, interface_and_op_name, message_text);
}




/*
** rpc_ss_log_event_exception
**
** FUNCTIONAL DESCRIPTION:
**
**      Convenience routine to log an event into the event log with an
**      exception in the EventData field.  This routine maps the exception
**      into text, and calls rpc_ss_log_event.  Calls to this routine are
**      generated in the stub as controlled by the -trace option and in
**      selective locations in the runtime library.
**
** PARAMETERS:
**
**      event_mask:
**
**          [in] Mask describing type of this event
**      
**      event_name:
**
**          [in] string that identifies the event.
**
**      interface_and_op_name:
**
**          [in] Optional string that shows the interface
**          and operation name.  May be specified as NULL.
**
**      event_exception:
**
**          [in] Exception to be encoded into the EventData field
**          of the event
*/
void rpc_ss_log_event_exception
#ifdef IDL_PROTOTYPES
(
    idl_ulong_int event_mask,
    char *event_name,
    char *interface_and_op_name,
    EXCEPTION *event_exception
)
#else
(event_mask, event_name, interface_and_op_name, event_exception)
    idl_ulong_int event_mask;
    char *event_name;
    char *interface_and_op_name;
    EXCEPTION *event_exception;
#endif
{
    char exception_message[100];    /* Buffer to build message text into */
    error_status_t status_value;    /* Status Values contained in           */
                                    /* exception, if present                */


    /* Return if event type is not selected */
    if (!(rpc_ss_g_events_to_log & event_mask) && 
        (event_mask != rpc_ss_m_event_all)) return;

    /* Attempt to extract the status value from the exception */
    if (exc_get_status(event_exception,&status_value) == 0)
    {
        /* Status obtained, use log event with status routine */
        rpc_ss_log_event_status(event_mask, event_name, interface_and_op_name,
            status_value);
        return;
    }

    /* Must be an address exception, just report address in event log */
    sprintf(exception_message,"Address Exception %08p",(idl_void_p_t)event_exception);
    rpc_ss_log_event(event_mask, event_name, interface_and_op_name, exception_message);
}




/*
** rpc_ss_log_event_binding
**
** FUNCTIONAL DESCRIPTION:
**
**      Convenience routine to log an event into the event log with a
**      binding handle in the EventData field.  This routine maps the
**      exception into text, and calls rpc_ss_log_event.  Calls to this
**      routine are generated in the stub as controlled by the -trace
**      option and in selective locations in the runtime library.
**      
** PARAMETERS:
**
**      event_mask:
**
**          [in] Mask describing type of this event
**      
**      event_name:
**
**          [in] string that identifies the event.
**
**      interface_and_op_name:
**
**          [in] Optional string that shows the interface
**          and operation name.  May be specified as NULL.
**
**      binding:
**
**          [in] Binding handle to be encoded in EventData field
*/
void rpc_ss_log_event_binding
#ifdef IDL_PROTOTYPES
(
    idl_ulong_int event_mask,
    char *event_name,
    char *interface_and_op_name,
    handle_t binding
)
#else
(event_mask, event_name, interface_and_op_name, binding)
    idl_ulong_int event_mask;
    char *event_name;
    char *interface_and_op_name;
    handle_t binding;
#endif
{
    char *string_binding = "";   /* string representation of the binding handle  */
    error_status_t st;      /* runtime status value */

    /* Return if event type is not selected */
    if (!(rpc_ss_g_events_to_log & event_mask) && 
        (event_mask != rpc_ss_m_event_all)) return;

    /* Convert the binding to text */
    rpc_binding_to_string_binding(binding, (idl_char**)&string_binding, &st);

    /* Log the event */
    rpc_ss_log_event(event_mask, event_name, interface_and_op_name, string_binding);

    /* 
    ** Free the allocated string. Since the binding came from the user, don't
    ** log an internal error event if it failed.
    */
    if (st == error_status_ok)
    {
        rpc_string_free((idl_char**)&string_binding, &st);
        if (st != error_status_ok)
            rpc_ss_log_event_status(rpc_ss_m_event_all,"internal_error","",st);
    }
}




/*
** rpc_ss_log_event_ctx
**
** FUNCTIONAL DESCRIPTION:
**
**      Convenience routine to log an event into the event log with 
**      context handle info in the EventData field.  This routine maps the
**      context into text, and calls rpc_ss_log_event.  Calls to this
**      routine are generated in the stub as controlled by the -trace
**      option and in selective locations in the runtime library.
**      
** PARAMETERS:
**
**      event_name:
**
**          [in] String that identifies the event.
**
**      binding:
**
**          [in] Optional Binding handle of server 
**
**      ctx_uuid:
**
**          [in] UUID generated for this context 
**
**      value:
**
**          [in] Application context handle value
**
*/
void rpc_ss_log_event_ctx
#ifdef IDL_PROTOTYPES
(
    char *event_name,
    handle_t binding,
    uuid_t  *ctx_uuid,
    rpc_ss_context_t value
)
#else
(event_name, binding, ctx_uuid, value)
    char *event_name;
    handle_t binding;
    uuid_t  *ctx_uuid;
    rpc_ss_context_t value;
#endif
{
    char *rpc_string;       /* RPC string representation of the binding handle  */
    char *string_binding;   /* string to use in for print */
    char *uuid_string;      /* string representation of the UUID */
    char *buffer;           /* Dynamic buffer to build EventData field */
    error_status_t st;      /* runtime status value */

    /* Return if event type is not selected */
    if (!(rpc_ss_g_events_to_log & rpc_ss_m_event_context)) return;

    /* Convert the binding to text, if available */
    string_binding = "";
    rpc_string = NULL;
    if (binding != NULL)
    {
        rpc_binding_to_string_binding(binding, (idl_char**)&rpc_string, &st);
        string_binding = rpc_string;
        if (st != error_status_ok) 
        {
            rpc_ss_log_event_status(rpc_ss_m_event_all,"internal_error",event_name,st);
            return;
        }
    }
    
    /* Convert the uuid to text */
    uuid_to_string((uuid_p_t)ctx_uuid, (idl_char**)&uuid_string, &st);
    if (st != error_status_ok) 
    {
        rpc_ss_log_event_status(rpc_ss_m_event_all,"internal_error",event_name,st);
        return;
    }

    /* 
    ** Concat all info together into a buffer (the 50 is a fudge factor to handle
    ** the address representation and puncuation in the sprintf call below).
    */
    buffer = (char*)malloc(strlen(uuid_string)+strlen(string_binding)+50);
    if (buffer == NULL) RAISE(rpc_x_no_memory);
    sprintf(buffer,"%08p(%s) %s",value,uuid_string,string_binding);

    /* Log the event */
    rpc_ss_log_event(rpc_ss_m_event_context, event_name, "", buffer);

    /* Free the string binding, uuid, and buffer */
    if (rpc_string != NULL)
    {
        rpc_string_free((idl_char**)&rpc_string, &st);
        if (st != error_status_ok) 
            rpc_ss_log_event_status(rpc_ss_m_event_all,"internal_error",event_name,st);
    }
    rpc_string_free((idl_char**)&uuid_string, &st);
    if (st != error_status_ok) 
        rpc_ss_log_event_status(rpc_ss_m_event_all,"internal_error",event_name,st);
    free(buffer);
}




/*
** rpc_ss_log_event_fault
** 
** FUNCTIONAL DESCRIPTION:
**
**      Convenience routine to log an event into the event log with a
**      fault name in the EventData field.  This routine maps the
**      exception into text, and calls rpc_ss_log_event.  Calls to this
**      routine are generated in the stub as controlled by the -trace
**      option and in selective locations in the runtime library.
**      
** PARAMETERS:
**
**      event_mask:
**
**          [in] Mask describing type of this event
**      
**      event_name:
**
**          [in] string that identifies the event.
**
**      interface_and_op_name:
**
**          [in] Optional string that shows the interface
**          and operation name.  May be specified as NULL.
**
**      fault_code:
**
**          [in] NCA Fault to be encoded in EventData field
*/
void rpc_ss_log_event_fault
#ifdef IDL_PROTOTYPES
(
    idl_ulong_int event_mask,
    char *event_name,
    char *interface_and_op_name,
    error_status_t fault_code
)
#else
(event_mask, event_name, interface_and_op_name, fault_code)
    idl_ulong_int event_mask;
    char *event_name;
    char *interface_and_op_name;
    error_status_t fault_code;
#endif
{
    char *fault_name; /* Text representation of the fault constant */

    /* Return if event type is not selected */
    if (!(rpc_ss_g_events_to_log & event_mask) && 
        (event_mask != rpc_ss_m_event_all)) return;

    /* Map fault into text */
    switch(fault_code)
    {
        case nca_s_fault_addr_error:
            fault_name = "rpc_s_fault_addr_error"; break;
        case nca_s_fault_context_mismatch:
            fault_name = "rpc_s_fault_context_mismatch"; break;
        case nca_s_fault_cancel:
            fault_name = "rpc_s_call_cancelled"; break;
        case nca_s_fault_fp_div_zero:
            fault_name = "rpc_s_fault_fp_div_by_zero"; break;
        case nca_s_fault_fp_error:
            fault_name = "rpc_s_fault_fp_error"; break;
        case nca_s_fault_fp_overflow:
            fault_name = "rpc_s_fault_fp_overflow"; break;
        case nca_s_fault_fp_underflow:
            fault_name = "rpc_s_fault_fp_underflow"; break;
        case nca_s_fault_ill_inst:
            fault_name = "rpc_s_fault_ill_inst"; break;
        case nca_s_fault_int_div_by_zero:
            fault_name = "rpc_s_fault_int_div_by_zero"; break;
        case nca_s_fault_int_overflow:
            fault_name = "rpc_s_fault_int_overflow"; break;
        case nca_s_fault_invalid_bound:
            fault_name = "rpc_s_fault_invalid_bound"; break;
        case nca_s_fault_invalid_tag:
            fault_name = "rpc_s_fault_invalid_tag"; break;
        case nca_s_fault_pipe_closed:
            fault_name = "rpc_s_fault_pipe_closed"; break;
        case nca_s_fault_pipe_comm_error:
            fault_name = "rpc_s_fault_pipe_comm_error"; break;
        case nca_s_fault_pipe_discipline:
            fault_name = "rpc_s_fault_pipe_discipline"; break;
        case nca_s_fault_pipe_empty:
            fault_name = "rpc_s_fault_pipe_empty"; break;
        case nca_s_fault_pipe_memory:
            fault_name = "rpc_s_fault_pipe_memory"; break;
        case nca_s_fault_pipe_order:
            fault_name = "rpc_s_fault_pipe_order"; break;
        case nca_s_fault_remote_comm_failure:
            fault_name = "rpc_s_fault_remote_comm_failure"; break;
        case nca_s_fault_remote_no_memory:
            fault_name = "rpc_s_fault_remote_no_memory"; break;
	case nca_s_fault_user_defined:
            fault_name = "rpc_s_fault_user_defined"; break;
        case nca_s_fault_object_not_found:
            fault_name = "rpc_s_object_not_found"; break;
        default:
            fault_name = "rpc_s_fault_unspec"; break;
    }

    /* Log the event */
    rpc_ss_log_event(event_mask, event_name, interface_and_op_name, fault_name);
}




/*
** rpc_ss_init_lm_once
**
** FUNCTIONAL DESCRIPTION:
** 
**      Routine executed only once via the threads once mechanism. This routine
**      sets up a mutex to control access to the log manager data structures.
**
** IMPLICIT OUTPUT PARAMETERS:
** 
**      rpc_ss_g_log_file:
**
**          The environment variable RPC_LOG_FILE is evaluated.  The associated
**          file name is opened using fopen and the FILE* of the file is set
**          into rpc_ss_g_log_file.  If RPC_LOG_FILE is defined, but has the
**          value "" then stdout is assigned to rpc_ss_g_log_file.
**
**      rpc_ss_g_events_to_log:
** 
**          The environment variable RPC_EVENTS is evaluated.  If defined, the
**          value is parsed and the appropriate fields in
**          rpc_ss_g_events_to_log are set.
**
**      lm_mutex: 
**
**          mutex created by this routine and used to synchronize
**          access to the data structures of the log manager.
**
*/
static void rpc_ss_init_lm_once
(
#ifdef IDL_PROTOTYPES
    void
#endif
)
{
#ifdef VMS
#define LOGFILE_OPTIONS ,"ctx=rec","rfm=stmlf","shr=get"
#else
#define LOGFILE_OPTIONS
#endif
    char *log_file_name;    /* Name to use when opening log file */
    char *event_string;     /* String representing events to log */

    /* Create the log manager mutex */
    RPC_SS_THREADS_MUTEX_CREATE(&lm_mutex);

    /* Get the log file name from RPC_LOG_FILE, if present */
    log_file_name = getenv("RPC_LOG_FILE");
    if (log_file_name == NULL) return;

    /* If log file name was "", then use stdout */
    if (*log_file_name == '\0' || *log_file_name == ' ')
    {
        rpc_ss_g_log_file = stdout;
        rpc_ss_log_file_name[0] = '\0';
    }
    else
    {
        rpc_ss_g_log_file = fopen(log_file_name,"w" LOGFILE_OPTIONS);
        if (rpc_ss_g_log_file == NULL)
        {
            fprintf(stderr,"RPC Log Manager: Unable to open file \"%s\"\n",log_file_name);
            fprintf(stderr,"    %s\n",strerror(errno));
        }
        else STRNCPY(rpc_ss_log_file_name,log_file_name,rpc_ss_c_lm_string_max);
    }
    
    /* Get the event list from RPC_EVENTS, if present */
    event_string = getenv("RPC_EVENTS");
    if (event_string != NULL) rpc_ss_parse_events(event_string);

    /* Enable logging, if log file open */
    if (rpc_ss_g_log_file != NULL) 
        rpc_ss_g_log_enabled = idl_true;
}




/*
** rpc_ss_initialize_log_file
**
** FUNCTIONAL DESCRIPTION:
** 
**      Idempotent routine to initialize the event log facility.  If
**      rpc_ss_g_log_file is non-NULL initialization, has already been done
**      and this routine simply returns.  Otherwise, the environment
**      variables (RPC_LOG_FILE and RPC_EVENTS) are checked to
**      initialize the event logging.  If the event logging system is
**      successfully initialized, then the log_start event is entered into
**      the log.
**
** PARAMETERS:
**
**      interface_and_op_name:
**
**          [in] Optional string that shows the interface and operation name.  May
**          be specified as NULL.
**
** IMPLICIT PARAMETERS:
** 
**      rpc_ss_g_log_enabled:
**
**          [in,out] Used for quick initialized check without invoking once
**          block.  If idl_true then already initialized.
**          
**      rpc_ss_g_events_to_log:
** 
**          [in,out] If rpc_ss_g_log_file was NULL on routine entry, then
**          RPC_EVENTS is evaluated.  If defined, the value is parsed and the
**          appropriate fields in rpc_ss_g_events_to_log are set.
**
*/
void rpc_ss_initialize_log_file
#ifdef IDL_PROTOTYPES
(
    char *interface_and_op_name
)
#else
(interface_and_op_name)
    char *interface_and_op_name;
#endif
{
    char events[rpc_ss_c_lm_string_max]; /* text listing events that are enabled */

    /* Fast path to return if already initialized */
    if (rpc_ss_g_log_enabled) return;

    /* Do lm once initialization */
    RPC_SS_THREADS_INIT;
    RPC_SS_THREADS_ONCE(&lm_once, rpc_ss_init_lm_once);

    /* If logging didn't get enabled, don't do anything else */
    if (!rpc_ss_g_log_enabled) return;

    /* Create text describing enabled event types */
    rpc_ss_get_events_text(rpc_ss_g_events_to_log, events);

    /* Log an event showing start of logging */
    rpc_ss_log_event(rpc_ss_m_event_all,"log_start",interface_and_op_name,events);
}




/*
** rpc_ss_lm_listener_thread
**
** FUNCTIONAL DESCRIPTION:
**
**      This routine is the start of a new thread.  It is invoked if the
**      current process is not yet listening.  This allows the log manager
**      to listen for call from a client, for example.
**          
*/
idl_void_p_t rpc_ss_lm_listener_thread
#ifdef IDL_PROTOTYPES
(
    idl_void_p_t dummy
)
#else
(dummy)
    idl_void_p_t dummy;
#endif
{
    error_status_t          st;         /* RPC runtime status               */

    /* Listen for Log Manager requests */
    rpc_server_listen(1,&st);

    /* Report Error in log */
    if (st != error_status_ok)
        rpc_ss_log_event_status(rpc_ss_m_event_all,"internal_error","RPC Log Manager",st);

    return 0;
}




/*
** rpc_ss_init_log_manager
**
** FUNCTIONAL DESCRIPTION:
**
**      This routine call is generated into a stub if the -event log_manager
**      option is specified during the idl compile. If
**      rpc_ss_g_log_manager_initialized is idl_true, then no action is
**      necessary.  Otherwise, the rpc_ss_log_manager interface is initialized.
**
**      On the client-side, it will need to spawn a thread to invoke
**      rpc_server_listen.  On the server-side, this is not necessary as there
**      already must already be a listener thread.
**
** INPUT PARAMETERS:
** 
**      interface_and_op_name:
**         
**          Optional string that shows the interface and operation name.  May
**          be specified as NULL.
**
**      is_client:
**
**          If true, called from client stub and thus needs to spawn an
**          rpc_server_listen thread.
**
**      ifspec:
**
**          The interface handle for the calling interface.  This is presumably
**          used to identify the server in some way for selection by management
**          calls.
**          
** IMPLICIT PARAMETERS:
** 
**      rpc_ss_g_log_manager_initialized:
**
**          [in,out] If rpc_ss_g_log_manager_initialized is idl_true, then the
**          routine simply returns.  Otherwise, the necessary initialization is
**          performed, and rpc_ss_g_log_manager_initialized is set to idl_true.
**
**      rpc_ss_g_log_enabled:
**
**          [in] If rpc_ss_g_log_enabled is false, then this routine will do
**          nothing but return.
**          
**      lm_mutex:
**
**          [in] Prevent more than one log manager from being started.
*/
void rpc_ss_init_log_manager 
#ifdef IDL_PROTOTYPES
(
        char *interface_and_op_name,
        idl_boolean is_client,
        rpc_if_handle_t ifspec
)
#else
(interface_and_op_name,is_client,ifspec)
        char *interface_and_op_name;
        idl_boolean is_client;
        rpc_if_handle_t ifspec;
#endif
{
    idl_ulong_int           i;
    pthread_t               listener;   /* listener thread created by this  */
                                        /* routine                          */
    
    rpc_binding_vector_p_t  bindings;   /* Binding vector on which this     */
                                        /* process is listening             */

    uuid_t                  *p_uuid;    /* Type UUID to identify this lm    */
                                        /* instance                         */

    error_status_t          st;         /* RPC runtime status               */


    /* If not logging, just return */
    if (!rpc_ss_g_log_enabled) return;

    /* If already initialized, just return */
    if (rpc_ss_g_lm_initialized) return;

    /* Lock the lm mutex to prevent the log file from being closed */
    RPC_SS_THREADS_MUTEX_LOCK(&lm_mutex);
    
    /* Initialized only if not done yet */
    if (!rpc_ss_g_lm_initialized)
    {
        /*
        ** Indicate that we are done and unlock the mutext to save others from
        ** waiting as the log manager interface is only acessed remotely.
        */
        rpc_ss_g_lm_initialized = idl_true;
        RPC_SS_THREADS_MUTEX_UNLOCK(&lm_mutex);

        /*
        ** Determine which bindings are being listened on.       
        */
        rpc_server_inq_bindings(&bindings,&st);

        /*
        ** If there are none, spawn a listener thread.
        */
        if (st == rpc_s_no_bindings)
        {
            /*
            ** Listen on all available protocol sequences
            */
            rpc_server_use_all_protseqs(1,&st);
            if (st != error_status_ok)
            {
                rpc_ss_log_event_status(rpc_ss_m_event_all,"internal_error","RPC Log Manager",st);
                return;
            }
            
            /*
            ** Determine which bindings are being listened on.       
            */
            rpc_server_inq_bindings(&bindings,&st);
            if (st != error_status_ok)
            {
                rpc_ss_log_event_status(rpc_ss_m_event_all,"internal_error","RPC Log Manager",st);
                return;
            }

            /* Create the thread to listen for log manager requests */
            pthread_create(&listener,pthread_attr_default,rpc_ss_lm_listener_thread,NULL);
        }
        else if (st != error_status_ok)
        {
            rpc_ss_log_event_status(rpc_ss_m_event_all,"internal_error","RPC Log Manager",st);
            return;
        }
                
        /* 
        ** Register rpc_ss_lm interface with runtime.  If available, use the
        ** UUID of the calling interface to aid in identification of this log
        ** manager instance.
        */
        p_uuid = NULL;
        if (ifspec != NULL) p_uuid = &(((rpc_if_rep_t*)ifspec)->id);
        rpc_server_register_if(rpc_ss_lm_v0_1_s_ifspec, 
            NULL /*p_uuid*/, (rpc_mgr_epv_t)NULL, &st);

        /* Report Error in log */
        if (st != error_status_ok)
        {
            rpc_ss_log_event_status(rpc_ss_m_event_all,"internal_error","RPC Log Manager",st);
            rpc_binding_vector_free(&bindings,&st);
            return;
        }

        /*
        ** Loop over bindings, listing them in the log file.
        */
        for (i = 0; i < bindings->count; i++)
            rpc_ss_log_event_binding(rpc_ss_m_event_all,"listening","RPC Log Manager",bindings->binding_h[i]);

        /* flush output so that it is immediately visible */
        RPC_SS_THREADS_MUTEX_LOCK(&lm_mutex);
        fflush(rpc_ss_g_log_file);
	i = fileno(rpc_ss_g_log_file);
	fsync(i);
        RPC_SS_THREADS_MUTEX_UNLOCK(&lm_mutex);

        /* Free the binding vector */
        rpc_binding_vector_free(&bindings,&st);
        if (st != error_status_ok)
        {
            rpc_ss_log_event_status(rpc_ss_m_event_all,"internal_error","RPC Log Manager",st);
            return;
        }
    }
    else
        RPC_SS_THREADS_MUTEX_UNLOCK(&lm_mutex);
}





/*
**  rpc_ss_modify_log
**
**  FUNCTIONAL DESCRIPTION:
**
**      This is the manager routine which supports remote acess to log manager.
**
**  FORMAL PARAMETERS:
**
**      lm_handle:
**
**          Currently unused server binding handle
**
**      change_file:
**
**          If true, then existing log file is closed and the log_file_name
**          parameter is used as the new file.
**
**      log_file_name:
**
**          [in,out] String to be used and new log file name and/or the name
**          of the currently open log file.
**          
**      change_events:
**
**          If true, then rpc_ss_g_events_to_log is modified to the value
**          supplied in the event_flags parameter.
**
**      event_flags:
**
**          [in,out]  New event types to log and/or recieves current set of
**          events being logged.
**
**  RETURN VALUE:
**
**      rpc_ss_c_lm_error_ok -- Indicates sucessful completion
**      
**      rpc_ss_c_lm_error_string -- Indicates error message argument is set
**      
*/
idl_ulong_int rpc_ss_modify_log
#ifdef IDL_PROTOTYPES
(
      /* [in] */ handle_t lm_handle,
      /* [in] */ idl_boolean change_file,
      /* [in, out] */ idl_char log_file_name[rpc_ss_c_lm_string_max],
      /* [in] */ idl_boolean change_events,
      /* [in,out] */ idl_ulong_int *event_flags,
      /* [out] */ idl_char error_message[rpc_ss_c_lm_string_max],
      /* [dummy] */ error_status_t *dce_st
)
#else
(lm_handle,change_file,log_file_name,change_events,event_flags,error_message,dce_st)
        /* [in] */ handle_t lm_handle;
        /* [in] */ idl_boolean change_file;
        /* [in, out] */ idl_char log_file_name[rpc_ss_c_lm_string_max];
        /* [in] */ idl_boolean change_events;
        /* [in,out] */ idl_ulong_int *event_flags;
        /* [out] */ idl_char error_message[rpc_ss_c_lm_string_max];
        /* [dummy] */ error_status_t *dce_st;
#endif
{
    int fd;	/* File number of log file for use with fsync()		    */

    idl_ulong_int lm_status = rpc_ss_c_lm_error_ok; /* Return status from   */
                                                    /* this routine         */
    error_message[0] = '\0';
    
    /* If specified, change log file */
    if (change_file)
    {
        /* Log final event in previous log file */
        rpc_ss_log_event(rpc_ss_m_event_all,"log_file","RPC Log Manager",(char*)log_file_name);

        /* Lock the log_file variable */
        RPC_SS_THREADS_MUTEX_LOCK(&lm_mutex);

        /* Close previous log file */
        if ((rpc_ss_g_log_file != NULL) && (rpc_ss_g_log_file != stdout))
            fclose(rpc_ss_g_log_file);

        /* If log file name was "", then use stdout */
        if (*log_file_name == '\0')
        {
            /* No name specified, just use stdout */
            rpc_ss_g_log_file = stdout;
            strcpy((char*)rpc_ss_log_file_name,"");
        }
        else
        {
            /* Open specified file */
            rpc_ss_g_log_file = fopen((char*)log_file_name,"w");

            /* If failure, return error message string */
            if (rpc_ss_g_log_file == NULL)
            {
		/* fopen failed, Return the associated error message text to rpclm */
                char *msg = strerror(errno);
                STRNCPY(error_message,msg,rpc_ss_c_lm_string_max);
                lm_status = rpc_ss_c_lm_error_string;

		/* Invalid name specified, fall back to stdout */
		rpc_ss_g_log_file = stdout;
                STRNCPY(rpc_ss_log_file_name,"",rpc_ss_c_lm_string_max);
            }
	    else 
	    {
		/* Save the file name */           
		STRNCPY(rpc_ss_log_file_name,log_file_name,rpc_ss_c_lm_string_max);
	    }
        }

        /* Unlock the log_file variable */
        RPC_SS_THREADS_MUTEX_UNLOCK(&lm_mutex);

        /* Log start event in new log file */
        rpc_ss_log_event(rpc_ss_m_event_all,"log_start","RPC Log Manager",(char*)rpc_ss_log_file_name);
    }

    /* If specified, change events */
    if (change_events)
    {
        char events[rpc_ss_c_lm_string_max]; /* text listing events that are enabled */

        RPC_SS_THREADS_MUTEX_LOCK(&lm_mutex);
        rpc_ss_g_events_to_log = *event_flags;
        RPC_SS_THREADS_MUTEX_UNLOCK(&lm_mutex);

        /* Create text describing enabled event types */
        rpc_ss_get_events_text(rpc_ss_g_events_to_log, events);

        /* Log the new set of events being logged */
        rpc_ss_log_event(rpc_ss_m_event_all,"log_events","RPC Log Manager",events);
    }
    
    /* Return current state to caller */
    RPC_SS_THREADS_MUTEX_LOCK(&lm_mutex);
    STRNCPY(log_file_name,rpc_ss_log_file_name,rpc_ss_c_lm_string_max);
    *event_flags = rpc_ss_g_events_to_log;
    if (rpc_ss_g_log_file != NULL)
    {
	fflush(rpc_ss_g_log_file);
	fd = fileno(rpc_ss_g_log_file);
	fsync(fd);
    }
    RPC_SS_THREADS_MUTEX_UNLOCK(&lm_mutex);
    return lm_status;
}
