%{
#include <sys/types.h>
#include <memory.h>
#include <ctype.h>
#include <stdio.h>
#include <errno.h>
#include <dirent.h>
#include <string.h>

#define ASSERT(expr)    

/* Flags to record token types seen */
#define CLEAN 0x0
#define ID 0x1
#define LPAR 0x2
#define RPAR 0x4
#define INFUN 0x4
#define OUTFUN 0x8
#define CLEAR(ts) (ts) = CLEAN

int debug = 0;
int debug1 = 0;
int stats = 1;
int ncomment = 0;
int nstr = 0;
int nfun = 0;
int nfununtraced = 0;
int ndefine = 0;
int nfunret = 0;
int ndefineret = 0;
int ndirective = 0;

int tkstate;
int brlevel = 0;
int prlevel = 0;

/* Keep track of lex state */
#define LSTACKSIZE 20
int lstack[LSTACKSIZE];         /* lex state stack */
int lsp = 0;                    /* lex state stack SP */
int lstate = INITIAL;               /* current lex state stack */

#define BUFFER_SIZE 1024
/* Track return expr in a macro definition.
 *  dre: Define Return Expression 
 */
#define DRE_BUF_SIZE  BUFFER_SIZE
#define DRE_INIT_BUF (dreBufPos = 0)
char dreBuf[DRE_BUF_SIZE];
int dreBufPos = 0;

/* Store info from which function name can be determined
 * The zeroth position in the buffer is not used and is used as a sentinel.
 */
#define FUN_BUF_SIZE  BUFFER_SIZE
#define FUN_INIT_BUF \
    do { \
  	funBufPtr = funBuf; \
        funBuf[0] = 0; \
    } while (0) 

char funBuf[FUN_BUF_SIZE];
char *funBufPtr = funBuf;
char funName[FUN_BUF_SIZE];
char funType[FUN_BUF_SIZE];
int funId, baseId;

/* Indicates whether to trace current function. Turned on by default for 
 * all functions. 
 */
int traceFun = 1;
int voidFunRetType = 0;

FILE *funcIdFileStream;
char funcIdFileName[BUFFER_SIZE];

char fileWarning[] =
    "/* DO NOT MODIFY THIS FILE. THIS FILE HAS BEEN AUTOMATICALLY \n * GENERATED BY THE TRACE PREPROCESSOR\n */";

#define RPAREN ')'      

/* Forward declarations for aux functions */
void initStk();
void push();
char *genSymLexState();
void processFunEntry();
void processFunExit();
void genFileIncludes();

%}

/* Lex states */
%x S_LPAR S_RPAR S_FUNBODY S_FUN S_STR S_COMMENT S_FUNRET S_DEFINE S_DEFINERET S_DEFINERETCOMMENT S_DIRECTIVE
 
ws          [ \t]
nl          \n
nws         ({ws}|{nl})
digit       [0-9]
letter      [a-zA-Z_]
sep         \;
id          {letter}({letter}|{digit})*

%%
        /* Initialization section */
        CLEAR(tkstate);
        genFileIncludes();   
        
        /* Pattern match section */

<INITIAL,S_FUN,S_DEFINE,S_DIRECTIVE,S_LPAR>\" {
            /* Need to eat up all chars in the string */
            ECHO;
            push(lstate);
            lstate = S_STR;
            BEGIN(lstate);          
        }


<INITIAL,S_DEFINE,S_DIRECTIVE,S_FUN,S_RPAR,S_FUNBODY,S_LPAR>"/*" {
            /* Need to eat up all chars in the comment. Its not necessary to 
             * check for this in S_FUNRET lex state as we do in S_DEFINERET
             * as a return statement inside a function will always have
             * semi-colon marking the statement end and any comments are 
             * before the semi-colon will become part of the return statement
             * which does not do any harm.
             */
            ECHO;
            push(lstate);
            lstate = S_COMMENT;
            BEGIN(lstate);          
        }

<INITIAL,S_FUN>^#define {
            /* Macro declaration */
            ECHO;
            DRE_INIT_BUF;
            push(lstate);
            lstate = S_DEFINE;
            BEGIN(lstate);
        }

^#      {
            /* All other cpp directives */
            ECHO;
            push(lstate);
            lstate = S_DIRECTIVE;
            BEGIN(lstate);
        }

_TAKES[^\;]*\;  {
            ECHO;
            CLEAR(tkstate);
            FUN_INIT_BUF;
        }

RCSID{ws}*\(.*\)    {
            ECHO;
        }

{id} |
\*      {

            ECHO;
            tkstate |= ID;
            /* Store id in anticipation of function declaration */
            if (!(tkstate & LPAR)) { 
		/* yyleng does not include the string terminator \0 char */
                funForm(yytext, yyleng);
            } 
        }

={nws}*[^;]*;   {
            /* An initialization assignment 
             * e.g. int f = a[(j ** 2)]; 
             */
            ECHO;
            CLEAR(tkstate); 
            /* Clear fun buffer */
            FUN_INIT_BUF;
        }

{sep}   {
            ECHO;
            CLEAR(tkstate);
            FUN_INIT_BUF;
        }

\(      {
            ECHO;
            if ((prlevel == 0) && (tkstate & ID)) {
                tkstate |= LPAR;
            }
            prlevel++;
            push(lstate);
            lstate = S_LPAR;
            BEGIN(lstate);
            /* Return from S_LPAR only when found matching right paren */
        }

<S_LPAR>\(  {
                ECHO;
                prlevel++;
        }

<S_LPAR>\)  {
                prlevel--;
                if (prlevel == 0) {
                    unput(RPAREN);
                    if (debug) {    
                        fprintf(stderr,
                                "Lstate S_LPAR, saw end \")\", changing to state S_RPAR\n");
                    }
		    lstate = S_RPAR;
		    BEGIN(lstate);                                      
                } else {
                    ECHO;
                }           
        }

<S_RPAR>\){nws}*{sep} |
<S_RPAR>\){nws}*[^a-zA-Z0-9_;{ \t\n/*]+ |
<S_RPAR>\){nws}*\/[^*] |
<S_RPAR>\){nws}*\*      {
            /* \){nws}*{sep}. 
             *      Seen forward declaration 
             *
             * \){nws}*[^a-zA-Z0-9_;{]+\; - 
             *      Seen a structure member or a global declaration 
             */
            ECHO;
            CLEAR(tkstate); 
            /* Clear fun buffer */
            FUN_INIT_BUF;
	    initStk(); 
            BEGIN(INITIAL);
        }

<S_RPAR>\)      {
            /* Seen function declaration */
            ECHO;   
            if (tkstate & (ID | LPAR)) {
                tkstate |= RPAR;
                push(lstate);
                lstate = S_FUNBODY;
                BEGIN(lstate);
            }
        }

<S_FUNBODY>\{ {
            ASSERT(lstate == S_FUNBODY);
            /* Ahah finally the begining of function body */
            ECHO;
            tkstate |= INFUN;
            funExtractNameAndType();   /* Find function name */
            processFunEntry();
            brlevel = 1;
            /* No need to push S_FUNBODY, just replace it with S_FUN */
            lstate = S_FUN;
            BEGIN(lstate);
        }

<S_FUN>\{   {
            ASSERT(lstate == S_FUN);
            ECHO;
            brlevel++;
        }

<S_FUN>\}   {
            ASSERT(lstate == S_FUN);
            if (brlevel == 1) {
                /* function exit */
                nfun++;
                processFunExit();           
                CLEAR(tkstate);
		/* Turn on function tracing if it was turned off for this
		 * function */
		if (traceFun == 0) traceFun = 1;
            }
            brlevel--;
            ECHO;
            if (brlevel == 0) {
                FUN_INIT_BUF;
                /* Should pop S_RPAR state */
                lstate = pop();
                ASSERT(lstate == S_RPAR);
                if (debug) {
                    fprintf(stderr,
                            "Lstate S_FUN, saw end \"}\", popped state %s\n",
                            genSymLexState(lstate));
                }
		initStk();
                BEGIN(INITIAL);
            }
        }

<S_FUN>[^a-zA-Z0-9_"']return/[^a-zA-Z0-9_]   {
            /* Get return expr from current position to first ; separator */
            fprintf(yyout, "%c", yytext[0]);
            if (traceFun) {			
		push(lstate);
		lstate = S_FUNRET;
		BEGIN(lstate);
	    } else {
		/* Do not trace return statements if tracing is turned off 
		 * for the function. Copy out return to the out stream
		 */
		ECHO;
	    }
        }

<S_FUNRET>[^\;]*/{sep}  {
            /* XXX
             * It may turn out that S_FUNRET lex state is not really    
             * needed. If so then combine actions here with
             * the actions for pattern "return" in S_FUN lex state 
             */
            nfunret++;
            processFunReturn();
            /* Rely on default action for ; to get copied out */
            lstate = pop();
            if (debug) {
                fprintf(stderr,
                        "Lstate S_FUNRET, traced return, popped state %s\n",
                        genSymLexState(lstate));
            }
            BEGIN(lstate);
        }

<S_DEFINE>[^a-zA-Z0-9_]return/[^a-zA-Z0-9_]    {
            /* Get return expr from current position to first of
             *      unescaped newline
             * or
             *      ; separator
             */
			fprintf(yyout, "%c", yytext[0]);
            push(lstate);
            lstate = S_DEFINERET;
            BEGIN(lstate);          
        }

<S_DEFINE,S_DIRECTIVE>\\\n  {
            ECHO;
        }

<S_DIRECTIVE>\n     {
            ndirective++;
            ECHO;
            lstate = pop();
            ASSERT(lstate == INITIAL);
            if (debug) {
                fprintf(stderr,
                        "Lstate S_DIRECTIVE, saw unescaped newline");
                fprintf(stderr, "popped state %s\n", 
                        genSymLexState(lstate));
            }
            CLEAR(tkstate);
            FUN_INIT_BUF;
            BEGIN(lstate);          
        }
    
<S_DEFINE>\n    {
            ndefine++;
            ECHO;
            lstate = pop();
            ASSERT((lstate == INITIAL) || (lstate == S_FUN));
            if (debug) {
                fprintf(stderr,
                        "Lstate S_DEFINE, saw macro end, popped state %s\n",
                        genSymLexState(lstate));
            }
            CLEAR(tkstate);
            FUN_INIT_BUF;
            BEGIN(lstate);          
        }

<S_DEFINERET>"/*"   {
            /* Eat up the comment. do not output it. */
            push(lstate);
            lstate = S_DEFINERETCOMMENT;
            BEGIN(lstate);
        }

<S_DEFINERETCOMMENT>[^*/]*  {
            /* Includes eating up newlines inside comments */
            /* null */
        }

<S_DEFINERETCOMMENT>[^*]\/  {
            /* null */
        }

<S_DEFINERETCOMMENT>\*  {
            /* null */
        }

<S_DEFINERETCOMMENT>"*/"    {
            lstate = pop();
            if (debug) {
                fprintf(stderr,
                        "Lstate S_DEFINERETCOMMENT, saw end \"*/\", popped state %s\n",
                        genSymLexState(lstate));
            }
            BEGIN(lstate);  
        }

<S_DEFINERET>[^/*\\\n\;]*     {
            dreForm(yytext, yyleng);
        }

<S_DEFINERET>\/[^*]     {
            dreForm(yytext, yyleng);
        }

<S_DEFINERET>\*     {
            dreForm(yytext, yyleng);
        }

<S_DEFINERET>\\(.|{nl}) {
            dreForm(yytext, yyleng);
        }

<S_DEFINERET>{sep} {
            /* End of DRE */
            ndefineret++;
            dreProcess(); /* does ECHO too */
            lstate = pop();
            ASSERT(lstate == S_DEFINE);
            if (debug) {
                fprintf(stderr,
                        "Lstate S_DEFINERET, saw end of DRE \"%s\"", 
                        yytext);
                fprintf(stderr, ", popped state %s\n",
                        genSymLexState(lstate));
            }
            BEGIN(lstate);          
        }

<S_DEFINERET>{nl} {
            /* End of DRE. Also put back the newline so that S_DEFINE
             * can end by catching it 
             */
            ndefineret++;
            dreProcess(); /* does ECHO too */
            unput('\n');
            lstate = pop();
            ASSERT(lstate == S_DEFINE);
            if (debug) {
                fprintf(stderr,
                        "Lstate S_DEFINERET, saw end of DRE \"%s\"", 
                        yytext);
                fprintf(stderr, ", popped state %s\n",
                        genSymLexState(lstate));
            }
            BEGIN(lstate);          
        }

%{
/* Rely on default action for eating and actually copying the string over, 
 * except for the following 2 rules.
 */
%}

<S_STR>\\\" {
            /* A \" does not end the string */
            ECHO;
        }

<S_STR>\"   {
            nstr++;
            /* End of string */
            ECHO;
            lstate = pop();
            if (debug) {
                fprintf(stderr,
                        "Lstate S_STR, saw end string quote '\"', popped state %s\n",
                        genSymLexState(lstate));
            }
            BEGIN(lstate);
        }

%{
/* Rely on default action for eating and actually copying the comment over, 
 * except for the following rule.
 */
%}

<S_COMMENT>"*/"     {
            /* End of comment */
            ncomment++;         
            ECHO;
            lstate = pop();
            if (debug) {
                fprintf(stderr,
                        "Lstate S_COMMENT, saw \"*/\", popped state %s\n",
                        genSymLexState(lstate));
            }
            BEGIN(lstate);
        }

<S_COMMENT>{ws}*NOTRACE{ws}*"*/" {
            /* End of NOTRACE directive comment */
            ncomment++;         
	    nfununtraced++;
	    traceFun = 0;
            ECHO;
            lstate = pop();
            if (debug) {
                fprintf(stderr,
                     "Lstate S_COMMENT, saw \"NOTRACE */\", popped state %s\n",
                        genSymLexState(lstate));
            }
            BEGIN(lstate);
        }

%%

/* Auxillary functions section */

void initStk()
{
    lsp = 0;
    lstate = INITIAL;
}	    

void push(int curlstate)
{
    if (lsp > LSTACKSIZE) {
        fprintf(stderr, "Lex state stack overflow, EXITING\n");
        exit(1);
    }
    lstack[lsp++] = curlstate;
}

int pop()
{
    int state;

    if (lsp <= 0) {
        fprintf(stderr, "Lex state stack underflow, EXITING\n");
        exit(1);
    }
    state = lstack[--lsp];
    return state;
}

char *genSymLexState(int lstate)
{
    char *symState;

    switch (lstate) {
      case INITIAL: symState = "INITIAL";
        break;
      case S_RPAR: symState = "S_RPAR";
        break;
      case S_FUNBODY: symState = "S_FUNBODY";
        break;
      case S_FUN: symState = "S_FUN";
        break;
    }
    return symState;
}

int dreForm(char *dreP, int dreLen) 
{
    char tbuf[DRE_BUF_SIZE];
    int tbufLen;
    int i = 0;

    if (dreBufPos + dreLen > DRE_BUF_SIZE) {
        fprintf(stderr, "DRE buffer overflow, exiting\n");
        exit(1);
    }       
    memcpy((char *)(dreBuf + dreBufPos), dreP, dreLen);
    dreBufPos += dreLen;
    return 0;
}

int dreProcess() 
{
    int i;
    int retExpr = 0;

    dreBuf[dreBufPos] = 0;
    for (i = 0; i < dreBufPos; i++) {
	if (!isspace(dreBuf[i]))  {
	    retExpr = 1;
	    break;
	}
    }
    if (retExpr) {
	fprintf(yyout,
		"OSI_CALLTRACE_RETURN_EXPR(TRACE_FUN_ID, TRACE_FUN_NAME, %s)",
		(char *)dreBuf);
    } else {
	fprintf(yyout,
		"OSI_CALLTRACE_RETURN_NOEXPR(TRACE_FUN_ID, TRACE_FUN_NAME)");
    }	
    ECHO; /* for the trailing new line or semi-colon */
    DRE_INIT_BUF;
}

/* 
 * Accesses globals yytext, yyleng, yyout.
 * yyleng does not account for string terminator char
 */
int processFunReturn()
{
    char funRetExpr[FUN_BUF_SIZE];
    int retExpr = 0;
    int i;

    memset((void *)funRetExpr, 0, FUN_BUF_SIZE);
    for (i = 0; i < yyleng; i++) {
	if (yytext[i] == '\n' || yytext[i] == '\r') {
	    funRetExpr[i] = ' ';
	} else {
	    funRetExpr[i] = yytext[i];
	}
	if (!isspace(yytext[i])) {
	    retExpr = 1;
	} 
    }
    if (retExpr) {
	if (voidFunRetType) {
	    fprintf(stderr,
		    "Invalid code, void function %s returns expression %s\n",
		    funName, retExpr);
	    fprintf(stderr, "EXITING \n");
	    exit(1);
	}
	fprintf(yyout, 
		"OSI_CALLTRACE_RETURN_EXPR(TRACE_FUN_ID, TRACE_FUN_NAME, ");
	for (i = 0; i < yyleng; i++) {
	    fprintf(yyout, "%c", funRetExpr[i]);
	}
	fprintf(yyout, " )");
    } else {
	fprintf(yyout,
		"OSI_CALLTRACE_RETURN_NOEXPR(TRACE_FUN_ID, TRACE_FUN_NAME)");
    }
}

int funForm(char *funP, int funLen) 
{
    if ((funLen > FUN_BUF_SIZE) ||
	((char *)&funBuf[FUN_BUF_SIZE] - funBufPtr <= funLen)) {
        fprintf(stderr, "FUN buffer will overflow for name %s, exiting\n",
                funP);
        exit(1);
    }       
    if (debug1) {
        fprintf(stderr, "==Store id %s \n", funP);
    }
    strcpy((char *)funBufPtr, funP);
    funBufPtr += funLen + 1; /* +1 for \0 */
    *funBufPtr = 0;
    return 0;
}

int funExtractNameAndType() 
{
    int i;
    char *fptr, *fptr2, *tfptr;
    char *tptr;
    char *tstr;
    char tFunType[FUN_BUF_SIZE];
    int defaultReturnType;
    char *charp;

    voidFunRetType = 0; /* global */

    /* Determine function name */
    funName[0] = 0; 
    fptr = funBufPtr;
    while ((*fptr == '\0') && (fptr > &funBuf[0])) {
	fptr--;
    }
    while ((isalnum(*fptr) || (*fptr == '_')) &&
	   (fptr > &funBuf[0])) {
	fptr--;
    }

    fptr2 = fptr;

    if (fptr == &funBuf[0]) {
	if (!isalpha(*fptr) && 
	    (*fptr != '_')) {
	    fptr++;
	}
    } else {
	fptr++;
    }
    strncpy((char *)funName, (char *)fptr, FUN_BUF_SIZE);

    /* Determine function type */

    funType[0] = 0;
    if (fptr2 == &funBuf[0]) {
	sprintf(funType, "int ");
    } else {
	for (tptr= &funType[0], tfptr = &funBuf[0];
	     tfptr <= fptr2;
	     tptr++, tfptr++) {
	    if (*tfptr == 0) {
		*tptr = ' ';
	    } else {
		*tptr = *tfptr;
	    }
	}
	*tptr = 0;
	/* Remove any static class specification */
	strcpy(tFunType, funType);
	tstr = strstr(tFunType, "static");
	if (tstr) {
	    tptr = tstr - &tFunType[0] + &funType[0];
	    tstr += 7;
	    sprintf(tptr, "%s", tstr);
	}
	
	defaultReturnType = 1;
	charp = funType;
	while (*charp != 0) {
	    if (!isspace(*charp)) {
		defaultReturnType = 0;
		break;
	    }
	    charp++;
	}
	
	if (defaultReturnType) {
	    sprintf(funType, "int ");
	} else {
	    /* Determine if void return type */
	    voidFunRetType = voidFun(funType);
	}
    }

    FUN_INIT_BUF;
}

void processFunEntry()
{
    /* Only generate trace records if function is being traced */
    if (traceFun) {
	funId = baseId++;
	fprintf(funcIdFileStream, "%d\t%s\n", funId, funName);
	fprintf(yyout, "\n#define TRACE_FUN_NAME \"%s\"\n", (char *)funName);
	fprintf(yyout, "#define TRACE_FUN_ID (%d)\n", funId);
	if (!voidFunRetType) {
	    fprintf(yyout,
		    "%s _TRANSARC_TRACE_FUN_RETVAR;\n",
		    (char *)funType);
	}
	fprintf(yyout,
		"OSI_CALLTRACE_ENTRY(TRACE_FUN_ID, TRACE_FUN_NAME);\n\n");
	fprintf(yyout, "do {\n");
    }
}

void processFunExit()
{
    /* Only generate trace records if function is being traced */
    if (traceFun) {
	fprintf(yyout, "} while (0); \n");
	fprintf(yyout,
		"\nOSI_CALLTRACE_EXIT(TRACE_FUN_ID, TRACE_FUN_NAME);\n");
	fprintf(yyout, "#undef TRACE_FUN_ID\n");
	fprintf(yyout, "#undef TRACE_FUN_NAME\n");
    }
}

void genFileIncludes()
{
    fprintf(yyout, "%s \n", fileWarning);
    fprintf(yyout, "#include <dcedfs/osi_calltrace.h> \n");
}

int getFunId(char *fname)
{
    int fid;
    
    /* 100 for now */
    return fid;
}

int voidFun(char *funType)
{
    char *str;
    char *curstr, *endstr;
    char *bw, *ew;
    char tstr[BUFFER_SIZE];
    char *curtstr;
    
    str = funType;
    curstr = str;
    endstr = str + strlen(str);
    curtstr = tstr;
    while (curstr != endstr) {
	if (!isspace(*curstr)) {
	    *curtstr++ = *curstr++;
	} else {
	    curstr++;
	    while (isspace(*curstr)) curstr++;
	}
    }
    *curtstr = 0;

    return (strcmp(tstr, "void") == 0); 
}

main (argc, argv)
int argc;
char **argv;
{
    char *inFile, *outFile, *trcDir;
    
    char errBuf[BUFFER_SIZE];
    char maxIdFileName[BUFFER_SIZE];
    char symbolsDir[BUFFER_SIZE];
    FILE *maxIdFileStream;
    DIR *trcDirStream;
    
    if (argc != 4) {
	fprintf(stderr, "Usage: %s <infile> <outfile> <trcdir>\n",
		argv[0]);
	exit(1);
    }
    
    inFile = argv[1];
    if ((yyin = fopen(inFile, "r")) == (FILE *)NULL) {
	sprintf(errBuf, "%s - Unable to open input file %s\n",
		argv[0], inFile);
	perror(errBuf);
	exit(1);
    }
    
    outFile = argv[2];
    if ((yyout = fopen(outFile, "w")) == (FILE *)NULL) {
	sprintf(errBuf,"%s - Unable to open output file %s\n",
		argv[0], outFile);
	perror(errBuf);
	exit(1);
    }
    
    trcDir = argv[3];
    
    /* Check out trcdir */
    if ((trcDirStream = opendir(trcDir)) == (DIR *)NULL) {
	sprintf(errBuf, "%s - unable to access trace dir %s",
		argv[0], trcDir);
	perror(errBuf);
	exit(1);
    } else {
	closedir(trcDirStream);
    }
    
    /* Create trcdir/SYMBOLS if it does not exist */
    sprintf(symbolsDir, "%s/SYMBOLS", trcDir);
    if ((trcDirStream = opendir(symbolsDir)) == (DIR *)NULL) {
	if (mkdir(symbolsDir, 0755) < 0) {
	    sprintf(errBuf, "$s - Unable to create symbols dir %s",
		    argv[0], symbolsDir);
	    perror(errBuf);
	    exit(1);
	}
    } else {
	closedir(trcDirStream);
    }
    
    sprintf(funcIdFileName, "%s/%s", symbolsDir, inFile);
    funcIdFileStream = fopen(funcIdFileName, "r");
    if ((funcIdFileStream == (FILE *)NULL) && (errno != ENOENT)) {
	sprintf(errBuf, "%s - Unable to open trace file %s\n",
		argv[0], funcIdFileName);
	perror(errBuf);
    }
    
    if (funcIdFileStream) {
	if (fscanf(funcIdFileStream, "%d", &baseId) == 0) {
	    baseId = 0;
	}
	fclose(funcIdFileStream);
    }
    
    if (baseId == 0) {
	sprintf(maxIdFileName, "%s/.max", symbolsDir);
	maxIdFileStream = fopen(maxIdFileName, "r+");
	if ((maxIdFileStream == (FILE *)NULL) && (errno != ENOENT)) {
	    sprintf(errBuf, "%s - Unable to open trace max id file %s\n",
		    argv[0], maxIdFileName);
	    perror(errBuf);
	    exit(1);
	}
	if (maxIdFileStream) {
	    if (fscanf(maxIdFileStream, "%d", &baseId) == 0) {
		sprintf(errBuf,
			"%s - Unable to read current max id from file %s\n",
			argv[0], maxIdFileName);
		perror(errBuf);
		exit(1);
	    }
	    baseId += 200;
	    fseek(maxIdFileStream, 0, SEEK_SET);
	    fprintf(maxIdFileStream, "%d", baseId);
	} else {
	    maxIdFileStream = fopen(maxIdFileName, "w");
	    if (maxIdFileStream == (FILE *)NULL) {
		sprintf(errBuf, "%s - Unable to create max id file %s \n",
			maxIdFileName);
		perror(errBuf);
		exit(1);
	    }
	    fprintf(maxIdFileStream, "%d", 100);
	    baseId = 100;
	}
	fclose(maxIdFileStream);
    }
    
    funcIdFileStream = fopen(funcIdFileName, "w");
    if (funcIdFileStream == (FILE *)NULL) {
	sprintf(errBuf, "%s - Unable to create trace file %s\n",
		argv[0], funcIdFileName);
	perror(errBuf);
    }
    
    yylex(); 
    
    fclose(funcIdFileStream);
    
    if (stats) {    
	fprintf(stderr, "Stats\n");
	fprintf(stderr, "# comments %d\n", ncomment);
	fprintf(stderr, "# strings %d\n", nstr);
	fprintf(stderr, "# functions %d\n", nfun);
	fprintf(stderr, "# function not traced %d\n", nfununtraced);
	fprintf(stderr, "# macros %d\n", ndefine);
	fprintf(stderr, "# function returns %d\n", nfunret);
	fprintf(stderr, "# macro returns %d\n", ndefineret);	
	fprintf(stderr, "# directives %d\n", ndirective);
    }
    return 0;
}

