.de ..
..
...\"       groff -mgm rfc99.roff > /tmp/p
...\" OSF-RFC 99.0
...\" undefine this when it's no longer a draft
...\" (and you can take out the \*(Dr below)
.ds dR DRAFT #4
...\"
...\" FORMATTING INSTRUCTIONS for this RFC:
...\"       groff -mgm THIS-RFC.roff	> THIS-RFC.ps
...\"       gnroff -mgm THIS-RFC.roff	> THIS-RFC.txt
...\"       eroff -p THIS-RFC.roff	> THIS-RFC.ps
...\"       nroff -Tlpr THIS-RFC.roff	> THIS-RFC.txt
...\"       troff -Tps THIS-RFC.roff | <ps-post-processor> > THIS-RFC.os
...\" (Where "troff" means "device-independent troff", or "ditroff".)
...\"
...\" =========================================================================
...\" This template first sets a bunch of *roff options (authors/readers
...\" don't usually have to know about these).
...\" Then it defines some strings and macros, many of which deal with
...\" things that differ between nroff & troff (some of these may not be
...\" perfect, but they're better than nothing -- to do a really good
...\" job would require a real semantic markup language.
...\" Convention: "Begin/End" for strings, "Start/Finish" for macros.
...\" Strings:
...\"       \*(f!        - Footnote string (replaces \*F).
...\"       \*(hB, \*(hE - Page header/footer font (internal use).
...\"       \*(iB, \*(iE - Doc header font (internal use).
...\"       \*(qB, \*(qE - Quotations.
...\"       \*(eB, \*(eE - Emphasis in primary font.
...\"       \*(lB, \*(lE - Literal font.
...\"       \*(mB, \*(mE - Second literal font.
...\"       \*(fB, \*(fE - Emphasis in literal font.
...\" Macros:
...\"       .aH      - Appendix header macro (uses number register \na).
...\"       .aL      - Automatic list macro (replaces .AL; uses num reg \ng).
...\"       .tS, .tF - Title start/finish (internal use).
...\"       .cS, .cF - Displays (no-fill) without indentation.
...\"       .dS, .dF - Displays (no-fill) with indentation.
...\"       .iS, .iF - Indented (fill) text.
...\" -------------------------------------------------------------------------
...\" First, set up some number registers here (instead of on command line),
...\" and include the "mm" macro package here (instead of on command line).
...\" -------------------------------------------------------------------------
.ie t \{\"	troff
. nr L 11i\"	page length = 11 inches.
. nr W 6.5i\"	page width  = 6.5 inches.
. nr O 0.75i\}\"page offset = 0.75 inches.
.el \{\"	nroff
. nr L 66\"	page length = 66 lines.
. nr W 72\"	page width  = 72 columns.
. nr O 3\}\"	page offset = 3 columns.
.nr N 2 \" No header on page 1.
\" Points to "mm" package, in /usr/lib/macros. - Elan's eroff only
.\"	.if \n(.g=1 .so /usr/lib/tmac/tmac.m
.ie \n(.g=1 ...\" nothing - groff
.el .so /usr/lib/tmac/tmac.m
...\" -------------------------------------------------------------------------
...\" Next, twiddle the "mm" package to suit our preferred style.
...\" -------------------------------------------------------------------------
...\" Point size and font types.
...\" -------------------------------------------------------------------------
.if n .fp 1 R \" "Regular" font ONLY -- don't use any others in nroff.
.if t \{ .S 10 12 \" Point size = 10, vertical spacing = 12.
...\" Note: Some systems give different names to these fonts.
.ie \n(.g=1 \{\" groff
. fp 1 TR	\" Times roman
. fp 2 TI	\" Times italic
. fp 3 TB	\" Times bold
. fp 4 TBI \}	\" Times bold italic
.el \{
. fp 1 R	\" Times roman
. fp 2 I	\" Times italic
. fp 3 B	\" Times bold
. fp 4 BI \}	\" Times bold italic
.fp 5 CW \" Courier.
.fp 6 CI \" Courier oblique.
.fp 7 CB \" Courier bold.
.fp 8 CX \" Courier bold oblique.
.fp 9 H \" Helvetica.
.fp 10 HI \" Helvetica oblique.
.fp 11 HB \" Helvetica bold.
.fp 12 HX \" Helvetica bold oblique.
.fp 13 S \} \" Special symbol font -- normally only called automatically.
...\" -------------------------------------------------------------------------
...\" Headings; page header and footers; titles.
...\" -------------------------------------------------------------------------
.nr Ej 0 \" No eject for first-level headings.
.nr Hs 7 \" Heading space level = blank line after heading (all levels).
.nr Hb 7 \" Heading break level = break after heading (all levels).
.nr Hi 1 \" Post-heading indent = paragraph indent.
.nr Hc 0 \" Heading centering = none.
.if n .ds HF 1 1 1 1 1 1 1 \" Heading fonts = regular (no underlining).
.if t .ds HF 11 11 11 11 11 11 11 \" Heading fonts = Helvetica bold.
.if t .ds HP 0 0 0 0 0 0 0 \" Heading point sizes (= default).
.HM 1 1 1 1 1 1 1 \" Heading mark = arabic (all levels).
.nr Hu 1 \" Unnumbered heading level = 1 (see aH macro, below).
.de HX \" Beginning-of-heading processing.
.in 0 \" Left justify headings.
.if \\$2=0 .ds }0\" Null string heading mark for HU.
.if \\$1=1 .ds }0 \\n(H1.\ \&\" Heading marks = dotted sections + 1 space.
.if \\$1=2 .ds }0 \\n(H1.\\n(H2.\ \&
.if \\$1=3 .ds }0 \\n(H1.\\n(H2.\\n(H3.\ \&
.if \\$1=4 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\ \&
.if \\$1=5 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\ \&
.if \\$1=6 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\ \&
.if \\$1=7 .ds }0 \\n(H1.\\n(H2.\\n(H3.\\n(H4.\\n(H5.\\n(H6.\\n(H7.\ \&
..
.de HZ \" End-of-heading processing.
.if n .in 3 \" Indent body of doc by 3 columns in nroff.
.if t .in 0 \" Don't indent in troff.
..
.if n .ds hB \&\" Page header/footer font begin in nroff.
.if t .ds hB \f9\" Page header/footer font begin in troff.
.if n .ds hE \&\" Page header/footer font end in nroff.
.if t .ds hE \fP\" Page header/footer font end in troff.
.if n .ds iB \&\" Doc header font begin in nroff.
.if t .ds iB \f(11\" Doc header font begin in troff.
.if n .ds iE \&\" Doc header font end in nroff.
.if t .ds iE \f1\" Doc header font end in troff.
.de tS \" Title start.
.SP 2 \" 2 blank lines.
.ce 99 \" Center (each line of) title.
.if t \{ .ft 11 \" Bold helvetica.
.S +2 D \} \" Bigger point size.
..
.de tF \" Title finish.
.ce \" Turn off centering.
.SP 1 \" 1 blank line.
.if t \{ .ft 1 \" Return to regular font.
.S P P \} \" Return to regular point size.
..
...\" -------------------------------------------------------------------------
...\" Special Appendix heading macro, .aH.
...\" -------------------------------------------------------------------------
.nr a 0 1 \" Appendix number.
.af a A \" Assign format upper-case alpabetic to number register a.
.de aH \" Appendix heading macro.
.if \\na=0 \{ .nr H1 0 \" Reset H1 to 0.
.HM A 1 1 1 1 1 1 \} \" Heading mark = Upper case alphabetic + arabics.
.HU "APPENDIX \\n+a. \\$1"
..
...\" -------------------------------------------------------------------------
...\" Paragraph stuff.
...\" -------------------------------------------------------------------------
.nr Pt 0 \" Paragraph type = left-justified.
.nr Pi 0 \" Paragraph indent = 0.
.nr Ps 1 \" Paragraph spacing = 1 blank space.
...\" -------------------------------------------------------------------------
...\" Special list macro, .aL (replaces .AL, for all levels).
...\" This should be used for almost all lists (including ".LI "\ "").
...\" The only exception is variable lists (.VL, indented by multiples of 6).
...\" -------------------------------------------------------------------------
.de aL
.ie \\n(.g=1 .nr g \\n[li*lvl]
.el .nr g \\n(:g
...\" In-line lists should be numbered (by hand): (1), (2), (3), ...
.if \\ng=0 .LB 6 0 1 3 a \" 1st level: (a), (b), (c), ...
.if \\ng=1 .LB 6 0 1 3 i \" 2nd level: (i), (ii), (iii), ...
.if \\ng=2 .LB 6 0 1 4 a \" 3rd level: [a], [b], [c], ...
.if \\ng=3 .LB 6 0 1 4 i \" 4th level: [i], [ii], [iii], ...
.if \\ng=4 .LB 6 0 1 6 a \" 5th level: {a}, {b}, {c}, ...
.if \\ng=5 .LB 6 0 1 6 i \" 6th level: {i}, {ii}, {iii}, ...
..
.nr Ls 6 \" Blank lines between all list items, by default (but adjustable).
...\" -------------------------------------------------------------------------
...\" Footnote stuff; special footnote string, \*(f!.
...\" -------------------------------------------------------------------------
.if n .ds f! [\\*F]\" Footnote string (replaces \*F in nroff).
.if t .ds f! \\*F\" Footnote string (same as \*F in troff).
.if n .FD 6 \" Footnotes not hyphenated or indented, label left justified.
.if t .FD 5 \" Footnotes hyphenated, not indented, label left justified.
.nr Fs 1 \" 1 blank line between footnotes.
...\" -------------------------------------------------------------------------
...\" Line adjustment stuff.
...\" -------------------------------------------------------------------------
.if n .nr Hy 0 \" No hyphenation in nroff.
.if t .nr Hy 1 \" Hyphenate in troff.
.if n .SA 0 \" Set adjust: left margin only in nroff.
.if t .SA 1 \" Set adjust: left and right margins in troff.
...\" -------------------------------------------------------------------------
...\" Miscellaneous stuff.
...\" -------------------------------------------------------------------------
.ta \" No tabs by default -- set them up by hand as needed.
.nr Si \n(Ls \" Default indent for .DS display macro = 6 (use in troff only).
...\" -------------------------------------------------------------------------
...\" Displays.
...\" -------------------------------------------------------------------------
.de cS \" Display start: no-fill, literal font, no indentation.
.P
.nf \" No fill mode.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .cS, ".ne"'s can be added by hand, but should be minimized.
.de cF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.P
..
.de dS \" Display start: no-fill, literal font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.nf \" No fill mode.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 5 \" Constant width font in troff.
..
...\" Within .dS, ".ne"'s can be added by hand, but should be minimized.
.de dF \" Display finish.
.if t .ft 1 \" Back to standard font in troff.
.fi \" Fill mode.
.LE
.P
..
.de iS \" Indent start: fill, regular font, with indentation.
.P
.aL
.LI "\ "
..
.de iF \" Indent finish.
.LE
.P
..
.de jS \" Indent start: no-fill, regular font, with indentation.
.P
.aL
.nf
.LI "\ "
..
.de jF \" Indent finish.
.fi
.LE
.P
..
.de nS \" Note to Reviewers start: fill, italics font, with indentation.
.P
.aL \" Use .aL macro for consistent indentation.
.LI "\ " \" List item will no (visible) marker.
.if t .ft 2 \" Italics font in troff.
Note to Reviewers:
..
...\" Within .dS, ".ne"'s can be added by hand, but should be minimized.
.de nF \" Note to Reviewers finish.
.if t .ft 1 \" Back to standard font in troff.
.LE
.P
..
...\" -------------------------------------------------------------------------
...\" Quotation marks and font toggles.
...\" -------------------------------------------------------------------------
.if n .ds qB \&"\" Quotation begin in nroff.
.if t .ds qB ``\" Quotation begin in troff.
.if n .ds qE \&"\" Quotation end in nroff.
.if t .ds qE ''\" Quotation end in troff.
.if n .ds eB \&\" Emphasis primary font begin in nroff.
.if t .ds eB \f2\" Emphasis primary font begin in troff.
.if n .ds eE \&\" Emphasis primary font end in nroff.
.if t .ds eE \fP\" Emphasis primary font end in troff.
.if n .ds lB \&`\" Literal font begin in nroff.
.if t .ds lB \f5\" Literal font begin in troff.
.if n .ds lE \&'\" Literal font end in nroff.
.if t .ds lE \fP\" Literal font end in troff.
.if n .ds mB `\" Second literal font begin in nroff.
.if t .ds mB \f5\" Second literal font begin in troff.
.if n .ds mE '\" Second literal font end in nroff.
.if t .ds mE \fP\" Second literal font end in troff.
.if n .ds fB \&\" Emphasis literal font begin in nroff.
.if t .ds fB \fP\f6\" Emphasis literal font begin in troff.
.if n .ds fE \&\" Emphasis literal font end in nroff.
.if t .ds fE \fP\f5\" Emphasis literal font end in troff.
.if n .ds dB \&\" Definition begin in nroff.
.if t .ds dB \f3\" Definition begin in troff.
.if n .ds dE \&\" Definition end in nroff.
.if t .ds dE \fP\" Definition end in troff.
...\"
...\"
...\" =========================================================================
...\" =========================================================================
...\"
.de cB
.P
.aL
.nf
.LI "\ "
.if t .ft 5
.ne \\$1
..
.de cE
.if t .ft 1
.LE
.P
.fi
..
...\"		START-RFC
...\"
...\" =========================================================================
...\" Finally, it's time to start writing the document!
...\" The OSF-RFC author modifies the following header/footer info.
...\" (The major/minor number is assigned by the OSF-RFC Editor.)
...\" =========================================================================
.ND "December 1996"\"	Date must be hard-coded.
.PH "$\*(hBOSF-RFC 99.0$Message Queuing for DCE$\\\\*(DT\*(hE$"
.PF "$\*(hBBowe, Salamone$\*(dR$Page \\\\n%\*(hE$" \" Draft version.
...\".PF "$\*(hBBowe, Salamone $$Page \\\\n%\*(hE$" \" Final version.
...\"
...\" Following are the first printed lines (header info) of the document:
...\"
\&\" Force top-of-first-page trap to position the following info correctly.
.tl $\*(iBThe Open Group$$J. Bowe (OSF)\*(iE$
.tl $\*(iBRequest For Comments: 99.0$$J. Salamone (OSF)\*(iE$
.tl $\*(iB\*(DT\*(iE$$$
.tS \" Title, in all capitals (can span multiple lines):
MESSAGE QUEUING FOR DCE
.tF
...\" =========================================================================
...\" Now, the actual body of the document!!
...\" Heading capitalization style:
...\"     1st level: CAPITALIZE ALL WORDS
...\"     2nd level: Capitalize Initial Letters of All (Significant) Words
...\"     3rd-7th level: Capitalize first letter of first word only
...\" =========================================================================
.P
.H 1 "INTRODUCTION"
.P
Providing a means for applications to communicate is a fundamental
service of any distributed computing infrastructure.
One method, which is analogous to inter-process communication mechanisms
typically available within a single system, is message exchange.
A message is a unit of data that one application process may send to other
application processes.
The size, content and significance of a message is determined by
the communicating application processes.
.P
DCE has always offered Remote Procedure Call (RPC) based communication.
Some DCE-detractors claim that message passing and/or queuing is superior.
We feel this sometimes turns into a religious battle.
Our view is that it depends on the application.
Providing some message-oriented services will make DCE more attractive for
some application writers.
.P
RFC 95, \*(qBDCE/NEXT: REQUIREMENTS SUMMARY\*(qE,
asks for "support for message queuing in DCE"
and "support for messaging in DCE, including asynchronous RPC".

.H 2 "Some Background on Messaging"
.P
Viewed from the highest level, there are three components of interest
in the messaging environment:
those that use the messaging service;
those that the messaging service uses;
and the messaging service itself.
Each of these will be described in more detail in later sections.
.P
There are primarily two types of message service users:
senders and recipients of messages;
and administrators.
A sender is a process which calls upon the messaging service to
communicate a message to other processes.
A recipient is a process which calls upon the messaging service to retrieve
messages that were sent by other processes.
A process may be both a sender and a receiver.
An administrator controls the configuration and operation of the
messaging service.
The services provided by the messaging system to
support these usage types are each described separately.
.P
The messaging system itself provides services through two interfaces,
one for message communication and related functions, and one for
administration.  Internally, the system is logically partitioned into
the components which support the interfaces local to an individual
system, queue managers, and queues.  There may be multiple instances
of each of these components as described later.
.P
The messaging system makes use of data transmission, marshaling,
naming, and security services provided by the underlying computing
environment, in this case, DCE.
.P
The messaging service allows senders and receivers to execute concurrently
and to send and receive messages asynchronously.
Two forms of asynchronous message communication to consider are message
queuing and message passing.
The focus of this work is to build a message queuing system, therefore,
message passing will only be mentioned to illustrate some of the differences
between queuing versus passing.
To adequately describe these forms of message communication, some of the
components of the messaging system must first be described in more detail.
.P
.H 2 "Document Structure"
.P
The remainder of this document is divided into four sections.
Section 2 describes some terminology.
Section 3 describes the major goals of the project.
Section 4 describes the network data structures
Section 5 describes the RPC interfaces.
Section 6 describes the API.
Section 7 describes the administrative interface.


...\" ---------------------------------------------------------------
.H 1 "TERMINOLOGY"
.P
A "queue" is a container for 0 or more messages.
.P
"Message queuing" is the exchange of messages between a sender and recipient
through a third party.
Sender and recipient processes need not be active at the same time.
.P
"Message passing" is the exchange of messages between a sender and recipient
directly.
Sender and recipient processes must not be active at the same time.
.P
A "queue manager" is a DCE server that manages a collection of queues.
Message queuing requires a queue manager.
.P
"Persistence" is how a message is stored within a queue manager.
"Volatile" means it is stored in memory;
this means it may be lost when the qeueue manager process exits.
"Persistent" means it is stored in a stable place, typically on disk;
this means it is not lost when the qeueue manager process
exits and is restarted.
We will use the DCE backing store library for persistent storage.

.P
...\" ---------------------------------------------------------------
.H 1 "GOALS AND NON-GOALS"
.P
The following are the goals of this project:
.aL
.LI
Provide an infrastructure for secure message queuing
between the queue manager and senders and recipients.
.LI
Implement on top of commercial DCE releases (OSF release 1.1).
This means the DCE source is not a requirement.
.LI
Supply a set of APIs that let a user send an arbitrarily complex
data structure to be to a destination.
.LE
.P
The following are \*(iBnot\*(iE goals:
.aL
.LI
Provide message passing.
.LI
Transaction capability.
.LE
.H 2 "System Features"
.P
The following is a list of queuing system features we will provide.
.aL
.LI
Adheres to the DCE security model.
In addition, the API provides an interface for an end-to-end protection
level and a means to identify initial senders to recipients.
.LI
An easy way to encode and decode (marshal) structured data as the message.
This will be done with the existing RPC encoding services.
.LI
Uses the DCE namespace to identify queue managers and queues.
.LI
Automatic acknowledgement of message receipt (or dequeue)
.LI
Support the following attributes on queues
.aL
.LI
queue name
.LI
queue name aliases
.LI
annotation
.LI
creation timestamp
.LI
maximum message size
.LI
maximum length of queue
.LI
enable and disable of enqueue and dequeue operations
.LI
current length
.LI
last activity timestamp
.LI
idle timeout for empty queues
.LI
persistence
.LE
.LI
Support the following attributes on messages
.aL
.LI
unique message identifier (UUID)
.LI
enqueue timestamp
.LI
message type
.LI
data type (UUID)
.LI
priority
.LI
message expiration
.LI
persistence
.LI
message sender (principal identity)
.LI
message delivery notice options
.LI
end-to-end protection level
(none, authentication, integrity, packet-level privacy)
.LE
.LI
Dequeue filtering based on some of the above message attributes
.LE
.P
...\" ---------------------------------------------------------------
.H 1 "DATA STRUCTURES"
.P
Included here are the "major" data structures, as defined in various
idl files.
Minor, supporting types and enumerations are not shown.
.P
This is the attribute structure of an individual message.
.dS 6
typedef struct mos_mattr_s_t {
    uuid_t          id;             /* ID of this item in the queue */
    uuid_t          datatype;       /* manager that encoded it */
    mos_msg_attr_msgtype_t
		    msgtype;        /* message type */
    sec_id_pa_t     sender;         /* sender identity */
    unsigned32      priority;       /* priority */
    unsigned32      flags;          /* flags */
    mos_msg_attr_persistence_t
		    persistence;
    /* notice_dest, notice_sec may be null */
    unsigned32      notice_opts;    /* notice options */
    [ptr,string]
      char          *notice_dest;   /* name of ack/reply queue */
    [ptr,string]
      char          *notice_sec_name;
				    /* sec group other qmgr must be in */
    unsigned32      protectlvl;     /* protection level */
    /* want a counter instead of time enqueued? */
    utc_t           time_enqueued;  /* when msg was enqueued by q-mgr */
    utc_t           expire_time;    /* when this msg will expire */
    utc_t           valid_time;     /* when this msg will become valid */
    uuid_t          qid;            /* ID of queue where this lives */
} mos_mattr_t;
.dF
.P
This is an array of bytes, which, as far as the messaging system
is concerned, is the message payload or body.
.dS 4
typedef struct {
   unsigned32          size;
   [ptr,size_is(size)]
   byte *              data;
} mos_datatype_bytearray_t;
.dF
.P
This is an item in the queue, composed of the message attributes and the body.
.dS 4
typedef struct mos_qitem_s_t {
    mos_mattr_t                     mattr;
    mos_datatype_bytearray_t        body;
} mos_qitem_t;
.dF
.P
This is the attribute structure of a queue.
.dS 6
typedef struct mos_qattr_s_t {
    uuid_t          id;             /* ID of the queue */
    [ptr,string]
      char          *name;          /* name of the queue */
    [ptr,string]
      char          *annotation;    /* annotation */
    mos_string_list_t
		    aliases;        /* alias names of the queue */
    mos_que_attr_persistence_t
		    persistence;
    boolean         enq_enabled;    /* enqueue: enable/disable */
    boolean         deq_enabled;    /* dequeue: enable/disable */
    unsigned32      flags;          /* flags */
    unsigned32      len;            /* current length of queue [ro] */
    unsigned32      max_msgsize;    /* max message size */
    unsigned32      max_qlen;       /* max length of queue */
    utc_t           created;        /* time created [ro] */
    utc_t           empty_timeout;  /* idle/empty time before removing */
    utc_t           last_activity;  /* time of last activity [ro] */
    uuid_t          acl;            /* ACL uuid - internal use [ro] */
} mos_qattr_t;
.dF
.P
.P
...\" ---------------------------------------------------------------
.H 1 "QUEUE MANAGER RPC OPERATIONS"
.P
.H 2 "Management (Queue Manager) Operations"
.H 3 "mos_mgmt_create_queue()"
Create a queue.
.H 3 "mos_mgmt_get_id_list()"
Return a list of the IDs of all queues.
.H 3 "mos_mgmt_rename()"
Rename a queue within queue manager.
.H 3 "mos_mgmt_move()"
Move messages from one queue to another, retaining all attributes.
This is within the same queue manager.
.H 2 "Queue (Data) Operations"
.H 3 "mos_q_enqueue()"
Enqueue a message in a given queue.
The message is placed in the queue according to priority.
.H 3 "mos_q_dequeue()"
Dequeue a message (body and attributes) from a queue,
optionally dequeuing it and optionally blocking until a message is available.
Also optionally accepts a selection filter.
.H 3 "mos_q_dequeue_next()"
Simpler version mos_q_dequeue.
Dequeues next available message and attributes from a queue.
.H 3 "mos_q_peek()"
Similar to mos_q_dequeue, but only a copy of the message
attributes and body are returned; it is not dequeued.
.H 3 "mos_q_purge()"
Purge a message with a given ID.
.H 3 "mos_q_retrieve_attr()"
Retrieve message attributes from a queue,
optionally blocking until a message is available.
Also optionally accepts a selection filter.
Similar to mos_q_dequeue, but a message body is not returned
and the message is not dequeued.
.H 3 "mos_q_retrieve_attr_by_id()"
Retrieve message attributes from a queue,
optionally blocking until a message is available.
Also optionally accepts a selection filter.
Similar to mos_q_dequeue, but a message body is not returned
and the message is not dequeued.
.H 3 "mos_q_ping()"
Determine if a queue with a given name exists.
Its ID is returned, since queues may have aliases, and UUIDs are unique.
This is a simplified version of mos_q_retrieve_attr,
but optimized for just determining if a queue is there.
It is indended for the API's "attach" call.
.H 3 "mos_q_get_id_list()"
Return a list of IDs of messages on a queue
that match the given selection filter.
.H 3 "mos_q_get_id_list_all()"
Return a list of IDs of all messages on a queue.
.H 3 "mos_q_delete_queue()"
Delete a queue.
.H 3 "mos_q_get_attr_by_name() and mos_q_get_attr_by_id()"
Return attributes of the queue described by the given name or UUID.
.H 3 "mos_q_set_attr_by_name() and mos_q_set_attr_by_id()"
Set attributes of the queue described by the given name or UUID.
.P
...\" ---------------------------------------------------------------
.H 1 "APPLICATION PROGRAMMING INTERFACE (API)"
.P
The API is broken into these categories:
.aL
.LI
API Control
.LI
Naming
.LI
Conversation Management
.LI
Security
.LI
Marshalling
.LI
Message Attribute Utilities
.LI
Message Selection Filter Utilities
.LI
Queue Attribute Utilities
.LI
Queue Management Utilities
.LE
.P
When a full DCE name is not specified for a queue in the various APIs,
the API will choose a default queue manager, based on the following
mechanisms.
The search order is:
.aL
.LI
Determine if caller has previously obtained or set a default queue manager
via the API with
mos_rsrc_dflt_quemgr_get() or mos_rsrc_dflt_quemgr_set(), respectively.
.LI
Environment variable \*(lBMOS_DFLT_QUEMGR_NAME\*(lE.
.LI
Per-host profile or hostdata object: \*(lB/.:/hosts/$HOSTNAME/profile\*(lE.
.LI
Per-cell profile: \*(lB/.:/cell-profile\*(lE.
.LE
.P
What follow are C function prototypes from our in-progress implementation
(mosif.h).
This describes the APIs and their parameters.
There is a separate, more-detailed specification of the API.
.P
.H 2 "API Control"
Client interfaces for API control to support
the Message Oriented Service Application Programming Interface(MOS-API).
.H 3 mos_done
.P
Releases all resources used by a MOS application.
.cS
    void
    mos_done(
        /* [out] */        error_status_t *       status
    );
.cF
.H 2 "Naming"
Client interfaces for Naming to support
the Message Oriented Service Application Programming Interface(MOS-API).
.H 3 mos_rsrc_dflt_quemgr_get
.P
Returns the default queue manager used by a MOS application.
.cS
    void
    mos_rsrc_dflt_quemgr_get(
        /* [in] */        sec_rgy_name_t          security_name,
        /* [out] */       mos_rsrc_name_t         name,
        /* [out] */       mos_handle_t *          resource_handle,
        /* [out] */       error_status_t *        status
    );
.cF
.H 3 mos_rsrc_dflt_quemgr_set
.P
Sets the default queue manager used by a MOS application.
.cS
    void
    mos_rsrc_dflt_quemgr_set(
        /* [in] */        mos_rsrc_name_t         name,
        /* [in] */        sec_rgy_name_t          security_name,
        /* [out] */       mos_handle_t *          resource_handle,
        /* [out] */       error_status_t *        status
    );
.cF
.H 3 mos_rsrc_attach
.P
Finds one existing resource by name in the namespace.
A resource is a name in the namespace that may be a queue, a
Q-mgr, a destination peer application, a specific NSI entry,
group, or profile name.
.cS
    void
    mos_rsrc_attach(
        /* [in] */        mos_rsrc_name_t         name,
        /* [in] */        sec_rgy_name_t          security_name,
        /* [out] */       mos_handle_t *          resource_handle,
        /* [out] */       error_status_t *        status
    );
.cF
.H 3 mos_rsrc_detach
.P
Releases one resource and any allocated memory within MOS
associated with the named resource.
It is the responsibility of the caller to release any resources
obtained via mos_rsrc_attach(), mos_rsrc_dflt_quemgr_get(),
mos_rsrc_dflt_quemgr_set(), mos_que_mgmt_create(), or
mos_msg_attr_notice_set().
.cS
    void
    mos_rsrc_detach(
        /* [in, out] */   mos_handle_t *          resource_handle,
        /* [out] */       error_status_t *        status
    );
.cF
.H 3 mos_rsrc_name_get
.P
Returns the queue manager name, its security group name, its principal name,
and if applicable the queue name itself for the specified resource handle.
.cS
    void
    mos_rsrc_name_get(
        /* [in] */        mos_handle_t            resource_handle,
        /* [out] */       sec_rgy_name_t          security_name,
        /* [out] */       sec_rgy_name_t          quemgr_prin_name,
        /* [out] */       mos_rsrc_name_t         quemgr_name,
        /* [out] */       mos_rsrc_name_t         que_name,
        /* [out] */       error_status_t *        status
    );
.cF
.H 2 "Conversation Management"
Client interfaces for Conversation Management to support the Message
Oriented Service Application Programming Interface(MOS-API).
.H 3 mos_msg_enqueue
.P
Enqueue one message to a queue.
.cS
    void
    mos_msg_enqueue(
        /* [in] */        mos_handle_t             resource_handle,
        /* [in] */        unsigned32               flags,
        /* [in] */        mos_msg_attr_t           msg_attributes,
        /* [in] */        void *                   msg_buffer,
        /* [out] */       uuid_t *                 msg_id,
        /* [out] */       error_status_t *         status
    );
.cF
.H 3 mos_msg_dequeue
.P
Dequeue one message from a queue.
.cS
    void
    mos_msg_dequeue(
        /* [in] */     mos_handle_t                resource_handle,
        /* [in] */     unsigned32                  flags,
        /* [in] */     mos_msg_selfilter_t         msg_selection_filter,
        /* [out] */    mos_msg_attr_t *            msg_attributes,
        /* [out] */    mos_msg_buf_t *             msg_buffer,
        /* [out] */    error_status_t *            status
    );
.cF
.H 3 mos_msg_peek
.P
Returns a copy of one message from a queue.
.cS
    void
    mos_msg_peek(
        /* [in] */     mos_handle_t                resource_handle,
        /* [in] */     unsigned32                  flags,
        /* [in] */     mos_msg_selfilter_t         msg_selection_filter,
        /* [out] */    mos_msg_attr_t *            msg_attributes,
        /* [out] */    mos_msg_buf_t *             msg_buffer,
        /* [out] */    error_status_t *            status
    );
.cF
.H 3 mos_msg_delete
.P
Deletes one message by message ID from a queue.
.cS
    void
    mos_msg_delete(
        /* [in] */        mos_handle_t             resource_handle,
        /* [in] */        uuid_t *                 msg_id,
        /* [out] */       error_status_t *         status
    );
.cF
.H 3 mos_msg_move
.P
Move one message by message ID from one queue to another.
.cS
    void
    mos_msg_move(
        /* [in] */        mos_handle_t             src_resource_handle,
        /* [in] */        mos_handle_t             dest_resource_handle,
        /* [in] */        uuid_t *                 msg_id,
        /* [out] */       error_status_t *         status
    );
.cF
.H 2 "Message Attribute Utilities"
Client interfaces for Message Attribute Utilities to support the
Message Oriented Service Application Programming Interface(MOS-API).
.H 3 mos_msg_attr_alloc
.P
Allocates memory within MOS and returns an opaque pointer to
a message attributes structure with defaults set.
.cS
    void
    mos_msg_attr_alloc(
        /* [out] */        mos_msg_attr_t *         msg_attributes,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_msg_attr_peek
.P
Returns an opaque pointer to the message attributes on an
existing message in the specified queue.
Applies to Message Queuing model only.
.cS
    void
    mos_msg_attr_peek(
        /* [in] */         mos_handle_t             resource_handle,
        /* [in] */         unsigned32               flags,
        /* [in] */         mos_msg_selfilter_t      msg_selection_filter,
        /* [out] */        mos_msg_attr_t *         msg_attributes,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_msg_attr_free
.P
Releases memory used for message attributes.
It is the responsibility of the caller to release the memory
if allocated by mos_msg_attr_alloc() or mos_msg_attr_peek().
.cS
    void
    mos_msg_attr_free(
        /* [in,out] */     mos_msg_attr_t *         msg_attributes,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_msg_attr_msgid_get
.P
Return message ID from a message attributes structure.
.cS
    void
    mos_msg_attr_msgid_get(
        /* [in] */         mos_msg_attr_t            msg_attributes,
        /* [out] */        uuid_t *                  msg_id,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_msg_attr_enqtime_get
.P
Return message enqueue time stamp in absolute time from
a message attributes structure.
.cS
    void
    mos_msg_attr_enqtime_get(
        /* [in] */         mos_msg_attr_t           msg_attributes,
        /* [out] */        utc_t *                  msg_enq_time,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_msg_attr_msgtype_get
.P
Return message type from a message attributes structure.
.cS
    void
    mos_msg_attr_msgtype_get(
        /* [in] */         mos_msg_attr_t           msg_attributes,
        /* [out] */        mos_msg_attr_msgtype_t * msg_type,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_msg_attr_msgtype_set
.P
Set message type in a message attributes structure.
.cS
    void
    mos_msg_attr_msgtype_set(
        /* [in] */         mos_msg_attr_msgtype_t  msg_type,
        /* [in,out] */     mos_msg_attr_t          msg_attributes,
        /* [out] */        error_status_t *        status
    );
.cF
.H 3 mos_msg_attr_priority_get
.P
Return priority from a message attributes structure.
.cS
    void
    mos_msg_attr_priority_get(
        /* [in] */         mos_msg_attr_t          msg_attributes,
        /* [out] */        unsigned32 *            priority,
        /* [out] */        error_status_t *        status
    );
.cF
.H 3 mos_msg_attr_priority_set
.P
Set priority in a message attributes structure.
.cS
    void
    mos_msg_attr_priority_set(
        /* [in] */         unsigned32              priority,
        /* [in,out] */     mos_msg_attr_t          msg_attributes,
        /* [out] */        error_status_t *        status
    );
.cF
.H 3 mos_msg_attr_ttl_get
.P
Return message expiration(time-to-live) in absolute time from
a message attributes structure.
.cS
    void
    mos_msg_attr_ttl_get(
        /* [in] */         mos_msg_attr_t           msg_attributes,
        /* [out] */        utc_t *                  ttl,
        /* [out] */        error_status_t *        status
    );
.cF
.H 3 mos_msg_attr_ttl_set
.P
Set message expiration(time-to-live) in absolute time in a
message attributes structure.
.cS
    void
    mos_msg_attr_ttl_set(
        /* [in] */         utc_t *                  ttl,
        /* [in,out] */     mos_msg_attr_t           msg_attributes,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_msg_attr_ttr_get
.P
Return time-to-receive in absolute time from a message
attributes structure.
.cS
    void
    mos_msg_attr_ttr_get(
        /* [in] */         mos_msg_attr_t           msg_attributes,
        /* [out] */        utc_t *                  ttr,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_msg_attr_ttr_set
.P
Set time-to-receive in absolute time in a message attributes
structure.
.cS
    void
    mos_msg_attr_ttr_set(
        /* [in] */         utc_t *                  ttr,
        /* [in,out] */     mos_msg_attr_t           msg_attributes,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_msg_attr_persistence_get
.P
Return persistence from a message attributes structure.
.cS
    void
    mos_msg_attr_persistence_get(
        /* [in] */         mos_msg_attr_t                  msg_attributes,
        /* [out] */        mos_msg_attr_persistence_t *    persistence,
        /* [out] */        error_status_t *                status
    );
.cF
.H 3 mos_msg_attr_persistence_set
.P
Set persistence in a message attributes structure.
.cS
    void
    mos_msg_attr_persistence_set(
        /* [in] */         mos_msg_attr_persistence_t      persistence,
        /* [in,out] */     mos_msg_attr_t                  msg_attributes,
        /* [out] */        error_status_t *                status
    );
.cF
.H 3 mos_msg_attr_notice_get
.P
Return notice options from a message attributes structure.
.cS
    void
    mos_msg_attr_notice_get(
        /* [in] */         mos_msg_attr_t           msg_attributes,
        /* [out] */        unsigned32 *             notice_flags,
        /* [out] */        mos_rsrc_name_t          notice_destination,
        /* [out] */        sec_rgy_name_t           notice_security_name,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_msg_attr_notice_set
.P
Set notice options in a message attributes structure
and return a handle to the notice destination.
.cS
    void
    mos_msg_attr_notice_set(
        /* [in] */         unsigned32               notice_flags,
        /* [in] */         mos_rsrc_name_t          notice_destination,
        /* [in] */         sec_rgy_name_t           notice_security_name,
        /* [in,out] */     mos_msg_attr_t           msg_attributes,
        /* [out] */        mos_handle_t *           resource_handle,
        /* [out] */        error_status_t *         status
    );
.cF
.H 2 "Security"
Client interfaces for Security to support
the Message Oriented Service Application Programming Interface(MOS-API).
.H 3 mos_msg_attr_protectlvl_get
.P
Return the end-to-end protection level of initial sender
from the message attribute structure.
Applies to Message Queuing model only.
.cS
    void
    mos_msg_attr_protectlvl_get(
        /* [in] */         mos_msg_attr_t           msg_attributes,
        /* [out] */        unsigned32 *             protect_level,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_msg_attr_protectlvl_set
.P
Sets the end-to-end protection level of initial sender
from the message attribute structure.
Applies to Message Queuing model only.
.cS
    void
    mos_msg_attr_protectlvl_set(
        /* [in] */         unsigned32               protect_level,
        /* [in,out] */     mos_msg_attr_t           msg_attributes,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_msg_attr_secid_get
.P
Return the security identity of initial sender of a message
from the message attribute structure.
Applies to Message Queuing model only.
.cS
    void
    mos_msg_attr_secid_get(
        /* [in] */         mos_msg_attr_t           msg_attributes,
        /* [out] */        sec_id_pa_t *            sec_id,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_rsrc_protectlvl_get
.P
Returns the protection level for communications made
to a resource.
This is not to be confused with end-to-end protection levels.
.cS
    void
    mos_rsrc_protectlvl_get(
        /* [in] */        mos_handle_t            resource_handle,
        /* [out] */       unsigned32 *            protect_level,
        /* [out] */       error_status_t *        status
    );
.cF
.H 3 mos_rsrc_protectlvl_set
.P
Sets and registers the protection level for communications made
to a resource.
This is not to be confused with end-to-end protection levels.
.cS
    void
    mos_rsrc_protectlvl_set(
        /* [in] */        unsigned32              protect_level,
        /* [in/out] */    mos_handle_t            resource_handle,
        /* [out] */       error_status_t *        status
    );
.cF
.H 2 "Marshalling"
Client interfaces for Marshalling to support
the Message Oriented Service Application Programming Interface (MOS-API).
.P
This is the datatype passed to mos_api_datatype_register().
It is meant for the idl-generated encoding/decoding function.
.cS
    typedef void (*mos_msg_attr_convfn_t)(
        /* [in] */         idl_es_handle_t        handle,
        /* [in,out] */     void *                 data,
        /* [in,out] */     error_status_t *       status
    );
.cF
.H 3 mos_msg_attr_datatype_get
.P
Return application-specific data type from message
attributes structure.
.cS
    void
    mos_msg_attr_datatype_get(
        /* [in] */         mos_msg_attr_t           msg_attributes,
        /* [out] */        uuid_t *                 datatype_id,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_msg_attr_datatype_set
.P
Set application-specific data type from message
attributes structure.
.cS
    void
    mos_msg_attr_datatype_set(
        /* [in] */         uuid_t *                 datatype_id,
        /* [in,out] */     mos_msg_attr_t           msg_attributes,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_api_datatype_register
.P
Register one application-specific data type and its associated
conversion function with MOS to encode/decode the data.
.cS
    void
    mos_api_datatype_register(
        /* [in] */         uuid_t *                      datatype_id,
        /* [in] */         mos_msg_attr_convfn_t         conv_fn,
        /* [out] */        error_status_t *              status
    );
.cF
.H 3 mos_api_datatype_unregister
.P
Unregister one application-specific data type and its associated
conversion function with MOS.
.cS
    void
    mos_api_datatype_unregister(
        /* [in] */         uuid_t *                      datatype_id,
        /* [out] */        error_status_t *              status
    );
.cF
.H 3 mos_msg_datatype_decode
.P
Decodes the message buffer returned by mos_msg_dequeue()
or mos_msg_peek().
.cS
    void
    mos_msg_datatype_decode(
        /* [in] */         uuid_t *                      datatype_id,
        /* [in] */         mos_msg_buf_t                 msg_buffer,
        /* [out] */        void *                        decoded_msg_buffer,
        /* [out] */        error_status_t *              status
    );
.cF
.H 3 mos_msg_buf_free
.P
Releases memory used for the message buffer.
It is the responsibility of the caller to release the memory
if allocated by mos_msg_dequeue() or mos_msg_peek().
.cS
    void
    mos_msg_buf_free(
        /* [in,out] */     mos_msg_buf_t *               msg_buffer,
        /* [out] */        error_status_t *              status
    );
.cF
.H 2 "Message Selection Filter Utilities"
Client interfaces for Message Selection Filter Utilities to support
the Message Oriented Service Application Programming Interface(MOS-API).
.H 3 mos_msg_selfilter_alloc
.P
Allocates memory within MOS and returns an opaque pointer to a
selection filter structure.
The selection filter is comprised of one or more masks that follow
the rules of the logical AND operator among all specified criteria
when retrieving messages.
.cS
    void
    mos_msg_selfilter_alloc(
        /* [out] */         mos_msg_selfilter_t *   selection_filter,
        /* [out] */         error_status_t *        status
    );
.cF
.H 3 mos_msg_selfilter_free
.P
Releases memory used for the selection filter when retrieving messages.
It is the responsibility of the caller to release the memory if
allocated by mos_msg_selfilter_alloc().
.cS
    void
    mos_msg_selfilter_free(
        /* [in,out] */      mos_msg_selfilter_t *   selection_filter,
        /* [out] */         error_status_t *        status
    );
.cF
.H 3 mos_msg_selmask_add
.P
Adds one mask to the list of masks in the selection filter structure.
A mask is comprised of a selection criteria type, a selection
criteria value, and the relational operator to be performed.
.cS
    void
    mos_msg_selmask_add(
        /* [in] */         mos_msg_selmask_type_t   mask_type,
        /* [in] */         mos_msg_selmask_value_t  mask_value,
        /* [in] */         mos_msg_selmask_op_t     mask_op,
        /* [in,out] */     mos_msg_selfilter_t      selection_filter,
        /* [out] */        error_status_t *         status
    );
.cF
.H 2 "Queue Attribute Utilities"
Client interfaces for Queue Attribute Utilities to support the Message
Oriented Service Application Programming Interface(MOS-API).
.H 3 mos_que_attr_alloc
.P
Allocates memory within MOS and returns an opaque pointer to a
queue attributes structure with defaults set.
.cS
    void
    mos_que_attr_alloc(
        /* [out] */        mos_que_attr_t *         que_attributes,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_que_attr_peek
.P
Returns an opaque pointer to the queue attributes on an
existing queue.
.cS
    void
    mos_que_attr_peek(
        /* [in] */         mos_handle_t             resource_handle,
        /* [out] */        mos_que_attr_t *         que_attributes,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_que_attr_free
.P
Releases memory used for queue attributes.
It is the responsibility of the caller to release the memory
if allocated by mos_que_attr_alloc() or mos_que_attr_peek().
.cS
    void
    mos_que_attr_free(
        /* [in,out] */     mos_que_attr_t *         que_attributes,
        /* [out] */        error_status_t *         status
    );
.cF
Commit queue attribute modifications on an existing queue.
.cS
    void
    mos_que_attr_commit(
        /* [in] */         mos_handle_t             resource_handle,
        /* [in] */         mos_que_attr_t           queue_attributes,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_que_attr_queid_get
.P
Return queue ID from queue attributes structure.
.cS
    void
    mos_que_attr_queid_get(
        /* [in] */         mos_que_attr_t           que_attributes,
        /* [out] */        uuid_t *                 que_id,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_que_attr_quecursize_get
.P
Return current queue size from queue attributes structure.
.cS
    void
    mos_que_attr_quecursize_get(
        /* [in] */         mos_que_attr_t           que_attributes,
        /* [out] */        unsigned32 *             que_cur_size,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_que_attr_createtime_get
.P
Return queue creation time stamp in absolute time from queue
attributes structure.
.cS
    void
    mos_que_attr_createtime_get(
        /* [in] */         mos_que_attr_t           que_attributes,
        /* [out] */        utc_t *                  que_create_time,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_que_attr_activetime_get
.P
Return queue last activity time stamp in absolute time from
queue attributes structure.
.cS
    void
    mos_que_attr_activetime_get(
        /* [in] */         mos_que_attr_t           que_attributes,
        /* [out] */        utc_t *                  que_active_time,
        /* [out] */        error_status_t *         status
    );
.cF
.H 3 mos_que_attr_alias_list
.P
Return the list of queue aliases by name from queue attributes
structure. The first entry in the list is the queue name itself.
.cS
    void
    mos_que_attr_alias_list(
        /* [in] */         mos_que_attr_t            que_attributes,
        /* [in] */         unsigned32                space_avail,
        /* [out] */        unsigned32 *              num_returned,
        /* [out, size_is(space_avail), length_is(*num_returned)] */
                           mos_rsrc_name_t           que_alias_list[],
        /* [out] */        unsigned32 *              num_left,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_alias_add
.P
Adds one queue alias to the list of queue aliases in the queue
attributes structure.
.cS
    void
    mos_que_attr_alias_add(
        /* [in] */         mos_rsrc_name_t           link_name,
        /* [in] */         mos_rsrc_name_t           que_alias_name,
        /* [in,out] */     mos_que_attr_t            que_attributes,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_alias_remove
.P
Removes one queue alias from the list of queue aliases in the
queue attributes structure.
.cS
    void
    mos_que_attr_alias_remove(
        /* [in] */         mos_rsrc_name_t           link_name,
        /* [in] */         mos_rsrc_name_t           que_alias_name,
        /* [in,out] */     mos_que_attr_t            que_attributes,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_alias_reset
.P
Sets the queue alias list to NULL in the queue attributes structure.
.cS
    void
    mos_que_attr_alias_reset(
        /* [in,out] */     mos_que_attr_t            que_attributes,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_annotation_get
.P
Return queue annotation from queue attributes structure.
.cS
    void
    mos_que_attr_annotation_get(
        /* [in] */        mos_que_attr_t             que_attributes,
        /* [out] */       mos_que_attr_annotation_t  annotation,
        /* [out] */       error_status_t *           status
    );
.cF
.H 3 mos_que_attr_annotation_set
.P
Set queue annotation in queue attributes structure.
.cS
    void
    mos_que_attr_annotation_set(
        /* [in] */         mos_que_attr_annotation_t annotation,
        /* [in,out] */     mos_que_attr_t            que_attributes,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_quemaxsize_get
.P
Return maximum queue size from queue attributes structure.
.cS
    void
    mos_que_attr_quemaxsize_get(
        /* [in] */         mos_que_attr_t            que_attributes,
        /* [out] */        unsigned32 *              que_maxsize,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_quemaxsize_set
.P
Set maximum queue size in queue attributes structure.
.cS
    void
    mos_que_attr_quemaxsize_set(
        /* [in] */         unsigned32                que_maxsize,
        /* [in,out] */     mos_que_attr_t            que_attributes,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_msgmaxsize_get
.P
Return maximum message size on queue from queue attributes structure.
.cS
    void
    mos_que_attr_msgmaxsize_get(
        /* [in] */         mos_que_attr_t            que_attributes,
        /* [out] */        unsigned32 *              msg_maxsize,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_msgmaxsize_set
.P
Set maximum message size on queue in queue attributes structure.
.cS
    void
    mos_que_attr_msgmaxsize_set(
        /* [in] */         unsigned32                msg_maxsize,
        /* [in,out] */     mos_que_attr_t            que_attributes,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_persistence_get
.P
Return queue persistence from queue attributes structure.
.cS
    void
    mos_que_attr_persistence_get(
        /* [in] */         mos_que_attr_t                que_attributes,
        /* [out] */        mos_que_attr_persistence_t *  persistence,
        /* [out] */        error_status_t *              status
    );
.cF
.H 3 mos_que_attr_persistence_set
.P
Set queue persistence in queue attributes structure.
.cS
    void
    mos_que_attr_persistence_set(
        /* [in] */         mos_que_attr_persistence_t    persistence,
        /* [in,out] */     mos_que_attr_t                que_attributes,
        /* [out] */        error_status_t *              status
    );
.cF
.H 3 mos_que_attr_idletimeout_get
.P
Return queue idle timeout in relative time from queue attributes
structure.
.cS
    void
    mos_que_attr_idletimeout_get(
        /* [in] */         mos_que_attr_t            que_attributes,
        /* [out] */        utc_t *                   que_idle_timeout,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_idletimeout_set
.P
Set queue idle timeout in relative time in queue attributes
structure.
.cS
    void
    mos_que_attr_idletimeout_set(
        /* [in] */         utc_t *                   que_idle_timeout,
        /* [in,out] */     mos_que_attr_t            que_attributes,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_allowenq_get
.P
Return boolean that describes whether enqueuing is allowed or
not from queue attributes structure.
.cS
    void
    mos_que_attr_allowenq_get(
        /* [in] */         mos_que_attr_t            que_attributes,
        /* [out] */        boolean *                 allow_enq,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_allowenq_set
.P
Turn enqueuing on or off in queue attributes structure.
.cS
    void
    mos_que_attr_allowenq_set(
        /* [in] */         boolean                   allow_enq,
        /* [in,out] */     mos_que_attr_t            que_attributes,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_allowdeq_get
.P
Return boolean that describes whether dequeuing is allowed or
not from queue attributes structure.
.cS
    void
    mos_que_attr_allowdeq_get(
        /* [in] */         mos_que_attr_t            que_attributes,
        /* [out] */        boolean *                 allow_deq,
        /* [out] */        error_status_t *          status
    );
.cF
.H 3 mos_que_attr_allowdeq_set
.P
Turn dequeuing on or off in queue attributes structure.
.cS
    void
    mos_que_attr_allowdeq_set(
        /* [in] */         boolean                   allow_deq,
        /* [in,out] */     mos_que_attr_t            que_attributes,
        /* [out] */        error_status_t *          status
    );
.cF
.H 2 "Queue Management Utilities"
Client interfaces for Queue Management Utilities to support the
Message Oriented Service Application Programming Interface (MOS-API).
.H 3 mos_que_mgmt_create
.P
Create one queue and commit its queue attributes to be managed
by one queue manager.
.cS
    void
    mos_que_mgmt_create(
        /* [in] */        mos_handle_t          qmgr_handle,
        /* [in] */        mos_rsrc_name_t       name,
        /* [in] */        mos_que_attr_t        que_attributes,
        /* [out] */       mos_handle_t *        que_handle,
        /* [out] */       error_status_t *      status
    );
.cF
.H 3 mos_que_mgmt_delete
.P
Delete one queue managed by the specified queue manager.
.cS
    void
    mos_que_mgmt_delete(
        /* [in] */        mos_que_delete_op_t   flags,
        /* [in,out] */    mos_handle_t *        resource_handle,
        /* [out] */       error_status_t *      status
    );
.cF
.H 3 mos_que_mgmt_move
.P
Move or rename one queue within a Q-mgr or from one Q-mgr
to another.
.cS
    void
    mos_que_mgmt_move(
        /* [in] */        mos_handle_t          dest_qmgr_handle,
        /* [in] */        mos_rsrc_name_t       new_que_name,
        /* [in] */        unsigned32            flags,
        /* [in/out] */    mos_handle_t *        move_que_handle,
        /* [out] */       error_status_t *      status
    );
.cF
.H 3 mos_que_mgmt_quename_list
.P
Return list of queues by name managed by specified Q-mgr.
.cS
    void
    mos_que_mgmt_quename_list(
        /* [in] */        mos_handle_t          resource_handle,
        /* [in] */        unsigned32            space_avail,
        /* [out] */       unsigned32 *          num_returned,
        /* [out, size_is(space_avail), length_is(*num_returned)] */
                          mos_rsrc_name_t       que_name_list[],
        /* [out] */       unsigned32 *          num_left,
        /* [out] */       error_status_t *      status
    );
.cF
.H 3 mos_que_mgmt_msgid_list
.P
Return list of messages by UUID from the specified queue that
satisfy the selection criteria.
.cS
    void
    mos_que_mgmt_msgid_list(
        /* [in] */        mos_handle_t          resource_handle,
        /* [in] */        mos_msg_selfilter_t   msg_selection_filter,
        /* [in] */        unsigned32            space_avail,
        /* [out] */       unsigned32 *          num_returned,
        /* [out, size_is(space_avail), length_is(*num_returned)] */
                          uuid_t                msg_id_list[],
        /* [out] */       unsigned32 *          num_left,
        /* [out] */       error_status_t *      status
    );
.cF
.P
...\" ---------------------------------------------------------------
.H 1 "ADMINISTRATIVE INTERFACE"
.P
Ideally, we would use \*(lBdcecp\*(lE to administer the message queuing system.
There are several obstacles to this, however.
Most critical is that non-source licensees do not have the \*(lBdcecp\*(lE
source.
.P
If \*(lBdcecp\*(lE allowed dynamic loading of customer-defined modules,
this would be a perfect candidate.
Unfortunately, this is not the case.
.P
Instead, we will provide a stand-alone control program in a \*(lBdcecp\*(lE
shell.
In other words, it will be a stripped-down \*(lBdcecp\*(lE that only
manipulates message queue objects.
Customers of this project who have DCE source will be able to integrate
our source into the DCE source with some effort.
.P
The administrative functions described below are written as if
they are incorporated into \*(lBdcecp\*(lE.

.H 2 "dcecp commands"
.P
\*(lBdcecp\*(lE will use the object \*(lBqueue\*(lE for message queues.
The following is a brief list of \*(lBdcecp\*(lE verbs supported.
Following that are details of each command.
What is shown is information \*(lBdcecp\*(lE will display when the
\*(lBhelp\*(lE verb is given.
.dS
  catalog       Returns names of all queues on the specified queue manager.
  create        Creates the specified queue.
  delete        Deletes the specified queue.
  dequeue       Dequeues a message from the specified queue.
  enqueue       Enqueues a message to the specified queue.
  list          Returns a list of messages on the specified queue.
  modify        Changes the attributes of the specified queue.
  move          Moves an entire queue or a queue member to another queue.
  remove        Removes a message from the specified queue.
  show          Returns the attributes of the specified queue.
.dF
.P
Two TCL variables are used by the various commands if the value is
not explicitly set on the command line:
\*(lBmos_dflt_quemgr\*(lE for the default queue manager to use,
and
\*(lBmos_quemgr_group\*(lE for the security group which will be
checked against the groups of which the queue manager is a member.
For all queue operations,
if the queue manager name is not given, the default queue manager is used.
...\" ----
.H 3 "queue catalog"
Returns names of all queues on the specified queue manager.
.dS
  -simplename     List all queues for a queue manager with simple pathnames.
  -group          Checks security group name where named resource is member.
.dF

.H 3 "queue create"
Creates the specified queue.
If the queue name is not given, a name will be generated;
it is a string version of the queue's ID (a UUID).
.dS
  -qmaxlength     Queue maximum size.
  -qmsgmaxsize    Message maximum size on queue.
  -qpersistence   Queue persistence (msgpersistence|volatile|persistent).
  -qallowenq      Queue enqueue service (yes|no).
  -qallowdeq      Queue dequeue service (yes|no).
  -qannotation    Queue annotation.
  -qaliases       Queue alias(es) for the queue name.
  -qidletimeout   Empty queue idle timeout in relative utc format.
  -group          Checks security group name where named resource is member.
  -attribute      Add queue attribute(s) to the queue being created.
.dF

.H 3 "queue delete"
Deletes the specified queue.
.dS
  -force          Force queue deletion even if queue is non-empty.
  -group          Checks security group name where named resource is member.
.dF

.H 3 "queue dequeue"
Dequeues a message from the specified queue.
.dS
  -mid            Message ID criteria (UUID string).
  -mtype          Message type criteria (data|notice).
  -mpriority      Message priority criteria (integer).
  -mdatatype      Message application-specific datatype criteria (UUID string).
  -mprotectlvl    Message end-to-end protection level criteria
                    (default|none|authn|integrity|privacy).
  -msender        Message sender's principal name criteria.
  -mttr           Message ttr (time-to-receive) criteria.
  -deqmode        Dequeue mode (nowaitdeq|deqwait).
  -group          Checks security group name where named resource is member.
  -criteria       List of message selection criteria.
.dF

.H 3 "queue enqueue"
Enqueues a message to the specified queue.
.dS
  -mpriority      Message priority.
  -mtype          Message type (data|notice).
  -mdatatype      Message application-specific datatype (uuid).
  -mopnotice      Notice option(s) (none|enqueue|dequeue) on a message.
                    A combination of notice options are allowed.
  -mqnotice       Notice destination for a notice sent by the messaging system.
  -mgrpnotice     Notice security group name where notice destination is member.
  -mpersistence   Message persistence (volatile|persistent).
  -mexpiration    Message expiration time in absolute utc format.
  -mreceivetime   Message ttr (time to receive) time in absolute utc format.
  -mprotectlvl    Message end-to-end protection level
		    (default|none|authn|integrity|privacy).
  -body           Message body specified as an ASCII text string.
  -enqmode        Enqueue mode (async|nowaitenq|enqwait|deqwait).
  -group          Checks security group name where named resource is member.
  -attribute      Add message attributes(s) to the message being enqueued.
.dF

.H 3 "queue list"
Returns a list of messages on the specified queue.
.dS
  -mid            Message ID criteria (UUID string).
  -mtype          Message type criteria (data|notice).
  -mpriority      Message priority criteria (integer).
  -mdatatype      Message application-specific datatype criteria (UUID string).
  -mprotectlvl    Message end-to-end protection level criteria
                         (default|none|authn|integrity|privacy).
  -msender        Message sender's principal name criteria.
  -mttr           Message ttr (time-to-receive) criteria.
  -group          Checks security group name where named resource is member.
  -criteria       List of message selection criteria.
.dF

.H 3 "queue modify"
Changes the attributes of the specified queue.
.dS
  -qmaxlength     Queue maximum size.
  -qmsgmaxsize    Message maximum size on queue.
  -qpersistence   Queue persistence (msgpersistence|volatile|persistent).
  -qallowenq      Queue enqueue service (yes|no).
  -qallowdeq      Queue dequeue service (yes|no).
  -qannotation    Queue annotation.
  -qaliases       Set a new list of queue alias(es) for the queue name.
  -qidletimeout   Empty queue idle timeout in relative utc format.
  -group          Checks security group name where named resource is member.
  -change         Change attribute(s) on an existing queue.
.dF

.H 3 "queue move"
Moves an entire queue or a queue member to another queue.
.dS
  -to             Destination queue name.
  -referral       Source and destination queue names kept by source qmgr.
  -mid            Message ID to be moved.
  -srcgroup       Checks security group name where source qmgr is member.
  -destgroup      Checks security group name where destination qmgr is member
.dF

.H 3 "queue remove"
Removes a message from the specified queue.
.dS
  -mid            Message ID to be removed.
  -group          Checks security group name where named resource is member.
.dF

.H 3 "queue show"
Returns the attributes of the specified queue.
.dS
  -mid            Returns the attributes of the specified message ID.
  -body           Returns the message body only.
  -all            Returns both the message attributes and message body.
  -group          Checks security group name where named resource is member.
.dF

.H 2 "Access Control Lists"
.P
The following permissions are supported by the management interface:
.VL 8 4
.LI i
queue creation (insert)
.LI m
manage server (enable and disable server, etc)
.LI r
read queue manager attributes and status
.LI c
control (change ACL)
.LI t
test permissions
.LE
.P
The following permissions are supported by the queue data interface:
.VL 8 4
.LI D
delete a queue
.LI M
manage (change) queue attributes
.LI R
read queue attributes
.LI e
enqueue a message
.LI d
dequeue a message
.LI r
read a message's attributes
.LI p
purge (delete) a message, without receiving its contents
.LI c
control (change ACL)
.LI t
test permissions
.LE

.P
...\"=========================================================================
...\" References go here, as an unnumbered heading.
...\" =========================================================================
.HU "REFERENCES"
.P
Note that some of the OSF-RFC's below may be revised after the
present one is published; further, some relevant new RFC's may
be published.  It is incumbent on the consumer of this RFC
to track these developments.
.P
.nr Ls 1 \" Blank line between items in reference list.
.VL 12 0
.LI "[RFC\ 95]"
Guidry, Michael, Estrem,
\*(qBDCE/NEXT: REQUIREMENTS SUMMARY\*(qE,
OSF-RFC 95.0, August 1996.
.LI "[RFC\ Index]"
W. Tuvell,
\*(qBIndex to OSF-RFC's\*(qE,
OSF-RFC Index, \*(eBLatest version\*(eE.
.LE
.P
...\" =========================================================================
...\" Author's address goes here, as unnumbered heading, at end of doc.
...\" =========================================================================
.ne 3+5
.HU "AUTHORS' ADDRESS"
.P
.tl $John Bowe$$Email: bowe@osf.org$
.tl $The Open Group$$Telephone: +1-617-621-7269$
.tl $11 Cambridge Center$$$
.tl $Cambridge, MA 02142-1405$$$
.tl $USA$$$
.P
.tl $Julie Salamone$$Email: salamone@osf.org$
.tl $The Open Group$$Telephone: +1-617-621-8707$
.tl $11 Cambridge Center$$$
.tl $Cambridge, MA 02142-1405$$$
.tl $USA$$$
...\" =========================================================================
...\" Done!
...\" =========================================================================
