#!/bin/ksh
#
#  @OSF_COPYRIGHT@
#  COPYRIGHT NOTICE
#  Copyright (c) 1990, 1991, 1992, 1993, 1996 Open Software Foundation, Inc.
#  ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
#  src directory for the full copyright text.
# 
# HISTORY
# $Log: sec.functions,v $
# Revision 1.1.24.2  1996/03/11  02:48:26  marty
# 	Update OSF copyright years
# 	[1996/03/10  20:09:15  marty]
#
# Revision 1.1.24.1  1995/12/11  22:46:28  root
# 	Submit OSF/DCE 1.2.1
# 
# 	HP revision /main/HPDCE02/jrr_1.2_mothra/1  1995/11/29  20:51 UTC  bell_d
# 	Many changes from others.
# 
# 	HP revision /main/HPDCE02/4  1994/10/18  19:47 UTC  bissen
# 	Merge Hpdce02_04 to HPDCE02 branch
# 	[1995/12/11  22:22:03  root]
# 
# Revision 1.1.21.10  1994/10/05  21:00:47  hester
# 	final updates for eraobj001 acl test
# 	[1994/10/05  20:58:31  hester]
# 
# Revision 1.1.21.9  1994/09/24  17:28:52  hester
# 	fix attr name
# 	[1994/09/23  20:08:58  hester]
# 
# Revision 1.1.21.8  1994/09/20  21:52:07  hester
# 	backout changes due to ERA rgy_edit updates
# 	[1994/09/20  21:33:25  hester]
# 
# 	HP revision /main/HPDCE02/3  1994/09/27  18:18 UTC  bissen
# 	merge in changes
# 
# Revision 1.1.21.7  1994/08/25  21:09:43  hester
# 	updates to xattrschema and latest dcecp functionality
# 	[1994/08/25  20:13:33  hester]
# 
# 	HP revision /main/HPDCE02/2  1994/08/23  15:00 UTC  bissen
# 	Merge from Hpdce02_01
# 
# Revision 1.1.21.6  1994/07/22  17:30:56  hester
# 	minor cleanup of syntax, etc.
# 	[1994/06/30  16:19:57  hester]
# 
# 	first rev of updates for ERA tests
# 	[1994/06/28  18:49:29  hester]
# 
# 	HP revision /main/HPDCE02/1  1994/07/05  15:30 UTC  bissen
# 	Merge hpdce02 (DCE 1.1 beta) and HPDCE01 into HPDCE02
# 
# 	HP revision /main/HPDCE01/1  1994/01/28  22:08  bissen
# 	merge kk and hpdce01
# 
# Revision 1.1.21.5  1994/05/20  19:30:58  pellis
# 	Updated to reflect changed rgy_edit messages.
# 	[1994/05/20  19:30:06  pellis]
# 
# Revision 1.1.21.4  1994/03/10  23:15:42  pellis
# 	Added extra carriage returns in change_org_management_info and
# 	change_person_id to account for a change made to rgy_edit for the
# 	update attributes question.
# 	[1994/03/10  23:15:16  pellis]
# 
# Revision 1.1.21.3  1994/03/04  22:19:51  pellis
# 	Added an extra carriage return to set_policies to account for a change
# 	made to rgy_edit for the update attributes question.
# 	[1994/03/04  22:17:15  pellis]
# 
# Revision 1.1.21.2  1994/02/03  20:56:50  pellis
# 	Fixed test to run resestr tests on remote machines at the same time.
# 	[1994/02/03  20:56:08  pellis]
# 
# Revision 1.1.21.1  1993/12/27  15:52:06  pellis
# 	Changed account and password lifespans from days to minutes.
# 	[1993/12/27  15:51:22  pellis]
# 
# Revision 1.1.19.8  1993/10/27  14:53:30  cmckeen
# 	Fixed error messages in add_account and delete_account
# 	[1993/10/27  14:52:59  cmckeen]
# 
# Revision 1.1.19.7  1993/10/20  14:47:40  ohara
# 	svr4 port 0t 8596
# 	[1993/10/19  20:41:16  ohara]
# 
# Revision 1.1.19.6  1993/10/15  21:40:11  pellis
# 	Fixed remove_KRB5CCNAME function to parse filename correctly.
# 	[1993/10/15  21:39:48  pellis]
# 
# Revision 1.1.19.5  1993/10/14  16:12:36  qbarry
# 	Merged with changes from 1.1.19.4
# 	[1993/10/14  16:12:26  qbarry]
# 
# 	Modified SEC.FUNCTIONS by removing function CHECK_STATUS.  It was a
# 	complete no-op and was responsible for DCESESTR not being able to
# 	detect RESESTR errors.  Replaced it with code in DCESESTR itself.
# 	Also removed unused function ADD_OBJECTS_ACT.
# 	[1993/10/14  16:07:49  qbarry]
# 
# Revision 1.1.19.4  1993/10/13  21:21:05  pellis
# 	Modified remove_KRB5CCNAME for dcesepol.
# 	[1993/10/13  21:20:49  pellis]
# 
# Revision 1.1.19.3  1993/09/24  17:00:29  qbarry
# 	Corrected a bug in VERIFY_MACHINES that was causing it to take
# 	multiple machine names and treat them a single name.  This was keeping
# 	DCESESTR from running with more than 1 -m option.
# 	[1993/09/24  17:00:01  qbarry]
# 
# Revision 1.1.19.2  1993/09/09  14:30:46  pellis
# 	Merged with changes from 1.1.19.1
# 	[1993/09/09  14:30:36  pellis]
# 
# 	Made major changes to remote_login for dcesepol.
# 	[1993/09/09  13:58:20  pellis]
# 
# Revision 1.1.19.1  1993/08/31  21:17:04  qbarry
# 	rlogin_to_machine no longer requires that the remote machine have the
# 	ROOT default shell be KSH.  (However KSH must still be available there!)
# 	[1993/08/31  21:11:46  qbarry]
# 
# Revision 1.1.16.7  1993/08/26  22:05:03  pellis
# 	Major changes to remote_login to allow a rewrite of dcesepol so
# 	that it works correctly.
# 	[1993/08/26  22:03:55  pellis]
# 
# Revision 1.1.16.6  1993/08/16  13:46:10  cmckeen
# 	Corrected a syntax error in verify_machines.
# 	[1993/08/16  13:45:03  cmckeen]
# 
# Revision 1.1.16.5  1993/08/13  18:48:45  cmckeen
# 	More changes made to reflect the new install tree structure
# 	[1993/08/13  18:21:34  cmckeen]
# 
# Revision 1.1.16.4  1993/08/11  17:43:45  pellis
# 	Merged with final version of test from DCE 1.0.2.
# 	[1993/08/11  17:40:00  pellis]
# 
# Revision 1.1.16.3  1993/08/02  17:31:03  cmckeen
# 	Changes made to reflect the new install tree
# 	[1993/08/02  17:17:36  cmckeen]
# 
# Revision 1.1.16.2  1993/07/28  19:36:00  cmckeen
# 	HP's TET'ized version of the system tests
# 	[1993/07/28  13:54:06  cmckeen]
# 
# Revision 1.1.12.3  1993/05/27  18:55:12  eheller
# 	*** empty log message ***
# 
# Revision 1.1.12.2  1993/05/27  14:06:43  eheller
# 	*** empty log message ***
# 	[1993/05/26  17:15:59  eheller]
# 
# Revision 1.1.5.3  1993/04/28  18:54:14  eheller
# 	*** empty log message ***
# 	[1993/04/28  18:52:44  eheller]
# 
# Revision 1.1.5.2  1993/04/23  13:52:01  eheller
# 	Merged time looping changes
# 	[1993/04/23  13:25:24  eheller]
# 
# 	Merged Hp_dce1_0_1 changes
# 	[1993/04/16  17:14:08  eheller]
# 
# 	Changed existing entry in password override file from a fatal
# 	error to a warning.
# 	[1992/07/17  20:30:34  pellis]
# 
# 	Changed override entry to have only six field separators (i.e. :) and
# 	changed remote_login to do a "dce_login -c" to envoke the password over-
# 	ride code in dce_login.
# 	[1992/07/16  15:48:27  pellis]
# 
# 	Made several changes to checks for /tmp on rsh dce_login to
# 	/usr/opt/dcelocal/var/security/creds.
# 	[1992/07/14  20:16:48  pellis]
# 
# 	Sync with shared sbox
# 	[1992/05/22  20:10:33  eperkins]
# 
# Revision 1.1.1.5  1993/03/11  22:14:37  osfrcs
# 	    Loading drop DCE1_0_2B18
# 
# Revision 1.1.3.10  1993/03/04  19:36:54  bissen
# 	Fixed functions called by resestr to be hostname specific.
# 	This allows for multiple instances of dcesestr to be running.
# 	Also modified test_fail variable when function failed.
# 	[1993/03/04  19:36:16  bissen]
# 	Revision 1.1.10.3  1993/02/11  17:19:25  pellis
# 	Changes made to make dcesestr function correctly.
# 	[1993/02/11  17:10:02  pellis]
# 
# Revision 1.1.10.2  1993/02/05  15:25:27  cjd
# 	Embedded copyright notice
# 	[1993/02/05  14:46:31  cjd]
# 
# Revision 1.1.8.2  1993/02/04  22:17:24  cjd
# 	Embedded copyright notice
# 
# Revision 1.1.3.9  1993/02/02  14:21:34  mgm
# 	Replaced remove_KRB5CCNAME with kdestroy where appropriate
# 	[1993/02/02  14:19:38  mgm]
# 	Revision 1.1.3.8  1992/11/25  21:44:10  mgm
# 	Changed neg_account_auth_info: need an extra return before
# 	"v $1 -f' to handle new question if error occurs.
# 	Changed verify_existence "Unable" to: verify_existence "Not authorized"
# 	because error message was changed in rgy_edit.
# 	Changed egrep line in 'verify_existence' to be case insensitive.
# 	[1992/11/25  21:40:52  mgm]
# 	Revision 1.1.3.6  1992/11/12  15:03:38  mgm
# 	Fixed password override again!
# 	[1992/11/12  15:03:09  mgm]
# 	Revision 1.1.3.7  1992/11/13  19:28:30  mgm
# 	Must have -c in remote_login to enable passwd_override.
# 	Added |grep -v to remsh command to fix remsh to oneself.
# 	[1992/11/13  19:27:46  mgm]
# 	Revision 1.1.3.5  1992/11/03  14:32:47  mgm
# 	Ported to TET
# 	[1992/11/03  14:32:13  mgm]
# 	Revision 1.1.3.4  1992/09/10  16:31:55  macgregor_m
# 	Changed create_override to correct syntax
# 	[1992/09/10  16:31:20  macgregor_m]
# 
# Revision 1.1.3.3  1992/09/09  13:18:40  macgregor_m
# 	re-added /bin/ksh
# 	[1992/09/09  13:17:48  macgregor_m]
# 
# Revision 1.1.3.2  1992/07/24  14:37:06  macgregor_m
# 	Ported to HPUX. Changed ping syntax, changed rsh to
# 	remsh and /bin/sh to /bin/ksh.
# 	[1992/07/24  14:36:24  macgregor_m]
# 
# Revision 1.1.1.2  1992/06/16  03:11:13  root
# 	    Loading drop Dce1_0_1b19
# 
# $EndLog$

# FILE: 71		DATE: 91/12/07		VERSION: 1.3
#			REVISED:92/3/12
# File contains a list of functions which are used by the three test
# programs written for security.  Not all functions are used by all
# the tests.
#
# RETURN CODES:
# 	1: Error occurred during setup or execution of test which makes
#	   it impossible to continue the test until problem is fixed.
#		EX: rgy_edit did not work properly, or cu is unavailable.
#	2: The test ran properly, but did not produce the expected result.
#		EX: Adding a person using rgy_edit ran successfully, but
#		    the person could not be found in the database.
#	3: The expected result was produced, but some other check on the
#	   database failed.
#		EX: When changing a group name, the new group name exists
#		    in the registry along with the old group name which 
#		    didn't get overwritten as expected.
#		EX: The test ran successfully, but some of the resulting
#		    data is missing.
#	4: Cleanup errors.  After successful completion of test, the program
#	   was unable to cleanup after itself.
#
#	6/30/92		Mary MacGregor	Changed /bin/sh to /bin/ksh
#					Changed rsh to remsh
#					Added correct ping for OSTYPE = HP-UX
#	11/2/92		Mary MacGregor	Ported to TET
#	11/13/92        Mary MacGregor  Must have -c in remote_login to enable
#               	                passwd_override.
#                                       Added |grep -v to remsh command to
#                                       fix remsh to oneself
#	3/4/93		Bob Bissen	Fixed functions used in resestr to
#					use hostname for account info
#
# To exit TET gracefully: Delete test purposes.

del_test_purp()
{
	for test_purp in $test_purp_list
	do
		tet_delete $test_purp "FAILURE...$test_purp() deleted."
	done
}	# end del_test_purp()

#===============================================================================
# Function:     dce_auth <principal> <password>
# Purpose:      To authenticate the cell by dce_login <principal>
#===============================================================================

dce_auth() {
	PRINCIPAL="${1}"
	PASSWORD="${2}"
	tet_infoline "Attempting to authenticate the cell by $PRINCIPAL"

	KRB5CCNAME=`dce_login_noexec $PRINCIPAL $PASSWORD` 1>/dev/null 2>&1
	check_return "$?" "ERROR: Unable to authenticate cell by $PRINCIPAL in dce_auth" \
			"The cell is now authenticated by $PRINCIPAL"
	export KRB5CCNAME
} # End of function dce_auth

check_KRB5CCNAME()
{
	STAT_CODE="${1}"
	PRINCIPAL="${2}"

        if [ $STAT_CODE -eq 0 ]
        then
                tet_infoline "$PRINCIPAL authenticated ticket has been removed"
        else
                tet_infoline "ERROR: Unable to remove authenticated ticket for $PRINCIPAL in check_KRB5CCNAME"
		fail=1
        fi
}	# end check_KRB5CCNAME
#===============================================================================
# Function:	check_return <Integer value(Return Code)> <Error Statement>
# Purpose:	Check return code and exit if value is other than 0.
#		
#===============================================================================
check_return() {
	if [ "${1}" != "0" ]
	then
		tet_infoline "${2}"	
		fail=1
		test_fail=1
	else
		if [ "${3}" != "" ]
		then
			tet_infoline "${3}"
		fi
	fi
} # End of function check_return

#===============================================================================
# Function:     check_return_noexit <Integer value(Return Code)> <Error
#               Statement>
# Purpose:      Check return code and issue fail message if value is other
#               than 0, but don't exit.
#
#===============================================================================
check_return_noexit() {
	if [ "${1}" != "0" ]
	then
		# If return code is not zero, print error message
		#
		tet_infoline "${2}"	
		fail=0
		test_fail=1
	else
		if [ "${3}" != "" ]
		then
			tet_infoline "${3}"
		fi
	fi
} # End of function check_return_noexit

#===============================================================================
# Function:     check_neg_return <Integer value(Return Code)> <Error Statement>
# Purpose:      Check return code and exit if value is 0.
#
#===============================================================================
check_neg_return() {
        if [ "${1}" = "0" ]
        then
                # ASSUMPTION: If this function is called, then execution
                #               of program will be stopped.
                # If return code is not zero, print error message and exit
                #
                tet_infoline "${2}"
		fail=1
        fi
} # End of function check_neg_return

#===============================================================================
# Function:	add_person name_of_person UNIX_id_of_person full_name
# Purpose:	Create a file which contains the commands to add a person
#		to the registry file.  Execute rgy_edit the batch command
#		file and verify that the user has been entered properly.
#===============================================================================
add_person() {

	# ASSUMPTION: The current user is not in the registry.  This 
	#		function is called after state_of_rgy which
	#		checks for existing users.
	#
	tet_infoline "Attempting to add person ${1} to registry"
	cat << EOF > ${RGY_INPUT}
do p
add ${1} ${2} -f "${3}"
v ${1} -f
q
EOF
	# Execute file using the rgy_edit command.  Send the output to file 
	#	${RGY_OUTPUT}
	execute_rgy
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Execute_rgy failed in add_person"
		fail=1
		test_fail=1
		return 
	fi
	# Check output file for proper execution of command.
	# Function verify_existence checks output file for existence of a 
	# person and return error code.
	# ASSUMPTION: Syntax of output of rgy_edit on a "view" command
	#		is <Name of Person> *<Unix ID of person>
	#
	cat ${RGY_OUTPUT} | verify_existence "Full name: *${3}" > /dev/null
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Person ${1} was not entered in registry in add_person"
		fail=1
		test_fail=1
		return 1
	fi
	# report that person has been added properly.
	#
	tet_infoline "Person ${1} has been ADDED to the registry."
	return 0

} # End of function add_person

#===============================================================================
# Function:     add_neg_person name_of_person UNIX_id_of_person full_name
# Purpose:      Create a file which contains the commands to add a person
#               to the registry file.  Execute rgy_edit the batch command
#               file and verify that the user has not been entered properly.
#===============================================================================
add_neg_person() {

        # Create stdin batch file for adding user.
        # ASSUMPTION: The current user is not in the registry.  This
        #               function is called after state_of_rgy which
        #               checks for existing users.
        #
        tet_infoline "Attempting to add person ${1} to registry without permission"
        cat << EOF > ${RGY_INPUT}
do p
add ${1} ${2} -f "${3}"
v ${1} -f
q
EOF
        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
		tet_infoline "ERROR: Execute_rgy failed in add_neg_person"
		fail=1
                return 1
        fi

        # Check output file for proper execution of command.
        # Function verify_existence checks output file for existence of a
        # person and return error code.
        # ASSUMPTION: Syntax of output of rgy_edit on a "view" command
        #               is <Name of Person> *<Unix ID of person>
        #
        cat ${RGY_OUTPUT} | verify_existence "Cannot retrieve entry for $1" > /dev/null
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Person ${1} was entered in registry unexpectedly in add_neg_person"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that person has been added properly.
        #
        tet_infoline "Person ${1} has NOT been added to the registry as EXPECTED."
        return 0

} # End of function add_neg_person

#===============================================================================
# Function:     delete_person <name_of_person>
# Purpose:      Create a file which contains the commands to add a person
#               to the registry file.  Execute rgy_edit the batch command
#               file and verify that the user has been delete properly.
#===============================================================================
delete_person() {

        # ASSUMPTION: The current user is not in the registry.  This
        #               function is called after state_of_rgy which
        #               checks for existing users.
        #
        tet_infoline "Attempting to delete person ${1} from registry"
        cat << EOF > ${RGY_INPUT}
do p
del ${1} 
v ${1} 
q
EOF
        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in delete_person"
		fail=1
                return 1
        fi
        # Check output file for proper execution of command.
        # Function verify_existence checks output file for existence of a
        # person and return error code.
        #
        cat ${RGY_OUTPUT} | verify_existence "Cannot retrieve entry" > /dev/null
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Person ${1} was not deleted from registry as expected in delete_person"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi
        # Call function to report that person has been deleted properly.
        #
        tet_infoline "Person ${1} has been DELETED from the registry."
        return 0

} # End of function delete_person

#===============================================================================
# Function:     delete_neg_person <name_of_person> 
# Purpose:      Create a file which contains the commands to add a person
#               to the registry file.  Execute rgy_edit the batch command
#               file and verify that the user has not been delete properly.
#===============================================================================
delete_neg_person() {

        # ASSUMPTION: The current user is not in the registry.  This
        #               function is called after state_of_rgy which
        #               checks for existing users.
        #
        tet_infoline "Attempting to delete person ${1} from registry without permissions"
        cat << EOF > ${RGY_INPUT}
do p
del ${1} 
v ${1} 
q
EOF
        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in delete_neg_person"
		fail=1
                return 1
        fi
        # Check output file for proper execution of command.
        # Function verify_existence checks output file for existence of a
        # person and return error code.
        #
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Person ${1} was deleted from registry unexpectedly in delete_neg_person"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi
        # Call function to report that person has not been deleted properly.
        #
        tet_infoline "Person ${1} has NOT been delete from the registry as EXPECTED."
        return 0

} # End of function delete_neg_person

#===============================================================================
# Function:	add_alias name_of_alias UNIX_ID
# Purpose:	Add an alias based on input of name of alias and UNIX_ID.
#		It is assumed that a person with the same UNIX_ID already
#		exists.
#===============================================================================
add_alias() {
	
	# Create stdin batch file for adding user.
	# ASSUMPTION: Alias requested doesn't already exist, and the UNIX
	#		ID used already exists in registry.
	#
	tet_infoline "Attempting to add alias ${1} to registry"
	cat << EOF > ${RGY_INPUT}
do p
add ${1} ${2} -al
v ${1}
q
EOF

	# Execute file using the rgy_edit command.  Send the output to file 
	#	${RGY_OUTPUT}
	execute_rgy
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Execute_rgy failed in add_alias"
		fail=1
		test_fail=1
		return 1
	fi

	# Check output file for proper execution of command.
	# Function verify_existence checks output file for existence of a 
	# person and return error code.
	#
	cat ${RGY_OUTPUT} | verify_existence "${1} *${2}" > /dev/null
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Alias ${1} was not entered in registry as expected in add_alias"
                cat ${RGY_OUTPUT}
		fail=1
		test_fail=1
		return 2
	fi

	# Call function to report that the person has been added properly.
	#
	tet_infoline "Alias ${1} has been added to the registry."
	return 0

} # End of function add_alias
#===============================================================================
# Function:	add_account <name_of_person> <name_of_group> <name_of_org>
#		<password> <auth_password> <home_dir> <shell> <psswd_valid>
# Purpose:	Adds an account for the person requested, group and 
#		organization requested.  Note that the default password
#		is used for all accounts.
#		
#===============================================================================
add_account() {
	# ASSUMPTION: Account doesn't already exist in registry, and 
	#		the person, group and organization do exist.
	#
	tet_infoline "Attempting to add account for person ${1}"
	cat << EOF > ${RGY_INPUT}
do a
add ${1} -g ${2} -o ${3} -pw ${4} -mp ${5} -h ${7} -s ${8} -pv ${6} 
v ${1}
q
EOF

	# Execute file using the rgy_edit command.  Send the output to file 
	#	${RGY_OUTPUT}
	execute_rgy 
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Execute_rgy failed in add_account"
		fail=1
		test_fail=1
		return 1
	fi

	# Check output file for proper execution of command.
	# Function verify_existence checks output file for existence of the
	# account and return error code.
	#
	cat ${RGY_OUTPUT} | verify_existence "${1} *\[${2} *${3}\]" > /dev/null

	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Account for ${1} was not entered as expected in add_account"
                cat ${RGY_OUTPUT}
		fail=1
		test_fail=1
		return 2
	fi

	# Call function to report that the person has been added properly.
	#
	tet_infoline "Account ${1} has been ADDED to the registry."
	return 0

} # End of function add_account.	

#===============================================================================
# Function:     add_neg_account <name_of_person> <name_of_group> <name_of_org>
#               <password> <auth_password> <home_dir> <shell> <psswd_valid>
# Purpose:      Adds an account for the person requested without permission.
#
#===============================================================================
add_neg_account() {
        # ASSUMPTION: Account doesn't already exist in registry, and
        #               the person, group and organization do exist.
        #
        tet_infoline "Attempting to add account for person ${1} without permission"
        cat << EOF > ${RGY_INPUT}
do a
add ${1} -g ${2} -o ${3} -pw ${4} -mp ${5} -h ${7} -s ${8} -pv ${6}
v ${1}
q
EOF

        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in add_neg_account"
		fail=1
                return 1
        fi

        # Check output file for proper execution of command.
        # Function verify_existence checks output file for existence of the
        # account and return error code.
        #

        cat ${RGY_OUTPUT} | verify_existence "Cannot retrieve any matching entries for ${1}" > /dev/null

        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Account for ${1} was entered unexpectedly in add_neg_account"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the person has been added properly.
        #
        tet_infoline "Account ${1} has NOT been added to the registry as EXPECTED."
        return 0

} # End of function add_neg_account.

#===============================================================================
# Function:     delete_account <name_of_person> <name_of_group> <name_of_org>
# Purpose:      Delete an account for the person requested, group and
#               organization requested.
#===============================================================================
delete_account() {
        # ASSUMPTION: Account already exist in registry
        #
        tet_infoline "Attempting to delete account for person ${1}"
        cat << EOF > ${RGY_INPUT}
do a
del -p ${1} -g ${2} -o ${3} 
v ${1}
q
EOF

        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in delete_account"
		fail=1
                return 1
        fi

        # Check output file for proper execution of command.
        # Function verify_existence checks output file for nonexistence of the
        # account and return error code.
        #
        cat ${RGY_OUTPUT} | verify_existence "Cannot retrieve" > /dev/null

        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Account for ${1} was not deleted in delete_account"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the person has been added properly.
        #
        tet_infoline "Account ${1} has been DELETED from the registry."
        return 0

} # End of function delete_account.

#===============================================================================
# Function:     delete_neg_account <name_of_person> <name_of_group> <name_of_org>
# Purpose:      Delete an account for the person requested, group and
#               organization requested without permissions.
#===============================================================================
delete_neg_account() {
        # ASSUMPTION: Account already exist in registry
        #
        tet_infoline "Attempting to delete account for person ${1} without permissions"
        cat << EOF > ${RGY_INPUT}
do a
del -p ${1} -g ${2} -o ${3} 
v ${1}
q
EOF

        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in delete_neg_account"
		fail=1
                return 1
        fi

        # Check output file for proper execution of command.
        # Function verify_existence checks output file for nonauthorization 
        #
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null

        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Account for ${1} was DELETED unexpectedly in delete_neg_account"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the person has been added properly.
        #
        tet_infoline "Account ${1} has NOT deleted from the registry as EXPECTED."
        return 0

} # End of function delete_neg_account.

#===============================================================================
# Function:	add_group name_of_group UNIX_id
# Purpose:	Adds a group to the registry file.
#		
#===============================================================================
add_group() {

	# ASSUMPTION: Group doesn't already exist in database	
	#
	tet_infoline "Attempting to add group ${1}"

	# Create stdin batch file for adding user.
	# 
	cat << EOF > ${RGY_INPUT}
do g
add ${1} ${2} -f "none"
v ${1} -f
q
EOF
	# Execute file using the rgy_edit command.  Send the output to file 
	#	${RGY_OUTPUT}
	execute_rgy 
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Execute_rgy failed in add_group"
		fail=1
		test_fail=1
		return 1
	fi
	# Check output file for proper execution of command.
	# Function verify_existence checks output file for existence of a 
	# group and return error code.
	#
	cat ${RGY_OUTPUT} | verify_existence "Full name:  none" > /dev/null
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Group ${1} was not entered as expected in add_group"
                cat ${RGY_OUTPUT}
		fail=1
		test_fail=1
		return 2
	fi
	# Call function to report that the person has been added properly.
	#
	tet_infoline "Group ${1} has been ADDED to the registry."
	return 0
} # End of function add_group

#===============================================================================
# Function:     add_neg_group name_of_group UNIX_id
# Purpose:      Attempts to add a group to the registry file without permission.
#
#===============================================================================
add_neg_group() {

        # ASSUMPTION: Group doesn't already exist in database
        #
        tet_infoline "Attempting to add group ${1} without permission"

        # Create stdin batch file for adding user.
        #
        cat << EOF > ${RGY_INPUT}
do g
add ${1} ${2} -f "none"
v ${1}
q
EOF

        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in add_neg_group"
		fail=1
                return 1
        fi

        # Check output file for proper execution of command.
        # Function verify_existence checks output file for existence of a
        # group and return error code.
        #
        cat ${RGY_OUTPUT} | verify_existence "Cannot retrieve entry for ${1}" > /dev/null
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Group ${1} was entered unexpectedly in add_neg_group"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the person has been added properly.
        #
        tet_infoline "Group ${1} has NOT been added to the registry as EXPECTED."
        return 0

} # End of function add_neg_group

#===============================================================================
# Function:     delete_group <name_of_group>
# Purpose:      Create a file which contains the commands to delete a group
#               to the registry file.  Execute rgy_edit the batch command
#               file and verify that the user has been delete properly.
#===============================================================================
delete_group() {

        # ASSUMPTION: The current user is not in the registry.  This
        #               function is called after state_of_rgy which
        #               checks for existing users.
        #
        tet_infoline "Attempting to delete group ${1} from registry"
        cat << EOF > ${RGY_INPUT}
do g
del ${1}
v ${1}
q
EOF
        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in delete_group"
		fail=1
                return 1
        fi
        # Check output file for proper execution of command.
        # Function verify_existence checks output file for existence of a
        # person and return error code.
        #
        cat ${RGY_OUTPUT} | verify_existence "Cannot retrieve entry" > /dev/null
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Group ${1} was not delete from registry as expected in delete_group"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi
        # Call function to report that person has been deleted properly.
        #
        tet_infoline "Group ${1} has been DELETED from the registry."
        return 0

} # End of function delete_group

#===============================================================================
# Function:     delete_neg_group <name_of_group>
# Purpose:      Create a file which contains the commands to delete a group
#               to the registry file.  Execute rgy_edit the batch command
#               file and verify that the user has not been delete properly.
#===============================================================================
delete_neg_group() {

        # ASSUMPTION: The current user is not in the registry.  This
        #               function is called after state_of_rgy which
        #               checks for existing users.
        #
        tet_infoline "Attempting to delete group ${1} from registry without permissions"
        cat << EOF > ${RGY_INPUT}
do g
del ${1}
v ${1}
q
EOF
        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in delete_neg_group"
		fail=1
                return 1
        fi
        # Check output file for proper execution of command.
        # Function verify_existence checks output file for existence of a
        # person and return error code.
        #
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Group ${1} was deleted from registry unexpectedly in delete_neg_group"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi
        # Call function to report that person has not been deleted properly.
        #
        tet_infoline "Group ${1} has NOT been delete from the registry as EXPECTED."
        return 0

} # End of function delete_neg_group

#===============================================================================
# Function:	add_org name_of_org UNIX_id
# Purpose:	Add specified organization to registry file
#		
#===============================================================================
add_org() {

	# ASSUMPTION: Organization doesn't already exist in database.
	#	
	tet_infoline "Attempting to add organization ${1}"
	# Create stdin batch file for adding user.
	# 
	cat << EOF > ${RGY_INPUT}
do o
add ${1} ${2} -f "none"
v ${1} -f
q
EOF

	# Execute file using the rgy_edit command.  Send the output to file 
	#	${RGY_OUTPUT}
	execute_rgy
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Execute_rgy failed in add_org"
		fail=1
		test_fail=1
		return 1
	fi

	# Check output file for proper execution of command.
	# Function verify_existence checks output file for existence of a 
	# organization and return error code.
	#
	cat ${RGY_OUTPUT} | verify_existence "Full name:  none" > /dev/null
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Organization ${1} was not entered as expected in add_org"
                cat ${RGY_OUTPUT}
		fail=1
		test_fail=1
		return 2
	fi

	# Call function to report that the person has been added properly.
	#
	tet_infoline "Organization ${1} has been ADDED to the registry."
	return 0

} # End of function add_org

#===============================================================================
# Function:     add_neg_org name_of_org UNIX_id
# Purpose:      Add specified organization to registry file without permission
#
#===============================================================================
add_neg_org() {

        # ASSUMPTION: Organization doesn't already exist in database.
        #
        tet_infoline "Attempting to add organization ${1} without permission"
        # Create stdin batch file for adding user.
        #
        cat << EOF > ${RGY_INPUT}
do o
add ${1} ${2} -f "none"
v ${1}
q
EOF

        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in add_neg_org"
		fail=1
                return 1
        fi

        # Check output file for proper execution of command.
        # Function verify_existence checks output file for existence of a
        # organization and return error code.
        #
        cat ${RGY_OUTPUT} | verify_existence "Cannot retrieve entry for ${1}" > /dev/null
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Organization ${1} was entered unexpectedly add_neg_org"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the person has been added properly.
        #
        tet_infoline "Organization ${1} has NOT been added to the registry as EXPECTED."
        return 0

} # End of function add_neg_org

#===============================================================================
# Function:     delete_org <name_of_org>
# Purpose:      Create a file which contains the commands to delete a organization
#               to the registry file.  Execute rgy_edit the batch command
#               file and verify that the user has been delete properly.
#===============================================================================
delete_org() {

        # ASSUMPTION: The current user is not in the registry.  This
        #               function is called after state_of_rgy which
        #               checks for existing users.
        #
        tet_infoline "Attempting to delete organization ${1} from registry"
        cat << EOF > ${RGY_INPUT}
do o
del ${1}
v ${1}
q
EOF
        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in delete_org"
		fail=1
                return 1
        fi
        # Check output file for proper execution of command.
        # Function verify_existence checks output file for existence of a
        # person and return error code.
        #
        cat ${RGY_OUTPUT} | verify_existence "Cannot retrieve entry" > /dev/null
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Organization ${1} was not delete from registry as expected delete_org"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi
        # Call function to report that person has been deleted properly.
        #
        tet_infoline "Organization ${1} has been DELETED from the registry."
        return 0

} # End of function delete_org

#===============================================================================
# Function:     delete_neg_org <name_of_org>
# Purpose:      Create a file which contains the commands to delete a organization
#               to the registry file.  Execute rgy_edit the batch command
#               file and verify that the user has not been delete properly.
#===============================================================================
delete_neg_org() {

        # ASSUMPTION: The current user is not in the registry.  This
        #               function is called after state_of_rgy which
        #               checks for existing users.
        #
        tet_infoline "Attempting to delete organization ${1} from registry without permissions"
        cat << EOF > ${RGY_INPUT}
do o
del ${1}
v ${1}
q
EOF
        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in delete_neg_org"
		fail=1
                return 1
        fi
        # Check output file for proper execution of command.
        # Function verify_existence checks output file for existence of a
        # person and return error code.
        #
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Organization ${1} was deleted from registry unexpectedly in delete_neg_org"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi
        # Call function to report that person has not been deleted properly.
        #
        tet_infoline "Organization ${1} has NOT been delete from the registry as EXPECTED."
        return 0

} # End of function delete_neg_org

#===============================================================================
# Function:	verify_existence string_to_match
# Purpose:	Checks the output of rgy_edit view command to verify that
#		the user/group/org with the UNIX ID provided exists in 
#		the registry.
#===============================================================================
verify_existence() {

	MATCH_STRING="${1}"
	# Search for member with specified ID in output file.
	#
	egrep -i "${MATCH_STRING}" 
	return "$?"

} # End of verify_existence()
	
#===============================================================================
# Function:	state_of_rgy -p <persons> -a <aliases> -g <groups> 
#		-o <organizations>
# Purpose:	Outputs data concerning the current state of the registry
#		file.  It makes sure that the members listed are not already 
#		in the registry.  The list can contain any number of 
#		persons, groups, aliases or organizations.
#
#===============================================================================
state_of_rgy() {
#set -x
	while [ -n "${1}" ]
	do
	    case "${1}" in

		-p) shift;
		    PERSONS="`echo $1 | sed 's/ /|/g'`"
		    shift;;

		-a) shift;
		    ALIASES=`echo $1 | sed 's/ /|/g'`
		    shift;;

		-g) shift;
		    GROUPS=`echo $1 | sed 's/ /|/g'`
		    shift;;

		-o) shift;
		    ORGS=`echo $1 | sed 's/ /|/g'`
		    shift;;

	    esac
	done

	tet_infoline "Determining the current state of registry"

	# Make sure that files ${RGY_INPUT} and ${RGY_OUTPUT} can be
	#  	created properly.
	#
	touch ${RGY_INPUT}
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Unable to create file ${RGY_INPUT} in state_of_rgy"
		fail=1
		return 1
	fi

	touch ${RGY_OUTPUT}
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Unable to create file ${RGY_INPUT} in state_of_rgy"
		fail=1
		return 1
	fi
	
	# Create stdin batch file for determining current state of registry.
	# 
	cat << EOF > ${RGY_INPUT}
do p
v
do g
v
do o
v
do a
v
q
EOF

	# Execute rgy_edit with input file.
	#
	execute_rgy
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Execute_rgy failed in state_of_rgy"
		fail=1
		return 1
	fi

	REPORT=""
	if [ -n "${PERSONS}" ]
	then
		tet_infoline "Attempting to verify existence of ${PERSONS}"
		# Check output file for person
   		awk '/Domain.*principal/,/Domain.*group/ {if ($1 != "Domain") 
			print $0}' < ${RGY_OUTPUT} | \
			verify_existence "${PERSONS}"


		if [ "$?" = 0 ]
		then
			REPORT="One of more of person ${PERSONS}"
		fi
	fi

	if [ -n "${ALIASES}" ]
	then
		tet_infoline "Attempting to verify existence of ${ALIASES}"
		# Check output file for alias
   		awk '/Domain.*principal/,/Domain.*group/ {if ($1 != "Domain") 
			print $0}' < ${RGY_OUTPUT} | \
			verify_existence "${ALIASES}"
	
		if [ "$?" = 0 ]
		then
			if [ -n "${REPORT}" ]
			then
				REPORT="${REPORT}, ${ALIASES}"
			else
				REPORT="One or more of ${ALIASES}"
			fi
		fi
	fi

	if [ -n "${GROUPS}" ]
	then
		tet_infoline "Attempting to verify existence of ${GROUPS}"
		# Check output file for group.
   		awk '/Domain.*group/,/Domain.*org/ {if ($1 != "Domain") 
			print $0}' < ${RGY_OUTPUT} | verify_existence ${GROUPS}

		if [ "$?" = 0 ]
		then
			if [ -n "${REPORT}" ]
			then
				REPORT="${REPORT}, ${GROUPS}"
			else
				REPORT="One or more of group ${GROUPS}"
			fi
		fi
	fi

	if [ -n "${ORGS}" ]
	then
		tet_infoline "Attempting to verify existence of ${ORGS}"
		# Check output file for organization.
   		awk '/Domain.*org/,/Domain.*account/ {if ($1 != "Domain") 
			print $0}' < ${RGY_OUTPUT} | verify_existence "${ORGS}"

		if [ "$?" = 0 ]
		then
			if [ -n "${REPORT}" ]
			then
				REPORT="${REPORT}, ${ORGS}"
			else
				REPORT="One or more of organization ${ORGS}"
				tet_infoline "One or more of organization ${ORGS}"
			fi
		fi
	fi

	if [ -n "${REPORT}" ]
	then
		REPORT="${REPORT} exists."
		tet_infoline "ERROR: ${REPORT} in state_of_rgy"
		fail=1
		return 1
	else
		return 0
	fi

} # End of state_of_rgy

#===============================================================================
# Function:     verify_rgy  <prefix>
# Purpose:      Outputs data concerning the current state of the registry
#               file.  It verify that the registry is already set up or not.
#
#===============================================================================
verify_rgy() {

        tet_infoline "Verifying the current state of registry"

        # Make sure that files ${RGY_INPUT} and ${RGY_OUTPUT} can be
        #       created properly.
        #
        touch ${RGY_INPUT}
        if [ "$?" != 0 ]
        then
		tet_infoline "ERROR: Unable to create file ${RGY_INPUT} in verify_rgy"
                fail=1
		return 1
        fi

        touch ${RGY_OUTPUT}
        if [ "$?" != 0 ]
        then
		tet_infoline "ERROR: Unable to create file ${RGY_OUTPUT} in verify_rgy"
                fail=1
		return 1
        fi

        # Create stdin batch file for determining current state of registry.
        #
        cat << EOF > ${RGY_INPUT}
do p
v
do g
v
do o
v
do a
v
q
EOF

        # Execute rgy_edit with input file.
        #
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in verify_rgy"
		fail=1
                return 1
        fi

        cat ${RGY_OUTPUT} | verify_existence "${1}" > /dev/null
	if [ "$?" != 0 ]
        then
		# Don't put a tet_infoline in here, nor a fail MGM
		return 1
	else	
		tet_infoline "Registry has been verified"
		return 0
	fi

} # End of function verify_rgy
	
	
#===============================================================================
# Function:	execute_rgy
# Purpose:	Executes rgy_edit with the proper input file and makes sure
#		that it returns control.
#===============================================================================
execute_rgy() {
	# WARNING: Might not be universal.  Needs to be checked
	#
	${RGY_EXEC} < ${RGY_INPUT} > ${RGY_OUTPUT} 2>&1 & 
	RGY_PID=$!
	COUNT=0

	while [ "${COUNT}" -le "${RGY_WAIT}" ]
	do
		sleep 1
		chkproc -p ${RGY_PID}
		if [ "$?" -eq 1 ]
		then
			break 2
		else
			COUNT=`expr ${COUNT} + 1`
		fi
	done

	if [ "${COUNT}" -gt "${RGY_WAIT}" ]
	then
		tet_infoline "ERROR: ${RGY_EXEC} is hung up.  Killing process ${RGY_PID} in execute_rgy"
		kill -9 ${RGY_PID}
		cat ${RGY_INPUT} ${RGY_OUTPUT}
		fail=1
		return 1
	fi	
	
} # End of execute_rgy.

#===============================================================================
# Function:     change_account_auth_info <name_of_prin> 
# Purpose:      Change account's authentication information.
#
#===============================================================================
change_account_auth_info() {

#set -x

        tet_infoline "Attempting to change account's authentication information"
        cat << EOF > ${RGY_INPUT}
do a
c -p $1 -g $2 -o $3



















y
$4
$5
v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_account_auth_info"
		fail=1
                return 1
        fi
        # Check to make sure the authentication information was changed
        cat ${RGY_OUTPUT} | verify_existence "$4" > /dev/null

        # Exit if the authentication information didn't change
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Account's authentication information was not changed as expected \
				in change_account_auth_info"
		cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Account's authentication information has been changed AS EXPECTED"
        return 0

} # End of function change_account_auth_info

#===============================================================================
# Function:     change_neg_account_auth_info <name_of_prin>
# Purpose:      Change account's authentication information without permission.
#
#===============================================================================
change_neg_account_auth_info() {

#set -x

        tet_infoline "Attempting to change account's authentication info without permission"
        cat << EOF > ${RGY_INPUT}
do a
c -p $1 -g $2 -o $3



















y
$4
$5

v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_neg_account_auth_info"
		fail=1
                return 1
        fi
        # Check to make sure the authentication information was not changed
        cat ${RGY_OUTPUT} | verify_existence "Not authorized" > /dev/null

        # Exit if the authentication information did change
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Account's authentication information was changed unexpectedly \
				in change_neg_account_auth_info"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have not made properly.
        tet_infoline "Account's authentication information has NOT changed AS EXPECTED"
        return 0

} # End of function change_neg_account_auth_info

#===============================================================================
# Function:     change_account_manag_info <name_of_prin> <name_of_group>
#			<name_of_org>
# Purpose:      Change account's management information.
#
#===============================================================================
change_account_manag_info() {

#set -x

        tet_infoline "Attempting to change account's management information"
        cat << EOF > ${RGY_INPUT}
do a
c -p $1 -g $2 -o $3 -$4
v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_account_manag_info"
		fail=1
                return 1
        fi
        # Check to make sure the management information was changed
        cat ${RGY_OUTPUT} | verify_existence "Account is: NOT valid" > /dev/null

        # Exit if the management information didn't change
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Account's management information was not changed as expected \
				in change_account_manag_info"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Account's management information has been changed AS EXPECTED"
        return 0

} # End of function change_account_manag_info

#===============================================================================
# Function:     change_neg_account_manag_info <name_of_prin>  <name_of_group>
#                       <name_of_org> 
# Purpose:      Change account's management information without permission.
#
#===============================================================================
change_neg_account_manag_info() {

#set -x

        tet_infoline "Attempting to change account's management info without permission"
        cat << EOF > ${RGY_INPUT}
do a
c -p $1 -g $2 -o $3 -$4
v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_neg_account_manag_info"
		fail=1
                return 1
        fi
        # Check to make sure the management information was not changed
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null

        # Exit if the management information did change
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Account's management information was changed unexpectedly \
				change_neg_account_manag_info"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have not made properly.
        tet_infoline "Account's management information has NOT changed AS EXPECTED"
        return 0

} # End of function change_neg_account_manag_info

#===============================================================================
# Function:     change_account_user_info <name_of_prin> <name_of_group>
#                       <name_of_org> <name_of_home_dir>
# Purpose:      Change account's user information.
#
#===============================================================================
change_account_user_info() {

#set -x

        tet_infoline "Attempting to change account's user information"
        cat << EOF > ${RGY_INPUT}
do a
c -p $1 -g $2 -o $3 -h $4
v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_account_user_info"
		fail=1
                return 1
        fi
        # Check to make sure the user information was changed
        cat ${RGY_OUTPUT} | verify_existence "$4" > /dev/null

        # Exit if the user information didn't change
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Account's user information was not changed as expected \
				change_account_user_info"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Account's user information has been changed AS EXPECTED"
        return 0

} # End of function change_account_user_info

#===============================================================================
# Function:     change_neg_account_user_info <name_of_prin>  <name_of_group> 
#                       <name_of_org> <name_of_home_dir>  
# Purpose:      Change account's user information without permission.
#
#===============================================================================
change_neg_account_user_info() {

#set -x

        tet_infoline "Attempting to change account's user info without permission"
        cat << EOF > ${RGY_INPUT}
do a
c -p $1 -g $2 -o $3 -h $4
v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_neg_account_user_info"
		fail=1
                return 1
        fi
        # Check to make sure the user information was not changed
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null

        # Exit if the user information did change
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Account's user information was changed unexpectedly \
				in change_neg_account_user_info"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have not made properly.
        tet_infoline "Account's user information has NOT changed AS EXPECTED"
        return 0

} # End of function change_neg_account_user_info

#===============================================================================
# Function:     change_auth_info <name_of_prin> <number of registry objects>
# Purpose:      Change authentication information.
#
#===============================================================================
change_auth_info() {

#set -x

        tet_infoline "Attempting to change authentication information"
        cat << EOF > ${RGY_INPUT}
auth
y
$1
$2
auth

q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_auth_info"
		fail=1
                return 1
        fi
        # Check to make sure the authentication information was changed
        cat ${RGY_OUTPUT} | verify_existence "$1" > /dev/null

        # Exit if the authentication information didn't change 
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Authentication information was not changed as expected \
				in change_auth_info"
		cat ${RGY_OUTPUT} 
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Authentication information has been changed AS EXPECTED"
        return 0

} # End of function change_auth_info

#===============================================================================
# Function:     change_neg_auth_info 
# Purpose:      Change authentication information without permission.
#
#===============================================================================
change_neg_auth_info() {

#set -x

        tet_infoline "Attempting to change authentication information without permission"
        cat << EOF > ${RGY_INPUT}
auth
y
$1
$2
auth

q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_neg_auth_info"
		fail=1
                return 1
        fi
        # Check to make sure the authentication information was not changed
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null

        # Exit if the authentication information didn't change 
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Authentication information was changed unexpectedly \
				in change_neg_auth_info"
		cat ${RGY_OUTPUT} 
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Authentication information has NOT changed AS EXPECTED"
        return 0

} # End of function change_neg_auth_info

#===============================================================================
# Function:     change_policy_info 
# Purpose:      Change policy information with permission.
#
#===============================================================================
change_policy_info() {

#set -x

        tet_infoline "Attempting to change policy information with permission"
        cat << EOF > ${RGY_INPUT}
po -al $1 -pl $2
po

q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_policy_info"
		fail=1
                return 1
        fi
        # Check to make sure that policy information have been changed
        cat ${RGY_OUTPUT} | verify_existence "6w6d6h" > /dev/null

        # Exit if the policy information didn't change
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Policy information was not changed as expected \
				in change_policy_info"
		cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Policy information has been changed AS EXPECTED"
        return 0

} # End of function change_policy_info

#===============================================================================
# Function:     change_neg_policy_info 
# Purpose:      Change policy information without permission.
#
#===============================================================================
change_neg_policy_info() {

#set -x

        tet_infoline "Attempting to change policy information without permission"
        cat << EOF > ${RGY_INPUT}
po -al $1 -pl $2
po

q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_neg_policy_info"
		fail=1
                return 1
        fi
        # Check to make sure that policy information was not changed
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null

        # Exit if the policy information didn't change
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Policy information was changed unexpectedly \
				in change_neg_policy_info"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Policy information has NOT changed AS EXPECTED"
        return 0

} # End of function change_neg_policy_info

#===============================================================================
# Function:     change_property_info
# Purpose:      Change property information with permission.
#
#===============================================================================
change_property_info() {

#set -x

        tet_infoline "Attempting to change property information with permission"
        cat << EOF > ${RGY_INPUT}
prop
y






$1

prop

q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_property_info"
		fail=1
                return 1
        fi
        # Check to make sure that property information have been changed
        cat ${RGY_OUTPUT} | verify_existence "$1"m"" > /dev/null

        # Exit if the property information didn't change
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Property information was not changed as expected \
				in change_property_info"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Property information has been changed AS EXPECTED"
        return 0

} # End of function change_property_info

#===============================================================================
# Function:     change_neg_property_info
# Purpose:      Change property information without permission.
#
#===============================================================================
change_neg_property_info() {

#set -x

        tet_infoline "Attempting to change property information without permission"
        cat << EOF > ${RGY_INPUT}
prop
y






$1

prop

q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_neg_property_info"
		fail=1
                return 1
        fi
        # Check to make sure that property information was not changed
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null

        # Exit if the property information didn't change
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Property information was changed unexpectedly \
				in change_neg_property_info"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Property information has NOT changed AS EXPECTED"
        return 0

} # End of function change_neg_property_info

#===============================================================================
# Function:     change_prin_quota <name_of_prin> <number of registry objects>
# Purpose:      Change object creation quota number.
#
#===============================================================================
change_prin_quota() {

#set -x

        tet_infoline "Attempting to change object creation quota number of principal ${1}"
        cat << EOF > ${RGY_INPUT}
do p
c $1 


$2

v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_prin_quota"
		fail=1
                return 1
        fi
        # Check to make sure the principal's  object creation quota was changed 
        cat ${RGY_OUTPUT} | verify_existence "Quota: ${2}" > /dev/null

        # Exit if the quota didn't change 
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Principal ${1}'s quota was not entered into registry as expected \
				in change_prin_quota"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Principal ${1}'s quota has been changed AS EXPECTED"
        return 0

} # End of function change_prin_quota

#===============================================================================
# Function:     change_neg_prin_quota <name_of_prin> <number of registry objects>
# Purpose:      Change object creation quota number without permission.
#
#===============================================================================
change_neg_prin_quota() {

#set -x

        tet_infoline "Attempting to change quota number of principal ${1} without permission"
        cat << EOF > ${RGY_INPUT}
do p
c ${1} 


${2}

v ${1} -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_neg_prin_quota"
		fail=1
                return 1
        fi
        # Check to make sure the principal object creation quota didn't change 
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null
        # Exit if the quota did change 
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Principal ${1}'s quota was change unexpectedly \
				in change_neg_prin_quota"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Principal ${1}'s quota has NOT been changed AS EXPECTED"
        return 0

} # End of function change_neg_prin_quota

#=============================================================================nn
# Function:     change_group_project_list <name_of_group> <flag>
# Purpose:      Change group's project list inclusion.
#
#===============================================================================
change_group_project_list() {

#set -x

        # Assumption: Old group 's project list = "l" in the registry
        #
        tet_infoline "Attempting to change the project list of group ${1}"
        cat << EOF > ${RGY_INPUT}
do g
c $1 -"$2"
v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_group_project_list"
		fail=1
                return 1
        fi
        # Check to make sure the group project list flag was changed 
        cat ${RGY_OUTPUT} | verify_existence "Project List:${2}" > /dev/null

        # Exit if the group's project list didn't change 
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Group ${1}'s project list was not changed as expected \
				in change_group_project_list"
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Group ${1}'s project list has been changed AS EXPECTED"
        return 0
} # End of function change_group_project_list

#=============================================================================nn
# Function:     change_neg_group_project_list <name_of_group> <flag>
# Purpose:      Change group's project list inclusion without permission.
#
#===============================================================================
change_neg_group_project_list() {

#set -x

        # Assumption: Old group 's project list = "l" in the registry
        #
        tet_infoline "Attempting to change the project list of group ${1} without permission"
        cat << EOF > ${RGY_INPUT}
do g
c $1 -"$2"
v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_neg_group_project_list"
		fail=1
                return 1
        fi
        # Check to make sure the group project list flag was not changed 
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null

        # Exit if the group's project list did change 
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Group ${1}'s project list was changed as unexpectedly \
				in change_neg_group_project_list"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Group ${1}'s project list has NOT changed AS EXPECTED"
        return 0
} # End of function change_neg_group_project_list

#===============================================================================
# Function:     change_org_management_info <name_of_org> <space_flag> <alpha_flag>
# Purpose:      Change management information of organization.
#
#===============================================================================
change_org_management_info() {

#set -x

        # Assumption: Old organization's password may be all spaces
	#             and may be all alphanumeric 
        #
        tet_infoline "Attempting to change management info of organization ${1}"
        cat << EOF > ${RGY_INPUT}
do o
c $1 


y




$2
$3
po $1

q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_org_management_info"
		fail=1
                return 1
        fi
        # Check to make sure the organization's management info was changed 
        cat ${RGY_OUTPUT} | verify_existence "MAY NOT be all spaces,  MAY NOT" > /dev/null

        # Exit if the organization's management info didn't changed 
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: ${1}'s management info was not changed as expected \
				in change_org_management_info"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Organization ${1}'s management info has been changed AS EXPECTED"
        return 0

} # End of function change_org_management_info

#===============================================================================
# Function:     change_neg_org_management_info <name_of_org> <space_flag> <alpha_flag>
# Purpose:      Change management information of organization without permission.
#
#===============================================================================
change_neg_org_management_info() {

#set -x

        # Assumption: Old organization's password may be all spaces
        #             and may be all alphanumeric
        #
        tet_infoline "Attempting to change management info of organization ${1} without permission"
        cat << EOF > ${RGY_INPUT}
po $1 -$2 -$3
po $1

q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_neg_org_management_info"
		fail=1
                return 1
        fi
        # Check to make sure the organization's management info was changed
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null

        # Exit if the organization's management info did change
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: ${1}'s management info was changed unexpectedly \
				in change_neg_org_management_info"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Organization ${1}'s management info has NOT changed AS EXPECTED"
        return 0

} # End of function change_neg_org_management_info

#===============================================================================
# Function:     change_prin_full_name <name_of_prin> <new full name>
# Purpose:      Change full name of principal.
#
#===============================================================================
change_prin_full_name() {

#set -x

        # Assumption: Old principal exists in the registry
        #
        tet_infoline "Attempting to change the full name of principal ${1}"
        cat << EOF > ${RGY_INPUT}
do p
c $1 -f "$2"
v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_prin_full_name"
		fail=1
                return 1
        fi
        # Check to make sure the principal still exists
        # There is no way currently to verify that the full name or org
        #       has changed.
        cat ${RGY_OUTPUT} | verify_existence "Full name: *${2}" > /dev/null

        # Exit if the principal doesn't exist
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Principal ${1} was not entered into registry as expected \
				in change_prin_full_name"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Principal ${1}'s full name has been changed AS EXPECTED"
        return 0

} # End of function change_prin_full_name

#===============================================================================
# Function:     change_neg_prin_full_name <name_of_org> <new full name>
# Purpose:      Change full name of principal without permission.
#
#===============================================================================
change_neg_prin_full_name() {

#set -x

        # Assumption: Old principal exists in the registry
        #
        tet_infoline "Attempting to change the full name of principal ${1} without permission"
        cat << EOF > ${RGY_INPUT}
do p
c $1 -f "$2"
v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_neg_prin_full_name"
		fail=1
                return 1
        fi
        # Check to make sure the principal still exists
        # There is no way currently to verify that the full name or org
        #       has changed.
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null

        # Exit if the principal doesn't exist
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Principal ${1}'s full name changed unexpectedly \
				in change_neg_prin_full_name"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Principal ${1}'s full name has NOT been changed AS EXPECTED"
        return 0

} # End of function change_neg_prin_full_name

#=============================================================================nn
# Function:     change_group_full_name <name_of_group> <new full name>
# Purpose:      Change full name of group.
#
#===============================================================================
change_group_full_name() {

#set -x

        # Assumption: Old group exists in the registry
        #
        tet_infoline "Attempting to change the full name of group ${1}"
        cat << EOF > ${RGY_INPUT}
do g
c $1 -f "$2"
v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_group_full_name"
		fail=1
                return 1
        fi
        # Check to make sure the group still exists
        # There is no way currently to verify that the full name or org
        #       has changed.
        cat ${RGY_OUTPUT} | verify_existence "Full name: *${2}" > /dev/null

        # Exit if the group doesn't exist
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Group ${1} was not entered into registry as expected \
				in change_group_full_name"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Group ${1}'s full name has been changed AS EXPECTED"
        return 0
} # End of function change_group_full_name

#===============================================================================
# Function:     change_neg_group_full_name <name_of_group> <new full name>
# Purpose:      Change full name of group without permission.
#
#===============================================================================
change_neg_group_full_name() {

#set -x

        # Assumption: Old group exists in the registry
        #
        tet_infoline "Attempting to change the full name of group ${1} without permission"
        cat << EOF > ${RGY_INPUT}
do g
c $1 -f "$2"
v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_neg_group_full_name"
		fail=1
                return 1
        fi
        # Check to make sure the group still exists
        # There is no way currently to verify that the full name or org
        #       has changed.
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null

        # Exit if the group doesn't exist
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Group ${1}'s full name changed unexpectedly \
				in change_neg_group_full_name"
                cat ${RGY_OUTPUT}
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Group ${1}'s full name has NOT been changed AS EXPECTED"
        return 0

} # End of function change_neg_group_full_name

#===============================================================================
# Function: 	change_org_full_name <name_of_org> <new full name> 
# Purpose:	Change full name of organization.  
#		   
#===============================================================================
change_org_full_name() {

#set -x

	# Assumption: Old organization exists in the registry
	#
	tet_infoline "Attempting to change the full name of organization ${1}"
	cat << EOF > ${RGY_INPUT}
do o
c $1 -f "$2"
v $1 -f
q
EOF

	# Execute ${RGY_EXEC} to make changes to registry.
	execute_rgy
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Execute_rgy failed in change_org_full_name"
		fail=1
		test_fail=1
		return 1
	fi
	# Check to make sure the organization still exists
	# There is no way currently to verify that the full name or org
	# 	has changed.
	cat ${RGY_OUTPUT} | verify_existence "Full name: *${2}" > /dev/null

	# Exit if the organization doesn't exist
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Organization ${1} was not entered into registry as expected \
				in change_org_full_name"
		fail=1
		test_fail=1
		return 2
	fi

	# Call function to report that the changes have been made properly.
	tet_infoline "Organization ${1}'s full name has been changed AS EXPECTED"
	return 0

} # End of function change_org_full_name

#===============================================================================
# Function:     change_neg_org_full_name <name_of_org> <new full name>
# Purpose:      Change full name of organization without permission.
#
#===============================================================================
change_neg_org_full_name() {

#set -x

        # Assumption: Old organization exists in the registry
        #
        tet_infoline "Attempting to change the full name of organization ${1} without permission"
        cat << EOF > ${RGY_INPUT}
do o
c $1 -f "$2"
v $1 -f
q
EOF

        # Execute ${RGY_EXEC} to make changes to registry.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_neg_org_full_name"
		fail=1
                return 1
        fi
        # Check to make sure the organization still exists
        # There is no way currently to verify that the full name or org
        #       has changed.
        cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null

        # Exit if the organization doesn't exist
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Organization ${1}'s full name changed unexpectedly \
				in change_neg_org_full_name"
		fail=1
                return 2
        fi

        # Call function to report that the changes have been made properly.
        tet_infoline "Organization ${1}'s full name has NOT been changed AS EXPECTED"
        return 0

} # End of function change_neg_org_full_name

#===============================================================================
# Function: 	change_group_name <old_group_name> <new_group_name> 
# Purpose:	Change name of group.  
#		   
#===============================================================================
change_group_name() {

	# ASSUMPTION: Old group exists in the registry
	#
	tet_infoline "Attempting to change name of group"
	cat << EOF > ${RGY_INPUT}
do g
c $1 -n $2
v $2
q
EOF

	# Execute with input file
	#
	execute_rgy
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Execute_rgy failed in change_group_name"
		fail=1
		return 1
	fi

	# Check output to verify that group has been changed, and that
	#    the changes have been propagated to the account.
	#
	cat ${RGY_OUTPUT} | verify_existence "^${2}[ 	]*[0-9][0-9]*$" > /dev/null

	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Name of group was not changed as expected in change_group_name"
		fail=1
		return 2
	else
		tet_infoline "New group name has been ADDED to the registry"
		# Check to see of old group still exists
		cat ${RGY_OUTPUT} | verify_existence "^${1}[ 	]*[0-9][0-9]*$" > /dev/null
		if [ "$?" = 0 ]
		then
			tet_infoline "ERROR: Old group name still exists in the registry in change_group_name"
			fail=1
			return 3
		else
			tet_infoline "Name of group has been changed to ${2}"
			return 0
		fi
	fi

} # End of function change_group_name
#===============================================================================
# Function: 	check_account <person_name> <group_name> <organization_name>
# Purpose:	To determine if the account requested is within the registry.
#
#===============================================================================
check_account() {
#set -x
	cat << EOF > ${RGY_INPUT}
do a
v ${1}
q
EOF

	tet_infoline "Attempting to verify  if account exists in the registry"
	# Execute with input file
	#
	execute_rgy 
	if [ "$?" != 0 ]
	then
                tet_infoline "ERROR: Execute_rgy failed in check_account"
		fail=1
		return 1
	fi
	
	# Check to see if account exists
	#
	cat ${RGY_OUTPUT} | verify_existence "${1}.*${2}.*${3}" > /dev/null

	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Account with ${1} ${2} and ${3} does not exist in the registry \
				in check_account"
		fail=1
		return 2
	else
		tet_infoline "Account ${1} ${2} ${3} exists in the registry"
		return 0
	fi

} # End of function check_account
#===============================================================================
# Function: 	change_person_id <person_name> <old UNIX ID> <new UNIX ID>
# Purpose:	Change UNIX ID for person.  
#		   
#===============================================================================
change_person_id() {

	tet_infoline "Attempting to change UNIX id for person ${1}"

	cat << EOF > ${RGY_INPUT}
do p
change
${1}

${3}


v ${1}
q
EOF

	# Execute rgy with input file.
	#
	execute_rgy
	if [ "$?" != 0 ]
	then
                tet_infoline "ERROR: Execute_rgy failed in change_person_id"
		fail=1
		return 1
	fi

	# Check to make sure that new ID has been set.
	#
	cat ${RGY_OUTPUT} | verify_existence "${1}[ 	]*${3}"

	# Exit if it doesn't exist
	#
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Unable to change UNIX_ID of person ${1} in change_person_id"
		fail=1
		return 2
	else
		cat ${RGY_OUTPUT} | verify_existence "${1}[ 	]*${2}"
		if [ "$?" = 0 ]
		then
			tet_infoline "ERROR: Old ID for person ${1} still exists in change_person_id"	
			fail=1
			return 3
		else
			tet_infoline "Person ${1}'s UNIX ID has been changed to ${2}."
			return 0
		fi
	fi

} #End of function change_person_id

#===============================================================================
# Function:	add_to_group_or_org -g|-o <name_of_group|org> <List of persons>
# Purpose:	Add existing members to new group|org created for tests.
#		
#===============================================================================
add_to_group_or_org() {
#set -x

	# Initialize variables to NULL
	ORG=""
	GROUP=""
	FLAG=""
	
	case "${1}" in

		-g) shift;
	 	   GROUP="${1}"
		   FLAG="group"
		   shift;
		   MEMBERS="${1}"
	    	   ;;
	    
		-o) shift;
		   ORG="${1}"
		   FLAG="org" 
		   shift;
		   MEMBERS="${1}"
	    	   ;;

	 	*) shift;
	      	   tet_infoline "ERROR: Illegal input to function add_to_group_or_org";
		   fail=1
		   test_fail=1
		   return 1;;
	 #   	   break;;

	esac

	tet_infoline "Attempting to add ${1} member to ${FLAG} in add_to_group_or_org"

	# If persons don't currently exist to add to membership, then exit
	# Check the current length of MEMBERS
	#
	LENGTH=`expr "${MEMBERS}" : ".*"`
	
	if [ "${LENGTH}" -eq 0 ]
	then
		tet_infoline "ERROR: Unable to continue because of lack of members in add_to_group_org"
		fail=1
		test_fail=1
		return 1
	fi

	# Create rgy input file
	#
	cat << EOF > ${RGY_INPUT}
do ${FLAG}
m "${ORG}${GROUP}" -a ${MEMBERS}
v "${ORG}${GROUP}" -m
q
EOF

	# Execute rgy with input file.
	execute_rgy
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Execute_rgy failed in add_to_group_or_org"
		fail=1
		test_fail=1
		return 1
	fi

	# Check to make sure that new ID has been set.
	FAIL="false"
	for i in ${MEMBERS}
	do
		cat ${RGY_OUTPUT} | verify_existence " ${i}" > /dev/null
		# Exit if it doesn't exist
		if [ "$?" != 0 ]
		then
			tet_infoline "ERROR: Unable to add member ${i} to ${FLAG} in add_to_group_or_org"
			FAIL="true"
		fi
	done

	if [ $FAIL = "true" ]; then
                tet_infoline "ERROR: Members ${MEMBERS} have NOT been added properly to \
			${FLAG} "${ORG}${GROUP}" in add_to_group_or_org"
		fail=1
		test_fail=1
		return 2
	fi
	# Call function to report that the members have been added properly.
	tet_infoline "Members ${MEMBERS} have been ADDED properly to ${FLAG} "${ORG}${GROUP}""
	return 0

} # End of function add_to_group_or_org

#===============================================================================
# Function:     add_neg_to_group_or_org -g|-o <name_of_group|org> <List of persons>
# Purpose:      Add existing members to new group|org without permissions.
#
#===============================================================================
add_neg_to_group_or_org() {
#set -x

        # Initialize variables to NULL
        ORG=""
        GROUP=""
        FLAG=""

        case "${1}" in

                -g) shift;
                   GROUP="${1}"
                   FLAG="group"
                   shift;
                   MEMBERS="${1}"
                   ;;

                -o) shift;
                   ORG="${1}"
                   FLAG="org"
                   shift;
                   MEMBERS="${1}"
                   ;;

                *) shift
                   tet_infoline "ERROR: Illegal input to function add_neg_to_group_or_org"
		   fail=1
                   break;;

        esac

        tet_infoline "Attempting to add ${1} member to ${FLAG} without permission"

        # If persons don't current exist to add to membership, then exit
        # Check the current length of MEMBERS
        #
        LENGTH=`expr "${MEMBERS}" : ".*"`

        if [ "${LENGTH}" -eq 0 ]
        then
                tet_infoline "ERROR: Unable to continue because of lack of members in add_neg_to_group_or_org"
		fail=1
                return 1
        fi

        # Create rgy input file
        #
        cat << EOF > ${RGY_INPUT}
do ${FLAG}
m "${ORG}${GROUP}" -a ${MEMBERS}
v "${ORG}${GROUP}" -m
q
EOF

        # Execute rgy with input file.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in add_neg_to_group_or_org"
		fail=1
                return 1
        fi

        # Check to make sure that new ID has been set.
	FAIL="false"
        for i in ${MEMBERS}
        do
                cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null
                # Exit if it doesn't exist
                if [ "$?" != 0 ]
                then
                        tet_infoline "ERROR: Able to add member ${i} to ${FLAG} unexpectedly \
				in add_neg_to_group_or_org"
                        cat ${RGY_INPUT} ${RGY_OUTPUT}
                        FAIL="true"
                fi
        done

        if [ $FAIL = "true" ]; then
                tet_infoline "ERROR: Some members have unexpectedly been added to $FLAG in add_neg_to_group_or_org"
		fail=1
                return 2
        fi
        # Call function to report that the members have been added properly.
        tet_infoline "Members ${MEMBERS} have NOT been added to "${ORG}${GROUP}" AS EXPECTED."
        return 0

} # End of function add_neg_to_group_or_org

#===============================================================================
# Function:     remove_from_group_or_org -g|-o <name_of_group|org> <List of persons>
# Purpose:      Remove existing members from group|org with permissions.
#
#===============================================================================
remove_from_group_or_org() {
#set -x

        # Initialize variables to NULL
        ORG=""
        GROUP=""
        FLAG=""

        case "${1}" in

                -g) shift;
                   GROUP="${1}"
                   FLAG="group"
                   shift;
                   MEMBERS="${1}"
                   ;;

                -o) shift;
                   ORG="${1}"
                   FLAG="org"
                   shift;
                   MEMBERS="${1}"
                   ;;

                *) shift;
                   tet_infoline "ERROR: Illegal input to function remove_from_group_or_org"
		   fail=1
                   break;;

        esac

        tet_infoline "Attempting to remove ${1} members from ${FLAG}"

        # If persons don't current exist to remove to membership, then exit
        # Check the current length of MEMBERS
        #
        LENGTH=`expr "${MEMBERS}" : ".*"`

        if [ "${LENGTH}" -eq 0 ]
        then
                tet_infoline "ERROR: Unable to continue because of lack of members in remove_from_group_or_org"
		fail=1
                return 1
        fi

        # Create rgy input file
        #
        cat << EOF > ${RGY_INPUT}
do ${FLAG}
m "${ORG}${GROUP}" -r ${MEMBERS}
v "${ORG}${GROUP}" -m
q
EOF

        # Execute rgy with input file.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in remove_from_group_or_org"
		fail=1
                return 1
        fi

        # Check to make sure that new ID has been set.
	FAIL="false"
        for i in ${MEMBERS}
        do
                cat ${RGY_OUTPUT} | verify_existence " ${i}" > /dev/null
                # Exit if it doesn't exist
                if [ "$?" = 0 ]
                then
                        tet_infoline "ERROR: Unable to remove member ${i} from ${FLAG} in remove_from_group_or_org"
                        cat ${RGY_INPUT} ${RGY_OUTPUT}
                        FAIL="true"
                fi
        done

        if [ $FAIL = "true" ]; then
                tet_infoline "ERROR: Some members have not been removed from $FLAG as expected in remove_from_group_or_org"
		fail=1
                return 2
        fi
        # Call function to report that the members have been added properly.
        tet_infoline "Members ${MEMBERS} have been removed properly from "${ORG}${GROUP}""
        return 0

} # End of function remove_from_group_or_org

#===============================================================================
# Function:     remove_neg_from_group_or_org -g|-o <group_name|org> <List of persons>
# Purpose:      Remove existing members from group|org without permissions.
#
#===============================================================================
remove_neg_from_group_or_org() {
#set -x

        # Initialize variables to NULL
        ORG=""
        GROUP=""
        FLAG=""

        case "${1}" in

                -g) shift;
                   GROUP="${1}"
                   FLAG="group"
                   shift;
                   MEMBERS="${1}"
                   ;;

                -o) shift;
                   ORG="${1}"
                   FLAG="org"
                   shift;
                   MEMBERS="${1}"
                   ;;

                *) shift;
                   tet_infoline "ERROR: Illegal input to function remove_neg_from_group_or_org"
		   fail=1
                   break;;

        esac

        tet_infoline "Attempting to remove ${1} members from ${FLAG} without permission"

        # If persons don't current exist to remove to membership, then exit
        # Check the current length of MEMBERS
        #
        LENGTH=`expr "${MEMBERS}" : ".*"`

        if [ "${LENGTH}" -eq 0 ]
        then
                tet_infoline "ERROR: Unable to continue because of lack of members in remove_neg_from_group_or_org"
		fail=1
                return 1
        fi

        # Create rgy input file
        #
        cat << EOF > ${RGY_INPUT}
do ${FLAG}
m "${ORG}${GROUP}" -r ${MEMBERS}
v "${ORG}${GROUP}" -m
q
EOF

        # Execute rgy with input file.
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in remove_neg_from_group_or_org"
		fail=1
                return 1
        fi

        # Check to make sure that new ID has been set.
	FAIL="false"
        for i in ${MEMBERS}
        do
                cat ${RGY_OUTPUT} | verify_existence "Unable" > /dev/null
                # Exit if it doesn't exist
                if [ "$?" != 0 ]
                then
                        tet_infoline "ERROR: Able to remove member ${i} from ${FLAG} unexpectedly \
				in remove_neg_from_group_or_org"
                        cat ${RGY_INPUT} ${RGY_OUTPUT}
			FAIL="true"
                fi
        done

        if [ $FAIL = "true" ]; then
                tet_infoline "ERROR: Some members have been removed unexepectedly from $FLAG in remove_neg_from_group_or_org"
		fail=1
                return 2
        fi
        # Call function to report that the members have been added properly.
        tet_infoline "Members ${MEMBERS} have NOT been removed from "${ORG}${GROUP}" AS EXPECTED"
        return 0

} # End of function remove_neg_from_group_or_org

#===============================================================================
# Function:	change_home_directory <person_name> <group_name> <org_name>
# Purpose:	Creates rgy_edit input file and executes the code to change
#		the home directory of person.  The password for person is
#===============================================================================
change_home_directory() {
	tet_infoline "Attempting to change home directory of person ${1}"
	# Create batch file
	cat << EOF > ${RGY_INPUT}
do a
c -p ${1} -g ${2} -o ${3} -h $4
v ${1}
q
EOF

	# Execute rgy with input file.
	execute_rgy
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Execute_rgy failed in change_home_directory"
		test_fail=1
		return 1
	fi
	# Check to make sure that new ID has been set.
	cat ${RGY_OUTPUT} | verify_existence "${1}.*${2}.*${3}.*${4}" > /dev/null

	# Exit if it doesn't exist
	if [ "$?" != 0 ]
	then
	 	tet_infoline "ERROR: Unable to change home directory for account ${1} in change_home_directory"
                cat ${RGY_OUTPUT}
		test_fail=1
		return 1
	else
		tet_infoline "Was able to change home directory for $1"
		return 0
	fi

} # End of function change_home_directory

#===============================================================================
# Function:     change_shell <person_name> <group_name> <org_name>
# Purpose:      Creates rgy_edit input file and executes the code to change
#               the shell of person.  The password for person is
#===============================================================================
change_shell() {
        tet_infoline "Attempting to change shell of person ${1}"
        # Create batch file
        cat << EOF > ${RGY_INPUT}
do a
c -p ${1} -g ${2} -o ${3} -s $4
v ${1}
q
EOF

        # Execute rgy with input file.
        execute_rgy

        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in change_shell"
                return 1
        fi
        # Check to make sure that new ID has been set.
        cat ${RGY_OUTPUT} | verify_existence "${1}.*${2}.*${3}.*${4}" > /dev/null

        # Exit if it doesn't exist
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Unable to change shell for account ${1} in change_shell"
                cat ${RGY_OUTPUT}
		return 1
	else
		tet_infoline "Was able to change shell for $1"
		return 0
        fi

} # End of function change_shell

#===============================================================================
# Function:     change_password <person_name> <org_name> <group_name> <Person's Password>
#               <Person New Password>
# Purpose:      Creates rgy_edit input file and executes the code to change
#               the password of person.  
#		Taken out of resestr.main when converted to tet
#===============================================================================
change_password()
{
        tet_infoline "Attempting to change $1 password from $4 to $5"
cat << EOF > ${RGY_INPUT}
do a
c -p $1 -o $2 -g $3 -mp $4 -pw $5
q
EOF

        # Execute file using the rgy_edit command.  Send the output to file
        #       ${RGY_OUTPUT}
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "FAILURE: Unable to change $1 password from $4 to $5"
		return 1
	else
		tet_infoline "Was able to change $1 password from $4 to $5"
		return 0
        fi
}	# end of function change_password

#=========================================================================
# Function:     execution
# Purpose:      Login to account then change home directory, shell, and
#               password. Used in resestr and moved to sec.functions when 
#		ported to tet.
#=========================================================================

execution() {
#set -x
	this_fail=0
	BEGIN=$1
	END=$2

	while [ $BEGIN -lt $END ] ; do
	        tet_infoline "Attempting to log in as $LEGAL_PREFIX$BEGIN"p""
	        export KRB5CCNAME=`dce_login_noexec $LEGAL_PREFIX$HOST$BEGIN"p" $SEC_LOGIN_PASSWD`
                case $OSTYPE in
 			"SVR4")
				echo $KRB5CCNAME | grep "FILE:/opt/dcelocal/var/security/creds/dc" > /dev/null ;;
			*)
	        		echo $KRB5CCNAME | grep "FILE:/opt/dcelocal/var/security/creds/dcecred" > /dev/null ;;
		esac

	        if [ $? != 0 ] ; then
	                tet_infoline "ERROR: Unable to login as account ${LEGAL_PREFIX}$HOST$BEGIN"p""
			this_fail=1
                        BEGIN=`expr "$BEGIN" + 1`
		else
	        	tet_infoline "Successfully logged in as $LEGAL_PREFIX$HOST$BEGIN"p" $SEC_LOGIN_PASSWD"
		        change_home_directory $LEGAL_PREFIX$HOST$BEGIN"p"\
		                $SEC_GROUP$HOST $SEC_ORG$HOST "$NEW_HOME_DIR$LEGAL_PREFIX$HOST$BEGIN"p""
			if [ $this_fail -ne 0 ] ; then
				this_fail=1
			fi

		        change_shell $LEGAL_PREFIX$HOST$BEGIN"p"\
		                $SEC_GROUP$HOST $SEC_ORG$HOST $NEW_SEC_SHELL
                        if [ $this_fail -ne 0 ] ; then
                                this_fail=1
                        fi

		        change_password $LEGAL_PREFIX$HOST$BEGIN"p" $SEC_ORG$HOST $SEC_GROUP$HOST\
		                $SEC_LOGIN_PASSWD $SEC_LOGIN_NEW_PASSWD
                        if [ $this_fail -ne 0 ] ; then
                                this_fail=1
                        fi

if [ $USE_ERA = yes ]; then
# called only by sestr so can use S_ATTR_NAME
			NEW_ATTR_VAL=$LEGAL_PREFIX${sestr_ctl_mach}$ATTR_NEW_VAL"val"
			change_attr principal $LEGAL_PREFIX$HOST$BEGIN"p" ${S_ATTR_NAME}${HOST} ${NEW_ATTR_VAL}
                        if [ $fail -ne 0 ] ; then
                                this_fail=1
                        fi
fi

		        # Remove authenticated tickets
			kdestroy
	                BEGIN=`expr "$BEGIN" + 1`
		fi
	done

	if [ $this_fail -ne 0 ] ; then
		return 1
	else 
		return 0
	fi

} # End execution

#=========================================================================
# Function:     login_il_person
# Purpose:
#=========================================================================

login_il_person() {
#set -x
	this_fail=0
	BEGIN=$1
	END=$2
	while [ $BEGIN -lt $END ]
	do
	        tet_infoline "Attempting to login as $ILLEGAL_PREFIX$HOST$BEGIN"p""
	        dce_login_noexec $ILLEGAL_PREFIX$HOST$BEGIN"p" $SEC_LOGIN_ILPASSWD | grep "Sorry" > /dev/null

		if [ $? -ne 0 ]
		then
			this_fail=1
	        	tet_infoline "ERROR: Unexpected login to illegal account $ILLEGAL_PREFIX$HOST$BEGIN"p"" 
			kdestroy
		else
	        	tet_infoline "Successfully unable to login as $ILLEGAL_PREFIX$HOST$BEGIN"p" AS EXPECTED"
		fi

	        BEGIN=`expr $BEGIN + 1`
	done
	
	if [ $this_fail -ne 0 ]
	then
		return 1
	else
		return 0
	fi

} # End login_il_person

#=========================================================================
# Function:     update_dir_shell_psswd
# Purpose:      To update home directory, shell, and password of the accounts
#               that were changed
#=========================================================================

update_dir_shell_psswd() {
#set -x
	TEMP=$SEC_HOME_DIR
	SEC_HOME_DIR=$NEW_HOME_DIR
	NEW_HOME_DIR=$TEMP

	TEMP=$SEC_SHELL
	SEC_SHELL=$NEW_SEC_SHELL
	NEW_SEC_SHELL=$TEMP

	TEMP=$SEC_LOGIN_PASSWD
	SEC_LOGIN_PASSWD=$SEC_LOGIN_NEW_PASSWD
	SEC_LOGIN_NEW_PASSWD=$TEMP

} # End update_dir_and_shell

#===============================================================================
# Function:	delete_objects -p <List of persons> -a <List of aliases> 
#		-g <List of groups> -o <List of organizations>
# Purpose:	Deletes all objects added to database
#		
#===============================================================================
delete_objects() {
#set -x

	# Delete objects from registry database
	# Checking for proper deletion is done within each function
	tet_infoline "Attempting to delete objects from database"

	# Initialize variable to execute a check on registry when deletion
	#	has been completed
	CHECK_STATE="state_of_rgy"

	while [ -n "${1}" ]
	do
	    case ${1} in

		-p) shift;
		    PERSONS="${1}"
		    CHECK_STATE="${CHECK_STATE} -p \"$1\""
		    shift;;

		-a) shift;
		    ALIASES="${1}"
		    CHECK_STATE="${CHECK_STATE} -a \"$1\""
		    shift;;

		-g) shift;
		    GROUPS="${1}"
		    CHECK_STATE="${CHECK_STATE} -g \"$1\""
		    shift;;

		-o) shift;
		    ORGS="${1}"
		    CHECK_STATE="${CHECK_STATE} -o \"$1\""
		    shift;;

	    esac
	done

	# Make sure that files ${RGY_INPUT} and ${RGY_OUTPUT} can be
	#  	created properly.
	touch ${RGY_OUTPUT}
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Unable to create file ${RGY_OUTPUT} in delete_objects"
		fail=1
		test_fail=1
		return 1
	fi

	# Create RGY_INPUT file

	cat << EOF > ${RGY_INPUT}
do p
`echo ${PERSONS} | awk '{for (i=1; i<=NF; i++) print "delete "$i; print "y"}'`
`echo ${ALIASES} | awk '{for (i=1; i<=NF; i++) print "delete "$i; print "y"}'`
do g
`echo ${GROUPS} | awk '{for (i=1; i<=NF; i++) print "delete "$i; print "y"}'`
do o
`echo ${ORGS} | awk '{for (i=1; i<=NF; i++) print "delete "$i; print "y"}'`
q
EOF

	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Unable to create file ${RGY_INPUT} in delete_objects"
		fail=1
		test_fail=1
		return 1
	fi

	# Execute rgy_edit
	execute_rgy
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Execute_rgy failed in delete_objects"
		fail=1
		test_fail=1
		return 1
	else
		tet_infoline "${RGY_EXEC} executed properly"
	fi

	# To verify proper deletion, call function state_of_rgy
	eval "${CHECK_STATE}"

	RETURN_CODE="$?"
	if [ "${RETURN_CODE}" != 0 ]
	then
		test_fail=1
		return "${RETURN_CODE}"
	fi

	tet_infoline "Objects created for testing have been removed from registry"
	return 0

} # End of function delete_objects


#===============================================================================
# Function:	add_objects_pol <Person UNIX ID> <Organization UNIX ID>
# Purpose:	Add all persons, aliases, groups and organizations to registry
#		for test DCESEACT
#
#===============================================================================
add_objects_pol() {
	# Add the required persons
	USER_ID=${1}
	add_person ${SEC_PREFIX}1p ${USER_ID}
	USER_ID=`expr ${USER_ID} + 1`
	add_person ${SEC_PREFIX}2p ${USER_ID}
	USER_ID=`expr ${USER_ID} + 1`
	add_person ${SEC_PREFIX}3p ${USER_ID}

	# Add the required organizations
	ORG_ID=${2}
	add_org ${SEC_PREFIX}1o ${ORG_ID}
	ORG_ID=`expr ${ORG_ID} + 1`
	add_org ${SEC_PREFIX}2o ${ORG_ID}
	ORG_ID=`expr ${ORG_ID} + 1`
	add_org ${SEC_PREFIX}3o ${ORG_ID}

	# Add the required accounts
	add_account "${SEC_PREFIX}1p" "none" "${SEC_PREFIX}1o"
	add_account "${SEC_PREFIX}2p" "none" "${SEC_PREFIX}2o"
	add_account "${SEC_PREFIX}3p" "none" "${SEC_PREFIX}3o"

} # End of function add_objects_pol

#===============================================================================
# Function:	add_objects_act <Person UNIX ID> <Group UNIX ID> <Org UNIX ID> 
# Purpose:	Add all persons, aliases, groups and organizations to registry
#		for test DCESEACT
#
#===============================================================================
add_objects_act () {

	# Add the required objects to registry database
	# Checking for proper entry is done within each function
	add_person ${SEC_PERSON} ${1}
	add_alias ${SEC_ALIAS} ${1}

	add_group ${SEC_GROUP} ${2}

	add_org	${SEC_ORG} ${3}

	add_account ${SEC_PERSON} ${SEC_GROUP} ${SEC_ORG}
	add_account ${SEC_ALIAS} ${SEC_GROUP} ${SEC_ORG}

} # End of function add_objects
#===============================================================================
# Function:	set_policies <Name of org> <Number of valid days> 
#		<-pls|-ped|-als>
# Purpose:	Set policies for organizations.  The options pls, ped, als
#		stand for "password life span", "password expiration date",
#		and "account life span", respectively.
#
#===============================================================================
set_policies() {
#set -x

	# Initialize all variables

	ACCOUNT_LS=""
	PASSWD_LS=""
	PASSWD_EX=""

	# Use a case statement to decide which policy you will be changing

	case ${3} in
	
		-pls) PASSWD_LS="${2}m";;
		
		-ped) PASSWD_EX="${2}";;

		-als) ACCOUNT_LS="${2}m";;

	esac
	
	# Create rgy_input file

	tet_infoline "Attempting to change policies for ${1}"

	# Create stdin batch file for adding user.
	# 
	cat << EOF > ${RGY_INPUT}
do o
c ${1}


y
${ACCOUNT_LS}

${PASSWD_LS}
${PASSWD_EX}



po ${1}

q
EOF

	# Execute file using the rgy_edit command.  Send the output to file 
	#	${RGY_OUTPUT}
	execute_rgy
	if [ "$?" != 0 ]
	then
                tet_infoline "ERROR: Execute_rgy failed in set_policies"
		fail=1
		return 1
	fi

	# Check output file for proper execution of command.
	# Cannot do at present time because there is no way of verifying.

	# Call function to report that the person has been added properly.
	#
	tet_infoline "Organization ${1}'s policies have been changed."
	return 0

} # End of program set_policies

#===============================================================================
# Function:	calc_valid_date <Number of valid days>
# Purpose:	Add the number of valid days to today's date, return the
#		new date
#
#===============================================================================
calc_valid_date() {
#set -x

	day=`expr \`date +%d\` + ${1}`
	month=`expr 1 \* \`date +%m\``
	year=`date +%y`
	
	# Use a case statement to calculate new date

	case ${month} in
		1|3|5|7|8|10|12) if [ "${day}" -gt 31 ] ; then
					month=`expr ${month} + 1`
					day=`expr ${day} - 31`
				 fi;;

		4|6|9|11)	 if [ "${day}" -gt 30 ] ; then
					month=`expr ${month} + 1`
					day=`expr ${day} - 30`
				 fi;;

		2)		 temp=`expr ${year} % 4`
				 if [ "${temp}" = 0 ] ; then
					if [ "${day}" -gt 29 ] ; then
						month=`expr ${month} + 1`
						day=`expr ${day} - 29`
					fi
				 else
					if [ "${day}" -gt 28 ] ; then
						month=`expr ${month} + 1`
						day=`expr ${day} - 28`
					fi
				 fi;;

	esac

	if [ "${month}" -gt 12 ] ; then
		year=`expr ${year} + 1`
		month=`expr ${month} - 12`
	fi

	NEWDATE="${year}/${month}/${day}"
	
	echo "${NEWDATE}"

	return 0

} # End of program calc_valid_date

#===============================================================================
# Function:	create_override <Name of Machine> <Name of Person> 
#		<Location of file>
# Purpose:	Adds entry to file to prohibit specified user from logging 
#		in to specified machine.
#
#===============================================================================
create_override() {

	# Use rshsp to login remotely to machines and create /etc/rgy/
	# 	passwd_override file.  
	tet_infoline "Attempting to create password override file on $1"
	rshsp ${1} touch ${3}
	if [ "$?" != 0 ]
	then
		tet_infoline "ERROR: Unable to create file passwd_override on ${1} in create_override"
		return 1
	else

		rshsp ${1} "grep \"${2}:exclude:::::\" < ${3}" > /dev/null
		if [ "$?" = 0 ]
		then
			tet_infoline "Override for ${2} already exists in file passwd_override in create_override"
			return 0
		else
			rshsp ${1} "echo \"${2}:exclude:::::\" >> ${3}"
			rshsp ${1} "grep "${2}:exclude:::::" < ${3}" > /dev/null
			if [ "$?" != 0 ]
			then	
				tet_infoline "ERROR: Unable to add to file passwd_override on machine ${1} in create_override"
				return 1
			else
				tet_infoline "Password override file has been created"
				return 0
			fi
		fi
	fi
} # End of function create_override

#===============================================================================
# Function:	verify_machines <List of Machines>
# Purpose:	Verify that the machines given in list exist on the network, 
#		and that they will work with cu.  If so, create a new list
# 		of legal machines.
#
#===============================================================================
verify_machines() {

	rm -f ${MACHINE_LIST_FILE}
	for i in $1
	do
		# Determine if machine exists on net
		case $OSTYPE in

			"AIX"|"SVR4")   ping $i 1 1 > /dev/null;;

			"OSF1")  ping -c 1 -s 1 $i > /dev/null;;

			"HP-UX") ping $i 8 1 > /dev/null;;

			*)       tet_infoline "OSTYPE = $OSTYPE unknown...";;
		esac

		if [ "$?" = 0 ]
		then
			echo ${i} >> ${MACHINE_LIST_FILE}
		else
			tet_infoline "Machine ${i} is not on the net (can't be pinged)"
		fi
	done

	# See if any machines are listed in the file.
	if [ -f ${MACHINE_LIST_FILE} ]
	then
		return 0
	else
		return 1
	fi
} # End of function verify_machines

#===============================================================================
# Function:	rlogin_to_machines <Name of Machines> <Name of Person>
#		<Name of Org> <Name of Group> <Person's Password>
#		<Person New Password>
# Purpose:	DCE login to remote machines as a Person, then change the
#		Person's password. Verify New password, then change it back.
#=============================================================================== 	
rlogin_to_machine() {
MACHINE_NAME=$1
NAMEP=$2
ORG=$3
GROUP=$4
PASSWD=$5
NEW_PASSWD=$6

        tet_infoline "Attempting to change ${NAMEP}'s password at $MACHINE_NAME"

        ${RSH_COMM} $MACHINE_NAME -n "dce_login $NAMEP $PASSWD -e /tmp/$TEST_CMD \
        'echo \"c -p $NAMEP -o $ORG -g $GROUP -mp $PASSWD -pw $NEW_PASSWD\"  | $RGY_EXEC'" \
                 > /tmp/seact$MACHINE_NAME 2>&1

        check_return "$?" "ERROR: Unable to change $NAMEP account's password at: $MACHINE_NAME (rlogin_to_machine 1)" \
                        "Was able to change $NAMEP account's password at: $MACHINE_NAME (rlogin_to_machine 1) AS EXPECTED"

        #
        # Wait for updates to propagate to slaves
        #
        sleep ${SEC_WAIT_TIME}

        ${RSH_COMM} $MACHINE_NAME  "dce_login $NAMEP $PASSWD -e /tmp/$TEST_FILE" | grep "Sorry" \
                >> /tmp/seact$MACHINE_NAME 2>&1
        check_return "$?" "ERROR: $NAMEP account's password was not changed at: $MACHINE_NAME (rlogin_to_machine 2)" \
                        "$NAMEP account's password was changed at: $MACHINE_NAME (rlogin_to_machine 2) AS EXPECTED"

        ${RSH_COMM}  $MACHINE_NAME "dce_login $NAMEP $NEW_PASSWD -e /tmp/$TEST_FILE" \
                |grep "Principal:" | grep -v "Global" |egrep "$NAMEP"  \
                >> /tmp/seact$MACHINE_NAME 2>&1
        check_return "$?" "ERROR: Cannot verify $NAMEP account's new password at: $MACHINE_NAME (rlogin_to_machine 3)" \
                        "Verified $NAMEP account's new password at: $MACHINE_NAME (rlogin_to_machine 3) AS EXPECTED"

tet_infoline "/tmp/seact$MACHINE_NAME"
while read LINE;do
        tet_infoline "$LINE"
done < /tmp/seact$MACHINE_NAME
date >/tmp/swap
#/etc/swapinfo >>/tmp/swap
/bin/df >> /tmp/df_l
while read LINE;do
        tet_infoline "$LINE"
done < /tmp/df_l

rm /tmp/seact$MACHINE_NAME /tmp/df_l

} # End of function rlogin_to_machine

#===============================================================================
# Function:	remote_login <Name of Machine> <Name of Person>
#		<Person's Password>
# Purpose:	Attempt DCE login to a remote machine as a Person/Account and
#		evaluate the result
# Return Codes:
#		0 = Login successful
#		1 = Login successful but password has expired
#		2 = Login unsuccessful because the account has expired
#		3 = Login unsuccessful because the account did not exist
#		4 = Login unsuccessful because the password is invalid, also
#		    caused by ./etc/passwd_override entry
#		99 = Login unsuccessful because of some other reason
#=============================================================================== 	
remote_login() {

MACHINE_NAME=$1
NAMEP=$2
PASSWD=$3

tet_infoline "Attempting login as ${NAMEP} on ${MACHINE_NAME}"

# Must use -c for certification - uses passwd_override file -
# otherwise, ignores it

LOGIN_RESULT=`rshsp ${MACHINE_NAME} \
        "dce_login_noexec -c ${NAMEP} ${PASSWD}" 2>&1`
LOGIN_RESULT=`echo ${LOGIN_RESULT} | sed s/\\\n//`

case ${LOGIN_RESULT} in
  "FILE:${DCELOCAL}"*)
	tet_infoline "${NAMEP} login on ${MACHINE_NAME} SUCCESSFUL"
	remove_KRB5CCNAME "${MACHINE_NAME}" "${LOGIN_RESULT}"
	return 0
	;;
  "Password must be changed! FILE:${DCELOCAL}"*)
	tet_infoline "SUCCESSFUL ${NAMEP} login on ${MACHINE_NAME}, but password is expired"
	remove_KRB5CCNAME "${MACHINE_NAME}" "${LOGIN_RESULT}"
	return 1
	;;
  "Sorry. Password Validation Failure. - Password has expired"*)
	tet_infoline "UNSUCCESSFUL ${NAMEP} login on ${MACHINE_NAME} caused by:"
	tet_infoline "${LOGIN_RESULT}"
	return 1
	;;
  "Sorry. Password Validation Failure. - account not valid for login"*)
	tet_infoline "UNSUCCESSFUL ${NAMEP} login on ${MACHINE_NAME} caused by:"
	tet_infoline "${LOGIN_RESULT}"
	return 2
	;;
  "Sorry. Password Validation Failure. - Client's entry in database has expired"*)
	tet_infoline "UNSUCCESSFUL ${NAMEP} login on ${MACHINE_NAME} caused by:"
	tet_infoline "${LOGIN_RESULT}"
	return 2
	;;
  "Sorry. User Identification Failure. - Registry object not found"*)
	tet_infoline "UNSUCCESSFUL ${NAMEP} login on ${MACHINE_NAME} caused by:"
	tet_infoline "${LOGIN_RESULT}"
	return 3
	;;
  "Sorry. Password Validation Failure. - Invalid password"*)
	tet_infoline "UNSUCCESSFUL ${NAMEP} login on ${MACHINE_NAME} caused by:"
	tet_infoline "${LOGIN_RESULT}"
	return 4
	;;
  *)
	tet_infoline "UNSUCCESSFUL ${NAMEP} login on ${MACHINE_NAME} caused by:"
	tet_infoline "${LOGIN_RESULT}"
	return 99
	;;
esac

} # End of function remote_login

#===============================================================================
# Function:     remove_KRB5CCNAME machine KRB5CCNAME
# Purpose:	To remove files that were created when authenticated the cell
#===============================================================================

remove_KRB5CCNAME() {

KRB5_HOST=${1}
KRB5=${2}

	FILE=`echo ${KRB5} | awk -F: '{print $NF}'`

	tet_infoline "Removing ${FILE}* on ${KRB5_HOST}"

	if [ "${KRB5_HOST}" = "`hostname`" ] ; then
		rm -f ${FILE}*
		STATUS=$?
	else
		${RSH_COMM} ${KRB5_HOST} "rm -f ${FILE}*"
		STATUS=$?
	fi

	if [ ${STATUS} -ne 0 ] ; then
		tet_infoline "WARNING: ${FILE} NOT removed on ${KRB5_HOST}"
	fi

} # End of remove_KRB5CCNAME

#===============================================================================
# Function:	remove_objects
# Purpose:	To remove all objects that were created in the registry database
#		(principals, organizations, groups, and accounts)
#===============================================================================

remove_objects() {
#set -x

        # Remove objects from registry database
        # Checking for proper deletion is done within each function
        tet_infoline "Attempting to remove objects from database"

        # Initialize variable to execute a check on registry when deletion
        #       has been completed
        CHECK_STATE="state_of_rgy"

        while [ -n "${1}" ]
        do
            case ${1} in

                -p) shift;
                    PERSONS="${1}"
                    CHECK_STATE="${CHECK_STATE} -p \"$1\""
                    shift;;

                -g) shift;
                    GROUPS="${1}"
                    CHECK_STATE="${CHECK_STATE} -g \"$1\""
                    shift;;

                -o) shift;
                    ORGS="${1}"
                    CHECK_STATE="${CHECK_STATE} -o \"$1\""
                    shift;;

	        -l) shift;
		    PREFIX="${1}"
		    shift;;

	       	-n) shift;
		    NUMBER_PREFIX="${1}"
		    shift;;

            esac
        done

        # Make sure that files ${RGY_INPUT} and ${RGY_OUTPUT} can be
        #       created properly.
        touch ${RGY_OUTPUT}
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Unable to create file ${RGY_OUTPUT} in remove_objects"
		fail=1
                return 1
        fi

        # Create RGY_INPUT file

        cat << EOF > ${RGY_INPUT}
do g
del $GROUPS
do o
del $ORGS
do p
EOF

	COUNT=0
	while [ $COUNT -lt $NUMBER_PREFIX ]
	do
		echo "del $PREFIX$COUNT"p"" >> ${RGY_INPUT}
		COUNT=`expr $COUNT + 1`
	done

	echo "q" >> ${RGY_INPUT}
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Unable to create file ${RGY_INPUT} in remove_objects"
		fail=1
                return 1
        fi
        # Execute rgy_edit
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in remove_objects"
		fail=1
                return 1
        else
                tet_infoline "${RGY_EXEC} executed properly"
        fi
        # To verify proper deletion, call function state_of_rgy
        eval "${CHECK_STATE}"

        RETURN_CODE="$?"
        if [ "${RETURN_CODE}" != 0 ]
        then
                return "${RETURN_CODE}"
        fi

        tet_infoline "All objects $PREFIX"XXp" have been removed from registry"
        return 0

} # End of function remove_objects

#===============================================================================
# Function:     delete_acl_obj
# Purpose:      To remove all objects that were created in the registry database
#               (principals, organizations, groups, and accounts)
#===============================================================================
delete_acl_obj() {
#set -x

        # Remove objects from registry database
        # Checking for proper deletion is done within each function
        tet_infoline "Attempting to remove objects from database"

        # Initialize variable to execute a check on registry when deletion
        #       has been completed
        CHECK_STATE="state_of_rgy"

        while [ -n "${1}" ]
        do
            case ${1} in

                -p) shift;
                    PERSONS="${1}"
                    CHECK_STATE="${CHECK_STATE} -p \"$1\""
                    shift;;

                -g) shift;
                    GROUPS="${1}"
                    CHECK_STATE="${CHECK_STATE} -g \"$1\""
                    shift;;

                -o) shift;
                    ORGS="${1}"
                    CHECK_STATE="${CHECK_STATE} -o \"$1\""
                    shift;;

                -l) shift;
                    PREFIX="${1}"
                    shift;;

                -n) shift;
                    NUMBER_PREFIX="${1}"
                    shift;;

            esac
        done

        # Make sure that files ${RGY_INPUT} and ${RGY_OUTPUT} can be
        #       created properly.
        touch ${RGY_OUTPUT}
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Unable to create file ${RGY_OUTPUT} in delete_acl_object"
		fail=1
                return 1
        fi

        # Create RGY_INPUT file

        cat << EOF > ${RGY_INPUT}
do g
del $GROUPS
do o
del $ORGS
do p
del $PERSONS
EOF

        COUNT=0
        while [ $COUNT -lt $NUMBER_PREFIX ]
        do
                echo "del $PREFIX$COUNT" >> ${RGY_INPUT}
                COUNT=`expr $COUNT + 1`
        done

        echo "q" >> ${RGY_INPUT}
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Unable to create file ${RGY_INPUT} in delete_acl_object"
		fail=1
                return 1
        fi
        # Execute rgy_edit
        execute_rgy
        if [ "$?" != 0 ]
        then
                tet_infoline "ERROR: Execute_rgy failed in delete_acl_object"
		fail=1
                return 1
        else
                tet_infoline "${RGY_EXEC} executed properly"
        fi
        # To verify proper deletion, call function state_of_rgy
        eval "${CHECK_STATE}"

        RETURN_CODE="$?"
        if [ "${RETURN_CODE}" != 0 ]
        then
                return "${RETURN_CODE}"
        fi

        tet_infoline "All objects $PREFIX"XX" have been removed from registry"
        return 0

} # End of function delete_acl_obj

#===============================================================================
# Function: 	check_status
# Purpose: 	To monitor all machines in the network whether they all finish
#		testing.
#===============================================================================

check_status () {

MACHINE_NAME="$1"
END="$2"
COUNT=0
tet_infoline "Monitoring activities at remote machines"
while :
do
	for MACHINE in $MACHINE_NAME
	do
		# added grep -v to avoid problems remsh'ing to oneself
if [[ `uname` = "HP-UX" ]]
then
		remsh $MACHINE "ps -ef" | grep "dce_login_noexec" | grep -v "grep" > /dev/null
else
		rsh $MACHINE "ps -ef" | grep "dce_login_noexec" | grep -v "grep" > /dev/null
fi
		if [ $? != 0 ]
		then
			COUNT=`expr $COUNT + 1`
		else
			COUNT=0
		fi
	done
       	if [ $COUNT -gt $END ]
       	then
       		tet_infoline "Activities at all remote machines are done"
		return 0
	fi
done
} # End of check_status

#===============================================================================
# Function: 	prompt_for_input
# Purpose:	Print out messages to execute file at remote machines, then
#		wait for command input whether to continue or to exit program
#===============================================================================
prompt_for_input() {

MACHINE_NAMES="$1"
FILE="$2"
DIR="$3"
MAX="$4"

	tet_infoline "Time to execute $FILE at the remote machines"
	echo ""; echo ""
	echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
	echo ""
        echo "GO TO THE FOLLOWING MACHINES: "
	echo ""
	for MACHINE in $MACHINE_NAMES
        do
		echo "     Machine:  $MACHINE"
        done
	echo ""
	echo "AND DO THE FOLLOWING:"
	echo ""
#	echo "     Make sure SEC_TIME in \$TET_ROOT/security/ts/dcesestr/dcesestr.data is set"
#	echo "     to the number of hours you want continuous login."
#	echo "     Remember: the first hour may not be a full hour."
#	echo ""
#	echo "     Make sure SEC_BEGIN and SEC_MAX in above file are also set and do not overlap"
#	echo "     from machine to machine."
#	echo ""
	echo "     Remember to source \$TET_ROOT/profile.dcest"
	echo ""
	echo "     Type: "$FILE""
	echo ""
	echo "		WHERE X is the number of hours of continuous login"
	echo "          WHERE Y is the beginning prefix."
	echo "          WHERE Z is the ending prefix."
	echo "          Remember Y and Z must be unique for each machine"
	echo "		ex: for machine_a:	 -b 0 -x 2"
	echo "		        machine_b:	 -b 3 -x 5"
	echo "		    maximum number is 9 (10 users) unless you change it in dcesestr.data file"
	echo "		    prior to starting the dcesestr test."		
	echo ""
	echo "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
	echo ""
	echo "Enter <y> after executing the command at the above machines: \c"
	read command
	echo ""
	while [ $command != "y" ]
	do
        	echo "Enter <y> to continue or <e> to exit testing: \c"
        	read command
        	if [ $command = "e" ]
        	then
                	echo "Exiting Program"
			return 1
        	fi
	done
} # End of prompt_for_input

#===============================================================================
# Function:     test_acl_perm_and_entry
# Purpose:      Testing ACL Managers entry types and permissions
#===============================================================================

test_acl_perm_and_entry() {

PRINC=$1
GROUP=$2
ORG=$3
        tet_infoline "Start testing ACL Directory/Policy entry type and permissions"
	tet_infoline " Testing invalid ACL entry types for directory"
	acl_edit /.:/sec/principal -m user_obj:r > ${RGY_OUTPUT} 2>&1
	check_neg_return "$?" "ERROR: Able to add invalid ACL entry type for directory in test_acl_perm_and_entry"
        acl_edit /.:/sec/principal -m group_obj:r > ${RGY_OUTPUT} 2>&1 
	check_neg_return "$?" "ERROR: Able to add invalid ACL entry type for directory in test_acl_perm_and_entry"
        acl_edit /.:/sec/group -m user_obj:r > ${RGY_OUTPUT} 2>&1 
	check_neg_return "$?" "ERROR: Able to add invalid ACL entry type for directory in test_acl_perm_and_entry"
        acl_edit /.:/sec/group -m group_obj:r > ${RGY_OUTPUT} 2>&1 
	check_neg_return "$?" "ERROR: Able to add invalid ACL entry type for directory in test_acl_perm_and_entry"
	acl_edit /.:/sec/org -m user_obj:r > ${RGY_OUTPUT} 2>&1 
	check_neg_return "$?" "ERROR: Able to add invalid ACL entry type for directory in test_acl_perm_and_entry"
        acl_edit /.:/sec/org -m group_obj:r > ${RGY_OUTPUT} 2>&1 
	check_neg_return "$?" "ERROR: Able to add invalid ACL entry type for directory in test_acl_perm_and_entry"

	tet_infoline " Testing invalid permissions for directory"
        acl_edit /.:/sec/principal -m unauthenticated:a > ${RGY_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid permissions to sec/prin for directory in test_acl_perm_and_entry"
        acl_edit /.:/sec/group -m unauthenticated:a > ${RGY_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid permissions to sec/group for directory in test_acl_perm_and_entry"
        acl_edit /.:/sec/org -m unauthenticated:a > ${RGY_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid permissions to sec/org for directory in test_acl_perm_and_entry"

	if [ $fail -eq 0 ]
	then
		tet_infoline "Successfully tested invalid ACL entry types and permissions for directory"
	else
		tet_infoline "ERROR: in testing invalid ACL entry types and permissions for directory \
				in test_acl_perm_and_entry"
		test_fail=1
		fail=0
	fi

	tet_infoline "Testing invalid ACL entry types for policy"

	acl_edit /.:/sec/policy -m user_obj:r > ${RGY_OUTPUT} 2>&1 
        check_neg_return "$?" "ERROR: Able to add invalid ACL entry type for policy in test_acl_perm_and_entry"

        acl_edit /.:/sec/policy -m group_obj:r > ${RGY_OUTPUT} 2>&1 
        check_neg_return "$?" "ERROR: Able to add invalid ACL entry type for policy in test_acl_perm_and_entry"

        tet_infoline "Testing invalid permissions for policy"
        acl_edit /.:/sec/policy -m unauthenticated:i > ${RGY_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid permissions to sec/policy in test_acl_perm_and_entry"

        if [ $fail -eq 0 ]
        then
                tet_infoline "Successfully tested invalid ACL entry types and permissions for policy"
        else
                tet_infoline "ERROR: in testing invalid ACL entry types and permissions for policy in test_acl_perm_and_entry"
                test_fail=1
		fail=0
        fi

        tet_infoline "Start testing ACL principal entry type and permissions"
        tet_infoline "Testing invalid ACL entry types for principal"

        acl_edit /.:/sec/principal/$PRINC -m group_obj:r > ${RGY_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid ACL entry type for principal in test_acl_perm_and_entry"

        tet_infoline "Testing invalid permissions for principal"

        acl_edit /.:/sec/principal/$PRINC -m unauthenticated:i > ${RGY_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid permissions to sec/principal in test_acl_perm_and_entry"

        if [ $fail -eq 0 ]
        then
                tet_infoline "Successfully tested invalid ACL entry types and permissions for principal"
        else
                tet_infoline "ERROR: in testing invalid ACL entry types and permissions for principal in test_acl_perm_and_entry"
                test_fail=1
		fail=0
        fi

        tet_infoline "Start testing ACL group entry type and permissions"
        tet_infoline "Testing invalid ACL entry types for group"

        acl_edit /.:/sec/group/$GROUP -m user_obj:r > ${RGY_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid ACL entry type for group in test_acl_perm_and_entry"

        tet_infoline "Testing invalid permissions for group"
        acl_edit /.:/sec/group/$GROUP -m unauthenticated:i > ${RGY_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid permissions to sec/group in test_acl_perm_and_entry"

        if [ $fail -eq 0 ]
        then
                tet_infoline "Successfully tested invalid ACL entry types and permissions for group"
        else
                tet_infoline "ERROR: in testing invalid ACL entry types and permissions for group in test_acl_perm_and_entry"
                test_fail=1
		fail=0
        fi

        tet_infoline "Start testing ACL organization entry type and permissions"
        tet_infoline "Testing invalid ACL entry types for organization"

        acl_edit /.:/sec/org/$ORG -m user_obj:r > ${RGY_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid ACL entry type for organization in test_acl_perm_and_entry"

        acl_edit /.:/sec/org/$ORG -m group_obj:r > ${RGY_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid ACL entry type for organization in test_acl_perm_and_entry"

        tet_infoline "Testing invalid permissions for organization"
        acl_edit /.:/sec/org/$ORG -m unauthenticated:i > ${RGY_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid permissions to sec/org in test_acl_perm_and_entry"

        if [ $fail -eq 0 ]
        then
                tet_infoline "Successfully tested invalid ACL entry types and permissions for organization"
        else
                tet_infoline "ERROR: in testing invalid ACL entry types and permissions for organization \
				in test_acl_perm_and_entry"
                test_fail=1
        fi

if [ $USE_ERA = yes ]; then

	# This goes one step further than the existing test does for the other objects
	#  - Test having the appropriate ACLs to change the ACLs on the schema object ("c")
	#    First remove them from the admin, then let admin try to add ACLs for another principal

	DCECP_CMD="acl modify /.:/sec/xattrschema -remove {user $ADMIN_PRIN}"
	dcecp -c ${DCECP_CMD} > ${DCECP_OUTPUT} 2>&1
	check_return "$?" "ERROR: Unable to delete permission to /.:/sec/xattrschema for $ADMIN_PRIN" \
                                "Able to delete permission to /.:/sec/xattrschema for $ADMIN_PRIN"
	
	kdestroy; dce_auth $ADMIN_PRIN $SEC_LOGIN_PASSWD

	DCECP_CMD="acl modify /.:/sec/xattrschema -add {user $PRIN$ID r}"
	dcecp -c ${DCECP_CMD} > ${DCECP_OUTPUT} 2>&1
	check_neg_return "$?" "ERROR: Able to add ACL to schema directory in test_acl_perm_and_entry without permission"
	
	# Authenticate the cell by cell_admin
	kdestroy; dce_auth $PARENT_ACCOUNT $PARENT_PASSWD
	
	DCECP_CMD="acl modify /.:/sec/xattrschema -add {user $ADMIN_PRIN c}"
	dcecp -c ${DCECP_CMD} > ${DCECP_OUTPUT} 2>&1
	check_return "$?" "ERROR: Unable to add control permission to /.:/sec/xattrschema for $ADMIN_PRIN" \
				"Able to add control permission to /.:/sec/xattrschema for $ADMIN_PRIN"

	kdestroy; dce_auth $ADMIN_PRIN $SEC_LOGIN_PASSWD

	# Now we should be able to change the ACLs with c permission
	DCECP_CMD="acl modify /.:/sec/xattrschema -add {user $PRIN$ID r}"
	dcecp -c ${DCECP_CMD} > ${DCECP_OUTPUT} 2>&1
	check_return "$?" "ERROR: Unable to modify ACL on schema directory in test_acl_perm_and_entry with c permission" \
				"Able to modify ACL on schema directory in test_acl_perm_and_entry with c permission"

	# go back to being cell_admin 
	kdestroy; dce_auth $PARENT_ACCOUNT $PARENT_PASSWD

	
#NOTE is this really a valid test? It's not in the spec, I'm just guessing based on others here...
	tet_infoline "Testing invalid ACL entry types for xattrschema directory"

	DCECP_CMD="acl modify /.:/sec/xattrschema -add {user_obj r}"
	dcecp -c ${DCECP_CMD} > ${DCECP_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid ACL entry type user_obj for schema directory in test_acl_perm_and_entry"

	DCECP_CMD="acl modify /.:/sec/xattrschema -add {group_obj r}"
	dcecp -c ${DCECP_CMD} > ${DCECP_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid ACL entry type group_obj for schema directory in test_acl_perm_and_entry"

        tet_infoline "Testing invalid permissions for schema directory"
	DCECP_CMD="acl modify /.:/sec/xattrschema -add {unauthenticated i}"
	dcecp -c ${DCECP_CMD} > ${DCECP_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid permissions i to sec/schema directory in test_acl_perm_and_entry"

        if [ $fail -eq 0 ]
        then
                tet_infoline "Successfully tested invalid ACL entry types and permissions for schema directory"
        else
                tet_infoline "ERROR: in testing invalid ACL entry types and permissions for schema directory in test_acl_perm_and_entry"
                test_fail=1
		fail=0
        fi

	tet_infoline "Testing invalid ACL entry types for schema object"
	SCHEMA=$4

	DCECP_CMD="acl modify /.:/sec/xattrschema/$SCHEMA -add {user_obj r}"
	dcecp -c ${DCECP_CMD} > ${DCECP_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid ACL entry type user_obj for schema object in test_acl_perm_and_entry"

	DCECP_CMD="acl modify /.:/sec/xattrschema/$SCHEMA -add {group_obj r}"
	dcecp -c ${DCECP_CMD} > ${DCECP_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid ACL entry type group_obj for schema object in test_acl_perm_and_entry"

        tet_infoline "Testing invalid permissions for xattrschema object"
	DCECP_CMD="acl modify /.:/sec/xattrschema/$SCHEMA -add {unauthenticated i}"
	dcecp -c ${DCECP_CMD} > ${DCECP_OUTPUT} 2>&1
        check_neg_return "$?" "ERROR: Able to add invalid permissions i to sec/xattrschema/object in test_acl_perm_and_entry"

        if [ $fail -eq 0 ]
        then
                tet_infoline "Successfully tested invalid ACL entry types and permissions for schema object"
        else
                tet_infoline "ERROR: in testing invalid ACL entry types and permissions for schema object in test_acl_perm_and_entry"
                test_fail=1
		fail=0
        fi

fi # ERA

} #End of test_acl_perm_and_entry

#===============================================================================
#
# Wait for the client processes to complete.
#
#===============================================================================

wait_for_clients()
{
	tet_infoline "wait_for_clients: Waiting for client processes to finish"
	#echo "PIDS = ${PIDS}"
	for PID in ${PIDS} ; do
		echo "Waiting for pid = ${PID} to complete...\c"
		wait ${PID}
		echo "done"
	done
	tet_infoline "wait_for_clients: Client processes finished"
}
