/* ______________________________________________________________________
 * Copyright (c) 1996 The Open Group, Inc., Cambridge, MA USA
 * All rights reserved.
 * ______________________________________________________________________
 *
 *  MODULE:
 *  m o s _ t a l k . c
 *
 *  DESCRIPTION:
 *  Client interfaces for Conversation Management to support the 
 *  Message Oriented Service Application Programming Interface(MOS-API).
 *
 * ______________________________________________________________________
 *
 * $Log: mos_talk.c,v $
 * Revision 1.13  1996/11/26  17:16:55  bowe
 * In call to mos_q_move_item(), add flags param.
 *
 * Revision 1.12  1996/11/21  14:39:14  salamone
 * Use new RPC mos_q_move_item() for msg move
 *
 * Revision 1.11  96/11/20  18:26:51  18:26:51  salamone (Julie Salamone)
 * Update flags desc
 * 
 * Revision 1.10  96/11/20  14:48:30  14:48:30  salamone (Julie Salamone)
 * Fix header file declarations
 * 
 * Revision 1.9  96/11/20  14:19:41  14:19:41  salamone (Julie Salamone)
 * Support empty message buffer
 * 
 * Revision 1.8  96/11/20  11:41:08  11:41:08  salamone (Julie Salamone)
 * Provide support for callers to explicitly decode msgs
 * 
 * Revision 1.7  96/11/11  17:05:24  17:05:24  salamone (Julie Salamone)
 * Clean-up mos__msg_get()
 * 
 * Revision 1.6  96/11/07  18:04:09  18:04:09  salamone (Julie Salamone)
 * Add msg move and que move support
 * 
 * Revision 1.5  96/10/25  14:42:42  14:42:42  salamone (Julie Salamone)
 * Add rsrc protectlvl support
 * 
 * Revision 1.4  96/10/23  16:12:22  16:12:22  salamone (Julie Salamone)
 * Add selection filter support
 * 
 * Revision 1.3  96/10/16  17:05:18  17:05:18  salamone (Julie Salamone)
 * Added resource error codes
 * 
 * Revision 1.2  96/10/15  16:16:13  16:16:13  salamone (Julie Salamone)
 * Added mos_msg_peek()/mos_msg_delete() support
 * 
 * Revision 1.1  96/10/14  16:56:32  16:56:32  salamone (Julie Salamone)
 * Initial revision
 * 
 * $EndLog$
 * ______________________________________________________________________
 */


/*
 * INCLUDE FILES
 */
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <dce/dce.h>
#include <dce/dce_msg.h>
#include <dce/dce_svc.h>
#include <dce/nbase.h>
#include <dce/assert.h>
#include <dce/aclif.h>
#include <dce/utc.h>
#include <dce/id_epac.h>
#include <dce/idl_es.h>

#include <mosif.h>
#include <mos_api.h>
#include <mos_base.h>
#include <mos_q.h>
#include <dcemosmsg.h>
#include <dcemosmac.h>
#include <dcemossvc.h>

static mos_datatype_bytearray_t   null_msg_buf;  /* NULL msg buffer */

/*
 * INTERNAL PROTOTYPES
 */
boolean mos__find_mask_by_type(mos_mask_list_t *, 
                               mos_msg_selmask_type_t, 
                               mos_mask_t **);
void mos__msg_get(mos_handle_t, boolean, unsigned32, mos_msg_selfilter_t, mos_msg_attr_t *, mos_msg_buf_t *, error_status_t *);


/*
 *  FUNCTION:
 *  m o s _ m s g _ e n q u e u e
 *
 *  OVERVIEW:
 *  Enqueue one message to a queue.
 *  The caller must have the proper access rights to enqueue a 
 *  message to a queue.
 *
 *  INPUTS:
 *  resource_handle:
 *                  A context handle to a resource.
 *                  To speed look-ups, a context handle to an NSI group
 *                  or profile is prohibited.
 *
 *  flags:
 *                  Indicates the message delivery mode. Only one option
 *                  is allowed to be specified.
 *                  The default is mos_c_enqmode_async.
 * 
 *  msg_attributes:
 *                  Use the utilities to allocate, set, and free message
 *                  attributes. This interface was provided so that the
 *                  application developer does not have to know what the
 *                  message attribute structure looks like and allows
 *                  flexibility to provide future message attributes.
 *
 *                  If NULL is specified, the API automatically allocates
 *                  and set all defaults for the message attributes.
 *                  Otherwise, it is the caller's responsibility to release
 *                  the memory allocated for the message attributes structure
 *                  via mos_msg_attr_free().
 *
 *  msg_buffer:
 *                  Opaque pointer to application-specific buffer contents.
 *                  An empty message buffer is supported. The queue manager
 *                  does not care about its contents and the application
 *                  designer could be using an empty message to signal an
 *                  event.
 *
 *  OUTPUTS:
 *  msg_id:
 *                  Unique message ID generated by the send API operations.
 *
 *  status:
 *                  A pointer to the completion status. On successful
 *                  completion, the routine returns error_status_ok.
 *                  Otherwise, it returns an error.
 *
 *  RETURNS:        None
 */
void
mos_msg_enqueue(
                mos_handle_t             resource_handle,
                unsigned32               flags,
                mos_msg_attr_t           msg_attributes,
                void *                   msg_buffer,
                uuid_t *                 msg_id,
                error_status_t *         status
               )
{
    error_status_t                 temp_status;
    boolean                        api_msg_attr_alloc = FALSE;
    boolean                        api_msg_buf_alloc = FALSE;
    mos_datatype_info_t *          datatype_info_p;
    mos_datatype_bytearray_t       msg_body; 
    mos_datatype_bytearray_t *     msg_body_p; 
    idl_es_handle_t                eh = NULL;
    idl_ulong_int                  esize;
    idl_byte                       *ep;

    /*
     * Initialize output parameters
     */
    uuid_create_nil(msg_id, status);     /* set output msg UUID to NIL */
    CLEAR_STATUS(status);

    /* 
     * Validate handle
     */
    if (! mos__is_rsrc_handle_valid(TRUE, resource_handle, status)) {
       return;
    }

    /* 
     * Validate enqueue mode flags.
     */
    if (! mos__is_enqmode_valid(flags, status)) {
       return;
    }
     
    /* 
     * Determine if "msg_attributes" is NULL.
     * If NULL is specified, API automatically allocates and sets all 
     * defaults for the message attributes.
     * Otherwise, it is the caller's responsibility to release
     * the memory allocated for the message attributes structure
     * via mos_msg_attr_free().
     */
    if (msg_attributes == NULL) {
       api_msg_attr_alloc = TRUE;
       mos_msg_attr_alloc(&msg_attributes, status); 
       if (BAD_STATUS(status)) {
          return;
       }
    }

    /* 
     * Determine if "msg_buffer" is NULL.
     * If NULL is specified, API automatically allocates and initializes
     * an empty default datatype structure.
     */
    if (msg_buffer == NULL) {
       api_msg_buf_alloc = TRUE;
       msg_body_p = 
          (mos_datatype_bytearray_t *)malloc(sizeof(mos_datatype_bytearray_t));
       if (msg_body_p == NULL) {
          SET_STATUS(status, mos_s_no_memory);
          if (api_msg_attr_alloc) 
             mos_msg_attr_free(&msg_attributes, &temp_status);
          return;
       }
       *msg_body_p = null_msg_buf;
    }


    /*
     * Generate a unique message ID for the message and place it 
     * in the message attributes area of the message.
     */
    if (GOOD_STATUS(status)) {
       uuid_create(&msg_attributes->id, status);
    }

    /* 
     * If message queuing model, this API uses the end-to-end protection 
     * level in the message attributes area of the message to set the 
     * protection level bewteen sender and Q-mgr on every send operation.
     */
    if (GOOD_STATUS(status)) {
        mos__auth_info_set(resource_handle, msg_attributes->protectlvl, status);
    }

    /* 
     * Determine if data is to be encoded.
     * The default data type is an array of bytes. It has a NIL UUID as a
     * data type value. In this case, there is no encoding/decoding performed 
     * by the messaging system.
     * Otherwise, invoke the registered conversion function associated with 
     * the data type specified in the message attributes to encode the 
     * "msg_buffer".
     */
    if (GOOD_STATUS(status) && msg_buffer) {
        if (uuid_is_nil(&msg_attributes->datatype, status)) {
            msg_body_p = (mos_datatype_bytearray_t *)msg_buffer;
        } else {
            /* 
             * Search our list of registered datatypes for conversion function 
             */
            if (mos__is_datatype_found(&msg_attributes->datatype, 
                                       &datatype_info_p)){
                /* Call encoding  services to encode data */
                idl_es_encode_dyn_buffer(&ep, &esize, &eh, status);
                if (GOOD_STATUS(status)) {
                    /* Call conversion function */
                    datatype_info_p->conv_fn(eh,
                                             (void *)msg_buffer,
                                             status);
                }
                if (GOOD_STATUS(status)) {
                    msg_body_p = &msg_body;
                    msg_body_p->data = ep;
                    msg_body_p->size = esize;
                }
            } else {
                SET_STATUS(status, mos_s_no_datatype_reg);  
            }
        }
    } /* End of if GOOD_STATUS(status) */

    /* 
     * XXX Process enqueue mode flags.
     */

    /* 
     * The "msg_buffer" and its "msg_attributes" are sent to
     * the specified resource via the server handle and queue name.
     *
     * An empty message buffer is supported. The queue manager does not 
     * care about its contents and the application designer could be using 
     * an empty message to signal an event.
     */
    if (GOOD_STATUS(status)) {
        mos_q_enqueue(resource_handle->server_handle, 
                      resource_handle->resource_name, 
                      msg_attributes, 
                      msg_body_p, 
                      flags,
                      msg_id, 
                      status);
    }

    /*
     * Release resources.
     * If we allocated the message attributes structure, then we'll free it.
     */
    if (api_msg_attr_alloc) 
       mos_msg_attr_free(&msg_attributes, &temp_status);
    if (api_msg_buf_alloc) 
       mos_msg_buf_free(&msg_body_p, &temp_status);
    if (eh)
        idl_es_handle_free(&eh, &temp_status);

    return;

} /* End of mos_msg_enqueue() routine */


/*
 *  FUNCTION:
 *  m o s _ m s g _ d e q u e u e
 *
 *  OVERVIEW:
 *  Dequeue one message from a queue.
 *  The queue manager returns the application-specific message
 *  buffer along with its message attributes and deletes the
 *  message from its queue.
 *
 *  The caller must have the proper access rights to dequeue a
 *  message from a queue.
 *
 *  INPUTS:
 *  resource_handle:
 *                  A context handle to a resource.
 *                  To speed look-ups, a context handle to an NSI group
 *                  or profile is prohibited.
 *
 *  flags:
 *                  Indicates the message retrieval mode. Only one option
 *                  is allowed to be specified.
 *                  The default is mos_c_deqmode_nowait.
 *
 *  msg_selection_filter:
 *                  This is a pointer to the selection filter structure.
 *                  Use the mos_msg_selfilter_alloc(), mos_msg_selfilter_free(),
 *                  and mos_msg_selmask_add() APIs to allocate, deallocate and
 *                  define one or more selection criteria. A message is
 *                  successfully retrieved following the rules of the logical
 *                  AND operator among all specified criteria.
 *
 *                  A NULL value indicates no selection criteria and the
 *                  message at the top of the specified queue is returned.
 *
 *  OUTPUTS:
 *  msg_attributes:
 *                  Use the utilities to get message attributes. This
 *                  interface was provided so that the application
 *                  developer does not have to know what the message attribute
 *                  structure looks like and allows flexibility to
 *                  provide future message attributes. For the
 *                  recipient, the security identity will be of interest
 *                  if authorization is to be performed.
 *
 *                  If NULL is specified, the message attributes are not
 *                  returned. Otherwise, it is the caller's responsibility
 *                  to release the memory allocated for the message attributes
 *                  structure via mos_msg_attr_free().
 *
 *  msg_buffer:
 *                  Opaque pointer to application-specific buffer contents.
 *                  An empty message buffer is supported. The queue manager
 *                  does not care about its contents and the application
 *                  designer could be using an empty message to signal an
 *                  event.
 *
 *                  It is the caller's responsibility to release the
 *                  memory allocated for the message buffer structure
 *                  via mos_msg_buf_free().
 *
 *  status:
 *                  A pointer to the completion status. On successful
 *                  completion, the routine returns error_status_ok.
 *                  Otherwise, it returns an error.
 *
 *  RETURNS:        None
 */
void
mos_msg_dequeue(
                mos_handle_t                        resource_handle,
                unsigned32                          flags,
                mos_msg_selfilter_t                 msg_selection_filter,
                mos_msg_attr_t *                    msg_attributes,
                mos_msg_buf_t *                     msg_buffer,
                error_status_t *                    status
               )
{
    mos__msg_get(resource_handle,
                 1,                      /* Dequeue message */
                 flags,
                 msg_selection_filter,
                 msg_attributes,
                 msg_buffer,
                 status);

    return;

} /* End of mos_msg_dequeue() routine */


/*
 *  FUNCTION:
 *  m o s _ m s g _ p e e k
 *
 *  OVERVIEW:
 *  Returns a copy of one message from a queue. If no selection
 *  criteria is specified, then the first message in the queue
 *  is returned.
 *  The queue manager returns the application-specific message
 *  buffer along with its message attributes but does not delete
 *  the message from its queue.
 *
 *  The caller must have the proper access rights to read a
 *  message from a queue.
 *
 *  In the event that multiple recipients may want to retrieve
 *  a message from the same queue, this API allows a copy to be
 *  retrieved without deleting the message from the queue. An
 *  example, may be a bulletin board.
 *
 *  INPUTS:
 *  resource_handle:
 *                  A context handle to a resource.
 *                  To speed look-ups, a context handle to an NSI group
 *                  or profile is prohibited.
 *
 *  flags:
 *                  Indicates the message retrieval mode. Only one option
 *                  is allowed to be specified.
 *                  The default is mos_c_deqmode_nowait.
 *
 *  msg_selection_filter:
 *                  This is a pointer to the selection filter structure.
 *                  Use the mos_msg_selfilter_alloc(), mos_msg_selfilter_free(),
 *                  and mos_msg_selmask_add() APIs to allocate, deallocate and
 *                  define one or more selection criteria. A message is
 *                  successfully retrieved following the rules of the logical
 *                  AND operator among all specified criteria.
 *
 *                  A NULL value indicates no selection criteria and the
 *                  message at the top of the specified queue is returned.
 *
 *  OUTPUTS:
 *  msg_attributes:
 *                  Use the utilities to get message attributes. This
 *                  interface was provided so that the application
 *                  developer does not have to know what the message attribute
 *                  structure looks like and allows flexibility to
 *                  provide future message attributes. For the
 *                  recipient, the security identity will be of interest
 *                  if authorization is to be performed.
 *
 *                  If NULL is specified, the message attributes are not
 *                  returned. Otherwise, it is the caller's responsibility
 *                  to release the memory allocated for the message attributes
 *                  structure via mos_msg_attr_free().
 *
 *  msg_buffer:
 *                  Opaque pointer to application-specific buffer contents.
 *                  An empty message buffer is supported. The queue manager
 *                  does not care about its contents and the application
 *                  designer could be using an empty message to signal an
 *                  event.
 *
 *                  It is the caller's responsibility to release the
 *                  memory allocated for the message buffer structure 
 *                  via mos_msg_buf_free().
 *
 *  status:
 *                  A pointer to the completion status. On successful
 *                  completion, the routine returns error_status_ok.
 *                  Otherwise, it returns an error.
 *
 *  RETURNS:        None
 */
void
mos_msg_peek(
             mos_handle_t                        resource_handle,
             unsigned32                          flags,
             mos_msg_selfilter_t                 msg_selection_filter,
             mos_msg_attr_t *                    msg_attributes,
             mos_msg_buf_t *                     msg_buffer,
             error_status_t *                    status
             )
{
    mos__msg_get(resource_handle,
                 0,                      /* Read message only */
                 flags,
                 msg_selection_filter,
                 msg_attributes,
                 msg_buffer,
                 status);

    return;

} /* End of mos_msg_peek() routine */


/*
 *  FUNCTION:
 *  m o s _ _ m s g _ g e t 
 *
 *  OVERVIEW:
 *  Either return a copy of one message or dequeue one message from a queue. 
 *  If no selection criteria is specified, then the first message in the 
 *  queue is returned.
 *
 *  INPUTS:
 *  resource_handle:
 *                  A context handle to a resource.
 *                  To speed look-ups, a context handle to an NSI group
 *                  or profile is prohibited.
 *
 *  dequeue:
 *                  If dequeue, dequeue message from the queue.
 *                  Otherwise, just read message from the queue.
 *
 *  flags:
 *                  Indicates the message retrieval mode. Only one option
 *                  is allowed to be specified.
 *                  The default is mos_c_deqmode_nowait.
 *
 *  msg_selection_filter:
 *                  This is a pointer to the selection filter structure.
 *                  Use the mos_msg_selfilter_alloc(), mos_msg_selfilter_free(),
 *                  and mos_msg_selmask_add() APIs to allocate, deallocate and
 *                  define one or more selection criteria. A message is
 *                  successfully retrieved following the rules of the logical
 *                  AND operator among all specified criteria.
 *
 *                  A NULL value indicates no selection criteria and the
 *                  message at the top of the specified queue is returned.
 *
 *  OUTPUTS:
 *  msg_attributes:
 *                  Use the utilities to get message attributes. This
 *                  interface was provided so that the application
 *                  developer does not have to know what the message attribute
 *                  structure looks like and allows flexibility to
 *                  provide future message attributes. For the
 *                  recipient, the security identity will be of interest
 *                  if authorization is to be performed.
 *
 *                  If NULL is specified, the message attributes are not
 *                  returned. Otherwise, it is the caller's responsibility
 *                  to release the memory allocated for the message attributes
 *                  structure via mos_msg_attr_free().
 *
 *  msg_buffer:
 *                  Opaque pointer to application-specific buffer contents.
 *                  An empty message buffer is supported. The queue manager
 *                  does not care about its contents and the application
 *                  designer could be using an empty message to signal an
 *                  event.
 *
 *                  It is the caller's responsibility to release the
 *                  memory allocated for the message buffer structure 
 *                  via mos_msg_buf_free().
 *
 *  status:
 *                  A pointer to the completion status. On successful
 *                  completion, the routine returns error_status_ok.
 *                  Otherwise, it returns an error.
 *
 *  RETURNS:        None
 */
void
mos__msg_get(
             mos_handle_t                        resource_handle,
             boolean                             dequeue,
             unsigned32                          flags,
             mos_msg_selfilter_t                 msg_selection_filter,
             mos_msg_attr_t *                    msg_attributes,
             mos_msg_buf_t *                     msg_buffer,
             error_status_t *                    status
             )
{
    error_status_t                 temp_status;
    mos_mattr_t *                  msg_attr_p;
    mos_datatype_bytearray_t *     msg_body_p;
    mos_mask_t                     selfilter_mask;
    mos_mask_t *                   selfilter_mask_p;

    /*
     * Initialize output parameters
     */
    CLEAR_STATUS(status);
    *msg_buffer = NULL;

    /* 
     * Validate handle
     */
    if (! mos__is_rsrc_handle_valid(TRUE, resource_handle, status)) {
       return;
    }

    /* 
     * Validate dequeue mode flags.
     */
    if (! mos__is_deqmode_valid(flags, status)) {
       return;
    }
     
    /* 
     * If message queuing model, this API uses the end-to-end
     * protection level selected in the selection criteria
     * to set the protection level bewteen recipient and Q-mgr on
     * every retrieve operation via rpc_binding_set_auth_info().
     */
    if (msg_selection_filter == NULL) {
        mos__auth_info_set(resource_handle,
                           mos_c_protect_level_default, 
                           status);
    } else {
        selfilter_mask_p = &selfilter_mask;
        if (mos__find_mask_by_type(msg_selection_filter,
                                   mos_c_mask_type_protectlvl,
                                   &selfilter_mask_p)) {
            mos__auth_info_set(
                         resource_handle, 
                         selfilter_mask_p->mask_info.tagged_union.protectlvl, 
                         status);
        } else {
            mos__auth_info_set(resource_handle,
                               mos_c_protect_level_default, 
                               status);
        } /* End of determine if protectlvl mask specified */
    } /* End of determine if selection criteria specified */
    if (BAD_STATUS(status)) {
       return;
    }
    
    /*
     * If sucessful, the "msg_buffer" and its "msg_attributes" are 
     * both retrieved.
     */
    msg_body_p = 
         (mos_datatype_bytearray_t *)malloc(sizeof(mos_datatype_bytearray_t));
    if (msg_body_p == NULL) {
       SET_STATUS(status, mos_s_no_memory); 
       return;
    }
    msg_attr_p = 
         (mos_mattr_t *)malloc(sizeof(mos_mattr_t));
    if (msg_attr_p == NULL) {
       SET_STATUS(status, mos_s_no_memory); 
       mos_msg_buf_free(&msg_body_p, &temp_status);
       return;
    } 
    if (dequeue) {
        mos_q_dequeue(resource_handle->server_handle,
                      resource_handle->resource_name,
                      msg_selection_filter,
                      flags,
                      msg_attr_p, 
                      msg_body_p,
                      status);
    } else {
        mos_q_peek(resource_handle->server_handle,
                   resource_handle->resource_name,
                   msg_selection_filter,
                   flags,
                   msg_attr_p, 
                   msg_body_p,
                   status);
    }

    /*
     * If the sender's requested end-to-end protection level is
     * higher, this API automatically negotiates a higher protection
     * level to retrieve a message successfully. If the sender's
     * requested end-to-end protection level is lower, this API
     * returns an error message stating the protection level must
     * be lowered in order to retrieve the message. The recipient
     * must manually select another protection level or loop thru
     * all protection levels to obtain the message with the proper
     * encryption.
     */
    if (BAD_STATUS(status)) {
       /* XXX check status for wrong protectlvl */
       mos_msg_buf_free(&msg_body_p, &temp_status);
       mos_msg_attr_free(&msg_attr_p, &temp_status);
       if (msg_attributes != NULL) {
          *msg_attributes = NULL;
       }
       return;
    }

    /*
     * The "msg_buffer", its "msg_attributes", and the status are
     * then returned to the calling application. Note that the
     * "msg_attributes" is not returned if specified as NULL.
     */
    if (GOOD_STATUS(status)) {
       *msg_buffer = msg_body_p;
       if (msg_attributes == NULL) {
           mos_msg_attr_free(&msg_attr_p, &temp_status);
       } else {
           *msg_attributes = msg_attr_p;
       }
    }
    return;

} /* End of mos__msg_get() routine */


/*
 *  FUNCTION:
 *  m o s _ m s g _ d a t a t y p e _ d e c o d e
 *
 *  OVERVIEW:
 *  Decodes the message buffer returned by mos_msg_dequeue() or
 *  mos_msg_peek().
 *
 *  This API invokes the registered conversion function associated with 
 *  the specified data type in order to decode the "msg_buffer". Note 
 *  that the datatype is obtained from the message attributes returned 
 *  by mos_msg_dequeue() or mos_msg_peek().
 *
 *  MOS provides no conversion for the default data type, a NIL UUID,
 *  which refers to an array of bytes.
 *
 *  INPUTS:
 *  datatype_id:
 *                 Application-specific data type represented as a UUID.
 *
 *  msg_buffer:
 *                 Opaque pointer to message buffer structure obtained
 *                 via mos_msg_dequeue() or mos_msg_peek(). 
 *
 *  OUTPUTS:
 *  decoded_msg_buffer:
 *                 Opaque pointer to the application-specific message
 *                 structure. It is the responsiblity of the caller to
 *                 provide an area to store the decoded application-specific
 *                 message data. In addition, it is the responsibility of
 *                 the caller to release any allocated portions of the
 *                 application-specific message.
 *
 *  status:
 *                 A pointer to the completion status. On successful
 *                 completion, the routine returns error_status_ok.
 *                 Otherwise, it returns an error. 
 *
 *  RETURNS:       None
 */
void
mos_msg_datatype_decode(
                        uuid_t *                    datatype_id,
                        mos_msg_buf_t               msg_buffer,   
                        void *                      decoded_msg_buffer,   
                        error_status_t *            status
                       )
{
    mos_datatype_info_t *          datatype_info_p;
    idl_es_handle_t                eh = NULL;
    idl_ulong_int                  esize;
    idl_byte                       *ep;
    error_status_t                 temp_status;

    /*
     * Initialize output parameters
     */
    CLEAR_STATUS(status);

    /*
     * Determine if datatype is NIL which is reserved for an array of bytes
     * In this case, there is no encoding/decoding performed by the 
     * messaging system.
     */
    if (! mos__is_uuid_valid(datatype_id, status)) {
        return;
    }

    /*
     * Validate message buffer 
     */
    if (msg_buffer == NULL){
        SET_STATUS(status, mos_s_msg_buf_inv);
        return;
    }

    /*
     * Validate message area allocated by caller
     */
    if (decoded_msg_buffer == NULL){
        SET_STATUS(status, mos_s_msg_appbuf_inv);
        return;
    }

    /* 
     * Search our list of registered datatypes for conversion function 
     * to invoke the registered conversion function associated with the 
     * data type specified in the message attributes in order to decode 
     * the "msg_buffer".
     */
    if (mos__is_datatype_found(datatype_id, 
                               &datatype_info_p)){
       /* Call encoding  services to decode data */
       ep = (idl_byte *)msg_buffer->data;
       esize = (idl_ulong_int)msg_buffer->size;
       idl_es_decode_buffer(ep, esize, &eh, status);
       if (GOOD_STATUS(status)) {
          /* Call conversion function */
          datatype_info_p->conv_fn(eh,
                                   (void *)decoded_msg_buffer, 
                                   status);
       }
    } else {
       SET_STATUS(status, mos_s_no_datatype_reg);  
    }

    if (eh)
        idl_es_handle_free(&eh, &temp_status);

    return;

} /* End of mos_msg_datatype_decode() routine */


/*
 *  FUNCTION:
 *  m o s _ m s g _ b u f _ f r e e
 *
 *  OVERVIEW:
 *  Releases memory used for the message buffer.
 *  It is the responsibility of the caller to release the memory
 *  if allocated by mos_msg_dequeue() or mos_msg_peek().
 *
 *  INPUTS/OUTPUTS:
 *  msg_buffer:
 *                 Opaque pointer to message buffer structure obtained
 *                 via mos_msg_dequeue() or mos_msg_peek(). If the 
 *                 operation succeeds, this parameter returns the
 *                 value NULL.
 *
 *  OUTPUTS:
 *  status:
 *                  A pointer to the completion status. On successful
 *                  completion, the routine returns error_status_ok.
 *                  Otherwise, it returns an error. 
 *
 *  RETURNS:        None
 */
void
mos_msg_buf_free(
                 mos_msg_buf_t *             msg_buffer,
                 error_status_t *            status
                )
{
    /*
     * Initialize output parameters
     */
    CLEAR_STATUS(status);

    /*
     * Validate handle to message buffer
     */
    if ((msg_buffer == NULL) || (*msg_buffer == NULL)) {
        SET_STATUS(status, mos_s_msg_buf_inv);
        return;
    }

    /*
     * Release data 
     */
    if ((*msg_buffer)->data) {
        free((*msg_buffer)->data);
        (*msg_buffer)->data = NULL;
    }

    /*
     * Release memory and return NULL pointer
     */
    free(*msg_buffer);
    *msg_buffer = NULL;
    return;

} /* End of mos_msg_buf_free() routine */


/*
 *  FUNCTION:
 *  m o s _ m s g _ d e l e t e
 *
 *  OVERVIEW:
 *  Delete one message by message ID from a queue.
 *  The queue manager does not return any application-specific
 *  message buffer or its message attributes but just deletes the
 *  message from its queue.
 *
 *  The caller must have the proper access rights to delete a
 *  message from a queue.
 *  
 *
 *  INPUTS:
 *  resource_handle:
 *                  A context handle to a resource.
 *                  To speed look-ups, a context handle to an NSI group
 *                  or profile is prohibited.
 *
 *  msg_id:         Unique message ID for message to be deleted.
 *
 *  OUTPUTS:
 *  status:
 *                  A pointer to the completion status. On successful
 *                  completion, the routine returns error_status_ok.
 *                  Otherwise, it returns an error.
 *
 *  RETURNS:        None
 */
void
mos_msg_delete(
               mos_handle_t             resource_handle,
               uuid_t *                 msg_id,
               error_status_t *         status
               )
{
    /*
     * Initialize output parameters
     */
    CLEAR_STATUS(status);

    /* 
     * Validate handle
     */
    if (! mos__is_rsrc_handle_valid(TRUE, resource_handle, status)) {
       return;
    }

    /* 
     * Validate UUID 
     */
    if (! mos__is_uuid_valid(msg_id, status)) {
       return;
    }

    /*
     * Determine the authentication level to use
     */
    mos__auth_info_set(resource_handle, resource_handle->protectlvl, status);

    /*
     * Purge/delete message with given ID 
     */
    if (GOOD_STATUS(status)) {
        mos_q_purge(resource_handle->server_handle,
                    resource_handle->resource_name,
                    msg_id,
                    status);
    }

    return;

} /* End of mos_msg_delete() routine */


/*
 *  FUNCTION:
 *  m o s _ m s g _ m o v e
 *
 *  OVERVIEW:
 *  Move one message by message ID from one queue to another.
 *
 *  This API assumes that the source and destination queues
 *  already exist. The caller must have the proper access rights
 *  to dequeue from the source queue and enqueue to the destination
 *  queue.
 *
 *  INPUTS:
 *  src_resource_handle:
 *                  A context handle to a source queue.
 *                  Use mos_rsrc_attach() to get the source queue handle.
 *
 *                  To speed look-ups, a context handle to an NSI group
 *                  or profile is prohibited.
 *
 *  dest_resource_handle:
 *                  A context handle to a destination queue.
 *                  Use mos_rsrc_attach() to get the destination queue handle.
 *
 *                  To speed look-ups, a context handle to an NSI group
 *                  or profile is prohibited.
 *
 *  msg_id:
 *                  Unique message ID generated by the send API operations.
 *
 *  OUTPUTS:
 *  status:
 *                  A pointer to the completion status. On successful
 *                  completion, the routine returns error_status_ok.
 *                  Otherwise, it returns an error.
 *
 *  RETURNS:        None
 */
void
mos_msg_move(
             mos_handle_t             src_resource_handle,
             mos_handle_t             dest_resource_handle,
             uuid_t *                 msg_id,
             error_status_t *         status
            )
{
    mos_msg_selfilter_t          msg_selfilter;
    error_status_t               temp_status;

    /*
     * Initialize output parameters
     */
    CLEAR_STATUS(status);

    /* 
     * Validate source handle to queue
     */
    if (! mos__is_rsrc_handle_valid(TRUE, src_resource_handle, status)) {
       return;
    }

    /* 
     * Validate destination handle to queue
     */
    if (! mos__is_rsrc_handle_valid(TRUE, dest_resource_handle, status)) {
       return;
    }

    /* 
     * Validate UUID 
     */
    if (! mos__is_uuid_valid(msg_id, status)) {
       return;
    }

    if (src_resource_handle->server_handle ==
                    dest_resource_handle->server_handle) {
        mos_q_move_item(dest_resource_handle->server_handle,
                        src_resource_handle->resource_name,
                        dest_resource_handle->resource_name,
                        msg_id,
			0,
                        status);
    } else {
        /*
         * Build message selection filter with specified message ID
         */
        mos_msg_selfilter_alloc(&msg_selfilter, status);
        if (BAD_STATUS(status)) {
           return;
        }
        mos_msg_selmask_add(mos_c_mask_type_msgid,
                            msg_id,
                            mos_c_mask_op_equal,
                            msg_selfilter,
                            status);

        /*
         * Peek/Enqueue/Purge specified message ID
         */
        if (GOOD_STATUS(status)) {
            mos__msg_pep(src_resource_handle,
                         dest_resource_handle,
                         msg_selfilter,
                         status);
        }
        mos_msg_selfilter_free(&msg_selfilter, &temp_status);
    }

    return;

} /* End of mos_msg_move() routine */


/*
 *  FUNCTION:
 *  m o s _ _ m s g _ p e p
 *
 *  OVERVIEW:
 *  Peek/Enqueue/Purge one message from the source queue to the 
 *  destination queue.
 *
 *  INPUTS:
 *  src_resource_handle:
 *                  A context handle to a source queue.
 *
 *  dest_resource_handle:
 *                  A context handle to a destination queue.
 *
 *  msg_selection_filter:
 *                  Opaque pointer to the selection filter buffer.
 *                  The message that meets the selection criteria is
 *                  moved.
 *                  A NULL value indicates no selection criteria and the
 *                  message at the top of the specified queue is moved.
 *
 *  OUTPUTS:
 *  status:
 *                  A pointer to the completion status. On successful
 *                  completion, the routine returns error_status_ok.
 *                  Otherwise, it returns an error.
 *
 *  RETURNS:        None
 */
void
mos__msg_pep(
             mos_handle_t             src_resource_handle,
             mos_handle_t             dest_resource_handle,
             mos_msg_selfilter_t      msg_selection_filter,
             error_status_t *         status
            )
{
   mos_mattr_t                  msg_attr;
   mos_msg_attr_t               msg_attr_p;
   mos_datatype_bytearray_t     msg_body;
   uuid_t                       msg_id;
   error_status_t               temp_status;
 
   /*
    * Initialize output parameters
    */
   CLEAR_STATUS(status);

   /*
    * Request to peek at a message's attributes from source queue
    */
   mos_msg_attr_peek(src_resource_handle,
                     mos_c_deqmode_nowait,
                     msg_selection_filter,
                     &msg_attr_p,
                     status);

   /*
    * Bypass mos_msg_peek() API since we do not want to decode
    * the message body.
    * Ensure end-to-end protection level for dequeuing message
    * from source queue.
    */
   if (GOOD_STATUS(status)) {
      mos__auth_info_set(src_resource_handle,
                         msg_attr_p->protectlvl,
                         &temp_status);
      mos_msg_attr_free(&msg_attr_p, &temp_status);
      mos_q_peek(src_resource_handle->server_handle,
                 src_resource_handle->resource_name,
                 msg_selection_filter,
                 mos_c_deqmode_nowait,
                 &msg_attr,
                 &msg_body,
                 status);
   }

   /*
    * Bypass mos_msg_enqueue() API since we do not want to encode
    * the message body.
    * Ensure end-to-end protection level for enqueuing message
    * to destination queue.
    */
   if (GOOD_STATUS(status)) {
      mos__auth_info_set(dest_resource_handle,
                         msg_attr.protectlvl,
                         &temp_status);
      mos_q_enqueue(dest_resource_handle->server_handle,
                    dest_resource_handle->resource_name,
                    &msg_attr,          /* Use same msg ID */
                    &msg_body,
                    mos_c_enqmode_wait_enq,
                    &msg_id,
                    status);
   }

   /*
    * Purge/delete message from source queue with given ID
    */
   if (GOOD_STATUS(status)) {
      mos_msg_delete(src_resource_handle,
                     &msg_id,
                     status);
   }

   return;

} /* End of mos__msg_pep() routine */


/*
 *  FUNCTION:
 *  m o s _ _ f i n d _ m a s k _ b y _ t y p e
 *
 *  OVERVIEW:
 *  Returns the mask that matches the specified mask type in the 
 *  selection filter.
 *
 *  INPUTS:
 *  msg_selection_filter:
 *                  Opaque pointer to the selection filter buffer.
 *
 *  selmask_type:
 *                  Type of selection criteria for specified mask.
 *
 *  OUTPUTS:
 *  selfilter_mask:
 *                  A pointer to the mask that matches the specified
 *                  mask type.
 *
 *  status:
 *                  A pointer to the completion status. On successful
 *                  completion, the routine returns error_status_ok.
 *                  Otherwise, it returns an error.
 *
 *  RETURNS:        TRUE  indicates mask was found.
 *                  FALSE indicates mask was not found.
 */
boolean
mos__find_mask_by_type(
                       mos_mask_list_t *        msg_selection_filter,
                       mos_msg_selmask_type_t   selmask_type,
                       mos_mask_t **            selfilter_mask
                      )
{
    int i;

    for (i = 0; i < msg_selection_filter->count; i++) {
 
       if (msg_selection_filter->list[i].mask_info.mask_type == selmask_type) {
           *selfilter_mask = &msg_selection_filter->list[i];
           return(TRUE);
       }

    } /* End of loop thru all masks in filter */

    *selfilter_mask = NULL;
    return(FALSE);

} /* End of mos__find_mask_by_type() routine */


/*
 *  FUNCTION:
 *  m o s _ _ i s _ e n q m o d e _ v a l i d
 *
 *  OVERVIEW:
 *  Validate message enqueue flags.
 *
 *  INPUTS:
 *  enq_mode:
 *                  Indicates the asynchronous/synchronous behavior
 *                  during a message enqueue operation.
 *
 *  OUTPUTS:
 *  status:
 *                  A pointer to the completion status. On successful
 *                  completion, the routine returns error_status_ok.
 *                  Otherwise, it returns an error.
 *
 *  RETURNS:        TRUE  indicates validation was successful.
 *                  FALSE indicates validation was not successful.
 */
boolean
mos__is_enqmode_valid(
                      unsigned32         enq_mode,
                      error_status_t *   status 
                      )
{
    CLEAR_STATUS(status);
    
    if (enq_mode & mos_c_enqmode_sync) {
        SET_STATUS(status, mos_s_enqmode_mp);  
        return(FALSE);
    }

    switch (enq_mode) {
        case (mos_c_enqmode_async):
        case (mos_c_enqmode_nowait_enq):
        case (mos_c_enqmode_wait_enq):
        case (mos_c_enqmode_wait_deq):
            return(TRUE);
        default:
            SET_STATUS(status, mos_s_enqmode_inv);   
            return(FALSE);
    }

} /* End of mos__is_enqmode_valid() routine */


/*
 *  FUNCTION:
 *  m o s _ _ i s _ d e q m o d e _ v a l i d
 *
 *  OVERVIEW:
 *  Validate message dequeue flags.
 *
 *  INPUTS:
 *  deq_mode:
 *                  Indicates the asynchronous/synchronous behavior
 *                  during a message dequeue operation.
 *
 *  OUTPUTS:
 *  status:
 *                  A pointer to the completion status. On successful
 *                  completion, the routine returns error_status_ok.
 *                  Otherwise, it returns an error.
 *
 *  RETURNS:        TRUE  indicates validation was successful.
 *                  FALSE indicates validation was not successful.
 */
boolean
mos__is_deqmode_valid(
                      unsigned32         deq_mode,
                      error_status_t *   status 
                      )
{
    CLEAR_STATUS(status);
    
    switch (deq_mode) {
        case (mos_c_deqmode_nowait):
        case (mos_c_deqmode_wait):
           return(TRUE);
        default:
           SET_STATUS(status, mos_s_deqmode_inv); 
           return(FALSE);
    }

} /* End of mos__is_deqmode_valid() routine */
