/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 */
/*
 * ID: $Id: crc-perf.c,v 1.1.21.1 1996/10/02 17:28:55 damon Exp $
 *
 * COMPONENT_NAME: EPISODE - CRC PERFORMANCE 
 *
 * The following functions list may not be complete.
 * Functions defined by/via macros may not be included.
 *
 * ORIGINS: Transarc Corp.
 *
 * (C) COPYRIGHT Transarc Corp. 1993
 * All Rights Reserved
 * Licensed Materials - Property of Transarc
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with Transarc Corp
 */
/*
 * HISTORY
 * $Log: crc-perf.c,v $
 * Revision 1.1.21.1  1996/10/02  17:28:55  damon
 * 	Newest DFS from Transarc
 * 	[1996/10/01  18:34:47  damon]
 *
 * Revision 1.1.16.2  1994/06/09  14:03:51  annie
 * 	fixed copyright in src/file
 * 	[1994/06/08  21:38:43  annie]
 * 
 * Revision 1.1.16.1  1994/02/04  20:15:32  devsrc
 * 	Merged from 1.0.3a to 1.1
 * 	[1994/02/04  15:11:28  devsrc]
 * 
 * Revision 1.1.14.1  1993/12/07  17:21:07  jaffe
 * 	New File from Transarc 1.0.3a
 * 
 * 	$TALog: crc-perf.c,v $
 * 	Revision 1.3  1994/11/01  21:32:06  cfe
 * 	Bring over the changes that the OSF made in going from their DCE 1.0.3
 * 	release to their DCE 1.1 release.
 * 	[from r1.2 by delta cfe-db6109-merge-1.0.3-to-1.1-diffs, r1.1]
 * 
 * 	Revision 1.1  1993/01/22  22:44:39  rajesh
 * 	Add CRC to Episode log pages to out-of-order sector writes.
 * 
 * 	This is the first checkpoint. It implements the code to generate CRC
 * 	lookup tables and CRCs both using 8 and 16 data bits in each
 * 	iteration. After some performance analysis, we decided to calculate
 * 	the CRC using the 8 bit approach. The reasons are mentioned in
 * 	tools/crc-perf.c. The code has been tested.
 * 
 * 	Not ready for export yet. Still need to add integrate the log package
 * 	to use CRCs.
 * 
 * 	This file contains the code to generate the lookup tables, so the CRC
 * 	can be calculated taking 8 or 16 bits at a time. It contains several
 * 	functions to calculate CRC taking 16 bits of data in each iteration
 * 	and one to do the same with 8 bits of data each time. These functions
 * 	were used in some performance measurements, after which it was decided
 * 	to go with the 8 bit approach. The reasons are mentioned in this file
 * 	as comments.
 * 
 * 	This file should not be built by default.
 * 	[added by delta rajesh-ot3435-add-crc32-to-log-pages, r1.1]
 * 
 * $EndLog$
 */

/* 

This file provides an implementation of CRC 32 essentially. It
includes the code necessary to generate the Lookup tables and to
calculate CRCs. There are 5 functions defined, each of which calculate
the CRC using slightly different implementations. There
implementations were coded with a view to find out the routines best
in performance. 

PERFORMANCE RESULTS:

The perfomance results (using getrusage) on shared, an RS6000 320H
with a 32 KByte data cache are given below, when the code is compiled
without debugging (-g) and with optimization (-O) turned on.

The times are in seconds and represent times for 1000 executions of
each routine, each time.

[logbuf] a.out /tmp/rajesh/4096
crc 8 = 0xc96ef68e, crc 32_16_1 = 0xc96ef68e, crc 32_16_2 = 0xc96ef68e
crc 32_16_3 = 0xc96ef68e, crc 32_16_4 = 0x4a3553ab
Msg Size      CRC Unit = 8          CRC Unit = 16
(bytes)     utime      stime       utime      stime
-----------------------------------------------------
 4096      1.230000   0.000000    1.620000   0.000000  CalcCRC32_16_1
                                  1.550000   0.000000  CalcCRC32_16_2
                                  1.480000   0.000000  CalcCRC32_16_3
                                  1.270000   0.000000  CalcCRC32_16_4

[logbuf] a.out /tmp/rajesh/8192
crc 8 = 0x4a1075eb, crc 32_16_1 = 0x4a1075eb, crc 32_16_2 = 0x4a1075eb
crc 32_16_3 = 0x4a1075eb, crc 32_16_4 = 0xf5fc85a7
Msg Size      CRC Unit = 8          CRC Unit = 16
(bytes)     utime      stime       utime      stime
-----------------------------------------------------
 8192      2.260000   0.000000    3.090000   0.000000
                                  3.110000   0.000000
                                  2.920000   0.000000
                                  2.550000   0.000000

Note that the CRC generated by CalcCRC32_16_4 is different from the
others. This is expected as given the input bytes to be B1 and B2, it
treates the data as B1B2 instead of B2B1 as the others.

PERFORMANCE ANALYSIS

Thanks to Ted, we have the following analysis. We expected the
performance results of CalcCRC32_16_4 to be about 50% faster that
CalcCRC_8, as the former routine executes the loop 1/2 the times that
the latter does. However, the former takes slightly more than the
latter. For input data size of 8K, the latter routine references the
lookup table 8K times randomly. Since the corresponding lookup table
is only 1K in size, it could entirely be present in the 32 K data
cache almost always, resulting in cache hits most of the time. And
though the former routine references only 4K random entries of the
corresponding lookup table. The lookup table is 256 Kbytes in size.
Given the data cache is 32K bytes, each access probably almost always
results in a data cache miss, which increases the time taken by the
routine.

The relative performance for CalcCRC32_16_X routines are as expected.
Comparing the code for each routine will automatically result in this
conclusion.

HOW DOES THIS ALGORITHM WORK?
   If you really really need to understand the internals of the
   algorithm, refer - 
   "A Tutorial on CRC Computations" by Ramabadran & Gaitonde, 
   IEEE Micro, August 1988, pg 62-74.

*/

#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include<sys/time.h>
#include <sys/resource.h>

#define BUFSIZE 8192

#define FLOAT(timeval) (  (float)((timeval).tv_sec) + \
		(((float)((timeval).tv_usec))/1000000))

unsigned long *crc8Table;
unsigned long *crc16Table;


void CalcTimeDiff(s1,us1,s2,us2,t)
int s1,us1,s2,us2;
struct timeval *t;
{
    /* Sanity checks */
    if ( (s2 < s1) || ((us2 < us1) && (!s2))) {
	printf("ERROR: After time < Before time \n");
	exit (1);
    }
    if ( us2 < us1 ) {
	us2 += 1000000;
	s2--;
    }

    t->tv_sec=s2-s1;
    t->tv_usec=us2-us1;
}

void CalcRusageTimes(r1,r2,utime,stime)
struct rusage r1,r2;
struct timeval *utime, *stime;
{
    int r1_sec,r2_sec,r1_usec,r2_usec;

    /* User time */
    r1_sec = r1.ru_utime.tv_sec;
    r1_usec = r1.ru_utime.tv_usec;

    r2_sec = r2.ru_utime.tv_sec;
    r2_usec = r2.ru_utime.tv_usec;

    CalcTimeDiff(r1_sec,r1_usec,r2_sec,r2_usec,utime);

    /* System time */
    r1_sec = r1.ru_stime.tv_sec;
    r1_usec = r1.ru_stime.tv_usec;

    r2_sec = r2.ru_stime.tv_sec;
    r2_usec = r2.ru_stime.tv_usec;

    CalcTimeDiff(r1_sec,r1_usec,r2_sec,r2_usec,stime);

}

void PrintTable(table,numEntries)
  unsigned long table[];
  int numEntries;
{
    int i = 0;

    printf ("Power of x [=i]  R((X**i)/g(x))\n");
    printf ("---------------  ----------------\n");

    for (i = 0; i<numEntries; i++) 
        printf ("    %3d                 0x%08x\n",i, table[i]);
}

/*
 * GenerateCrcReducedLookupTable
 *    Generates the reduced lookup table used in CRC calculation. 
 *    This routine can handle CRC-16 and CRC-32 tables
 *    Returns -1 on error;
 */

int GenerateCrcReducedLookupTable (crcDegree,crcReducedTable)
  int crcDegree;
  unsigned long **crcReducedTable;
{
    int power,index, numEntries;
    unsigned long remainder, temp, coeff;
    unsigned long polyCoeff[2];

    polyCoeff[0] = 0xA001L; /* coefficient for CRC 16 generator polynomial */
    polyCoeff[1] = 0xEDB88320L; /* coefficients for CRC 32 generator poly */

    if ( crcDegree != 16 && crcDegree != 32 ) {
        return(-1);
    };

    index= ((crcDegree & 0x20) != 0);
    coeff = polyCoeff[index];
    
    numEntries = ( index + 1) * 16;
    (*crcReducedTable)=(unsigned long *)
	malloc (numEntries * sizeof(unsigned long));

    remainder = coeff;
    for (power = crcDegree; power < 2*crcDegree ; power++) {
	(*crcReducedTable)[power-crcDegree]=remainder;
        temp = remainder & 0x00000001; /* Is remainder divisible by generator */
        remainder = ( remainder >> 1 );
        if ( temp == 1 ) {
           /* modulo-2 subtraction of generator from remainder */
	    remainder = remainder ^ coeff; 
        }
    }
}

/* 
 * GenerateCrc32LookupTable 
 *    Generate the full lookup table for CRC 32.
 *    If 8 bits are to be checked at a time, the size of lookup table is 
 *    256 (2**8) entries of 1 word (4 bytes) each = 1Kbytes.
 *    If 16 bits are to be checked at a time, lookup table size is 
 *    64K (2**16) entries of 1 word each = 256Kbytes.
 */

int GenerateCrc32LookupTable(flag,crcTable)
  int flag;  /* 8 bits or 16 bits at a time */
unsigned long **crcTable;
{
    int i,j,t,numEntries,numBits;
    unsigned long crc;
    unsigned long *crcReducedTable;  

    GenerateCrcReducedLookupTable(32,&crcReducedTable);

    if ( flag )  {
	numEntries = 65536;
	numBits = 16;
    } else  {
	numEntries = 256;
	numBits = 8;
    }

    *crcTable = (unsigned long *)
	malloc(numEntries * sizeof (unsigned long));

    for (i=0; i<numEntries; i++) {
        crc = 0;
        t = i;
        for (j = 0; j < numBits; j++) {
            if ( t & ( 0x1 << (numBits - 1 -j)) ) 
                crc ^= crcReducedTable[j];
        }
        (*crcTable)[i]=crc; 
    }
}

/* 
 * CalcCRC32_8
 *    Generate CRC-32 using 8 bits of data at a time
 */

int CalcCRC32_8(buffer,bufSize,crc)
unsigned char * buffer;
int bufSize;
unsigned long *crc;
{
    int i;
    unsigned long crcReg;

    crcReg=0;

    for (i=0; i<bufSize; i++) {
	crcReg = (crc8Table[(int)((crcReg ^ buffer[i]) & 0x000000FFL)]) 
	    ^ ((crcReg >> 8) & 0x00FFFFFFL);
    }
    *crc=crcReg;
}

/* 
 * CalcCRC32_16_1
 *    Method 1 to generate CRC-32 using 8 bits of data at a time.
 *    Treats the input data as a array of half words (shorts).
 */

int CalcCRC32_16_1(buffer,bufSize,crc)
unsigned short * buffer;
int bufSize;
unsigned long *crc;
{
    int i;
    unsigned long crcReg, data;

    crcReg=0;
    for (i=0; i<bufSize/2; i++) {
	data = buffer[i];
	/* Swap bytes on big endian machines e.g. rs6000*/
	data =  ((data & 0x000000FFL) << 8) | ((data & 0x0000FF00L) >> 8);

	crcReg = crc16Table[ (int) ((crcReg ^ data) & 0x0000FFFFL)]  ^
	     ((crcReg >> 16) & 0x0000FFFFL);
    }
    *crc=crcReg;
}

/* 
 * CalcCRC32_16_2
 *    Method 2 to generate CRC-32 using 8 bits of data at a time.
 *    Treats the input data as a array of half words (shorts).
 *    This is exactly same as CalcCRC32_16_1, except for the number of 
 *    array references.
 */

int CalcCRC32_16_2(buffer,bufSize,crc)
unsigned short * buffer;
int bufSize;
unsigned long *crc;
{
    int i;
    unsigned long crcReg;

    crcReg=0;
    for (i=0; i<bufSize/2; i++) {
/*	data =  ((buffer[i] & 0x000000FFL) << 8) | ((buffer[i] & 0x0000FF00L) >> 8);
	crcReg = crc16Table[ (int) ((crcReg ^ data) & 0x0000FFFFL)]  ^
	     ((crcReg >> 16) & 0x0000FFFFL);
*/
	crcReg = crc16Table[ (int) ((crcReg ^
				     (((buffer[i] & 0x000000FFL) << 8) |
				      ((buffer[i] & 0x0000FF00L) >> 8))) &
				    0x0000FFFFL)] ^
					((crcReg >> 16) & 0x0000FFFFL);

    }
    *crc=crcReg;
}

/* 
 * CalcCRC32_16_3
 *    Method 3 to generate CRC-32 using 8 bits of data at a time.
 *    Treats the input data as a array of bytes.
 */

int CalcCRC32_16_3(buffer,bufSize,crc)
unsigned char * buffer;
int bufSize;
unsigned long *crc;
{
    int i;
    unsigned long crcReg; /*, data;*/

    crcReg=0;
    for (i=0; i<bufSize; i+=2) {
	crcReg = crc16Table[ (int) ((crcReg ^
				     (buffer[i] | (buffer[i+1] << 8))) &
				    0x0000FFFFL)]  ^
					((crcReg >> 16) & 0x0000FFFFL);
    }
    *crc=crcReg;
}

/* 
 * CalcCRC32_16_4
 *    Method 4 to generate CRC-32 using 8 bits of data at a time.
 *    Treats the input data as a array of half words.
 *    It does not perform byte swapping even on Big endian machines.
 *    As a result, the data bytes are not in the right order for CRC
 *    calculation and the result will differ from the other CRC32 calculation
 *    methods.
 */

int CalcCRC32_16_4(buffer,bufSize,crc)
unsigned short * buffer;
int bufSize;
unsigned long *crc;
{
    int i;
    unsigned long crcReg, data;

    crcReg=0;
    for (i=0; i<bufSize/2; i++) {
	crcReg = crc16Table[ (int) ((crcReg ^ buffer[i]) & 0x0000FFFFL)]  ^
	     ((crcReg >> 16) & 0x0000FFFFL);
    }
    *crc=crcReg;
}

main (argc,argv) 
int argc;
char **argv;
{
    char buffer[BUFSIZE],errMsg[BUFSIZE];
    int bufSize=BUFSIZE;
    struct rusage r0, r8, r16_1, r16_2, r16_3, r16_4;
    struct timeval utime8, stime8, utime16_1, stime16_1, utime16_2, stime16_2;
    struct timeval utime16_3, stime16_3, utime16_4, stime16_4;
    int fd, nread,i;
    unsigned long crc_8,crc_16_1, crc_16_2, crc_16_3,crc_16_4;

    if (argc < 2) {
	fprintf(stderr,"Usage: %s <data-file> \n",argv[0]);
	exit(1);
    }

    /* initialize phase */
    GenerateCrc32LookupTable(0,&crc8Table); 
    GenerateCrc32LookupTable(1,&crc16Table); 

    if ( (fd = open(argv[1], 0, 0755)) < 0 ) {
	sprintf((char *)errMsg,"failure on open of %s: ",argv[1]);
	perror(errMsg);
	exit (1);
    }

    if ( (nread = read (fd, buffer, bufSize)) < 0 ) {
	sprintf((char *)errMsg,"failure on read of %s: ",argv[1]);
	perror(errMsg);
	exit (1);
    }

    getrusage(RUSAGE_SELF,&r0);
    
    /* loop - for some sensible timings */
    for (i=0;i<1000;i++) 
        CalcCRC32_8(buffer, nread, &crc_8);

    getrusage(RUSAGE_SELF,&r8);

    for (i=0;i<1000;i++) 
	CalcCRC32_16_1(buffer, nread, &crc_16_1);

    getrusage(RUSAGE_SELF,&r16_1);

    for (i=0;i<1000;i++) 
	CalcCRC32_16_2(buffer, nread, &crc_16_2);

    getrusage(RUSAGE_SELF,&r16_2);

    for (i=0;i<1000;i++) 
	CalcCRC32_16_3(buffer, nread, &crc_16_3);

    getrusage(RUSAGE_SELF,&r16_3);

    for (i=0;i<1000;i++) 
	CalcCRC32_16_4(buffer, nread, &crc_16_4);

    getrusage(RUSAGE_SELF,&r16_4);

    close(fd);

    CalcRusageTimes(r0,r8,&utime8,&stime8);
    CalcRusageTimes(r8,r16_1,&utime16_1,&stime16_1);
    CalcRusageTimes(r16_1,r16_2,&utime16_2,&stime16_2);
    CalcRusageTimes(r16_2,r16_3,&utime16_3,&stime16_3);
    CalcRusageTimes(r16_3,r16_4,&utime16_4,&stime16_4);

    printf ("crc 8 = %0#8x, crc 16_1 = %0#8x, crc 16_2 = %0#8x \n",
	    crc_8, crc_16_1, crc_16_2);
    printf( "crc 16_3 = %0#8x, crc 16_4 = %0#8x \n", crc_16_3, crc_16_4);

    printf ("Msg Size      CRC Unit = 8          CRC Unit = 16    \n");
    printf ("(bytes)     utime      stime       utime      stime  \n");
    printf ("-----------------------------------------------------\n");

    printf ("%5d    %10f %10f  %10f %10f \n",
	    nread,
	    FLOAT(utime8),
	    FLOAT(stime8),
	    FLOAT(utime16_1),
	    FLOAT(stime16_1)
	    );

    printf ("                               %10f %10f \n",
	    FLOAT(utime16_2),
	    FLOAT(stime16_2)
	    );

    printf ("                               %10f %10f \n",
	    FLOAT(utime16_3),
	    FLOAT(stime16_3)
	    );
    printf ("                               %10f %10f \n",
	    FLOAT(utime16_4),
	    FLOAT(stime16_4)
	    );

}

	
