
Subject:   Message Oriented Service Application Programming Interface
	   (MOS-API)
Revision:  Version 1.14
Date:      November 21, 1996
------------------------------

1.0 Introduction

    1.1 Overview

	This document describes the API for the Message Oriented Service(MOS)
	integrated with DCE. MOS-API supports a message queuing model.
	In a message queuing model, a source peer application sends
	messages to a queue manager/queue regardless if the destination
	peer application is available.

	MOS-API is used by senders, recipients, and system administration
	interfaces. The APIs are categorized as follows:
	    API Control
	    Naming
	    Conversation Management
	    Security
	    Marshalling
	    Message Attribute Utilities
	    Message Selection Filter Utilities
	    Queue Attribute Utilities
	    Queue Management Utilities
	In addition, sample programs have been provided to help illustrate
	the use of the MOS-API.


    1.2 Terms and Definitions

	API:  Application Programming Interface

	MOS:  Message Oriented Service

	MOM:  Message Oriented Middleware

	MP:   Messaging Passing model

	MQ:   Messaging Queuing model

	MS:   Messaging Service

	NSI:  Name Service Interface


    1.3 References

	For Messaging Information outside and within OSF:
	    http://www.osf.org/OSF-only/ct/messaging



2.0 Message Oriented Service Application Programming Interface (MOS-API)

    The following table describes a high-level list of functions by
    category and the services offered. Note that the APIs related to
    messaging specifically begin with "mos_".

    API Control:

       mos_done():           Releases all resources used by a MOS
			     application.


    Naming:

       mos_rsrc_dflt_quemgr_get():
			     Returns the default queue manager used by
			     a MOS application.

       mos_rsrc_dflt_quemgr_set():
			     Sets the default queue manager to be used
			     by a MOS application.

       mos_rsrc_attach():    Finds one existing resource by name in the
			     namespace.
			     A resource is a name in the namespace that
			     may be a queue, a Q-mgr, a destination peer
			     application, a specific NSI entry, group, or
			     profile name.

       mos_rsrc_detach():    Releases one resource and any allocated
			     memory within MOS associated with the named
			     resource.
			     It is the responsibility of the caller to
			     release any resources obtained via
			     mos_rsrc_attach(), mos_rsrc_dflt_quemgr_get(),
			     mos_rsrc_dflt_quemgr_set(), mos_que_mgmt_create(),
			     or mos_msg_attr_notice_set().

       mos_rsrc_name_get():  Returns the queue manager name, its security group
			     name, its principal name, and, if applicable, the
			     queue name itself for the specified resource
			     handle.

      -Manipulating Groups:

       mos_rsrc_group_attach():
			     Finds one existing NSI group by name in the
			     namespace.

       mos_rsrc_group_detach():
			     Releases one NSI group and any allocated
			     memory within MOS associated with the named
			     group.
			     It is the responsibility of the caller to
			     release any resources obtained via
			     mos_rsrc_group_attach() or mos_rsrc_group_create().

       mos_rsrc_group_create():
			     Creates one NSI group with no members.

       mos_rsrc_group_delete():
			     Deletes one NSI group.

       mos_rsrc_group_mbr_add():
			     Add a member to a group.

       mos_rsrc_group_mbr_remove():
			     Remove one member from the specified group.

       mos_rsrc_group_mbr_list():
			     Returns all member names from a group.


    Conversation Management (Applies to Message Queuing model only.):

       mos_msg_enqueue():    Enqueue one message to a queue.

       mos_msg_group_enqueue():
			     Enqueue a message to all members of a
			     specified NSI group of queues.

       mos_msg_dequeue():    Dequeue one message from a queue.

       mos_msg_peek():       Returns a copy of one message from a queue.

       mos_msg_delete():     Delete one message by message ID from a queue.

       mos_msg_move():       Move one message by message ID from one
			     queue to another.

    Security (Applies to Message Queuing model only.):

       mos_msg_attr_protectlvl_get():
			     Return the end-to-end protection level of
			     initial sender from the message attribute
			     structure.
			     Applies to Message Queuing model only.

       mos_msg_attr_protectlvl_set():
			     Sets the end-to-end protection level of initial
			     sender in the message attribute structure.
			     Applies to Message Queuing model only.

       mos_msg_attr_secid_get():
			     Return the security identity of initial sender
			     of a message from the message attribute structure.
			     Applies to Message Queuing model only.

       mos_rsrc_protectlvl_get():
			     Returns the protection level for
			     communications made to a resource. This
			     is not to be confused with end-to-end
			     protection levels described in Section 2.4.

       mos_rsrc_protectlvl_set():
			     Sets and registers the protection level for
			     communications made to a resource. This
			     is not to be confused with end-to-end
			     protection levels described in Section 2.4.


    Marshalling (Applies to Message Queuing model only.):

       mos_api_datatype_register():
			     Register one application-specific data
			     type and its associated conversion
			     function with MOS to encode/decode the data.

       mos_api_datatype_unregister():
			     Unregister one application-specific data
			     type and its associated conversion
			     function with MOS to encode/decode the data.

       mos_msg_attr_datatype_get():
			     Return application-specific data type
			     from message attributes structure.

       mos_msg_attr_datatype_set():
			     Set application-specific data type in message
			     attributes structure.

       mos_msg_datatype_decode():
			     Decodes the message buffer returned by
			     mos_msg_dequeue() or mos_msg_peek().

       mos_msg_buf_free():
			     Releases memory used for the message buffer.
			     It is the responsibility of the caller to
			     release the memory if allocated by
			     mos_msg_dequeue() or mos_msg_peek().


    Message Attribute Utilities:

       mos_msg_attr_alloc():   Allocates memory within MOS and returns an
			       opaque pointer to a message attributes
			       structure with defaults set.

       mos_msg_attr_peek():
			       Returns an opaque pointer to the message
			       attributes on an existing message in the
			       specified queue.
			       Applies to Message Queuing model only.

       mos_msg_attr_free():    Releases memory used for message attributes.
			       It is the responsibility of the caller to
			       release the memory if allocated by
			       mos_msg_attr_alloc() or mos_msg_attr_peek().

       mos_msg_attr_msgid_get():
			       Return message ID from a message attributes
			       structure.
       mos_msg_attr_enqtime_get():
			       Return message enqueue time stamp in absolute
			       time from message attributes structure.

       mos_msg_attr_msgtype_get():
			       Return message type from message attributes
			       structure.
       mos_msg_attr_msgtype_set():
			       Set message type in message attributes
			       structure.

       mos_msg_attr_priority_get():
			       Return priority from message attributes
			       structure.
       mos_msg_attr_priority_set():
			       Set priority in message attributes structure.

       mos_msg_attr_ttl_get(): Return message expiration(time-to-live) in
			       absolute time from message attributes structure.
       mos_msg_attr_ttl_set(): Set message expiration(time-to-live) in
			       absolute time in message attributes structure.

       mos_msg_attr_ttr_get(): Return time-to-receive in absolute time from
			       message attributes structure.
       mos_msg_attr_ttr_set(): Set time-to-receive in absolute time in
			       message attributes structure.

       mos_msg_attr_persistence_get():
			       Return persistence from message attributes
			       structure.
       mos_msg_attr_persistence_set():
			       Set persistence in message attributes structure.

       mos_msg_attr_notice_get():
			       Return notice options from message attributes
			       structure.
       mos_msg_attr_notice_set():
			       Set notice options in message attributes
			       structure and return a handle to the notice
			       destination.


    Message Selection Filter Utilities (Applies to Message Queuing model only.):

       mos_msg_selfilter_alloc():
			       Allocates memory within MOS and returns an
			       opaque pointer to a selection filter
			       structure.
			       The selection filter is comprised of one
			       or more masks that follow the rules of
			       the logical AND operator among all
			       specified criteria when retrieving messages.

       mos_msg_selfilter_free():
			       Releases memory used for the selection
			       filter when retrieving messages.
			       It is the responsibility of the caller
			       to release the memory if allocated by
			       mos_msg_selfilter_alloc().

       mos_msg_selmask_add():  Adds one mask to the list of masks in the
			       selection filter structure. A mask is
			       comprised of a selection criteria type, a
			       selection criteria value, and the relational
			       operator to be performed.


    Queue Attribute Utilities (Applies to Message Queuing model only.):

       mos_que_attr_alloc():   Allocates memory within MOS and returns an
			       opaque pointer to a queue attributes
			       structure with defaults set.

       mos_que_attr_peek():    Returns an opaque pointer to the queue
			       attributes on an existing queue.

       mos_que_attr_free():    Releases memory used for queue attributes.
			       It is the responsibility of the caller to
			       release the memory if allocated by
			       mos_que_attr_alloc() or mos_que_attr_peek().

       mos_que_attr_commit():  Commit queue attribute modifications on an
			       existing queue.

       mos_que_attr_queid_get():
			       Return queue ID from queue attributes structure.
       mos_que_attr_quecursize_get():
			       Return current queue size from queue
			       attributes structure.
       mos_que_attr_createtime_get():
			       Return queue creation time stamp in absolute
			       time from queue attributes structure.
       mos_que_attr_activetime_get():
			       Return queue last activity time stamp in
			       absolute time from queue attributes structure.

       mos_que_attr_alias_list():
			       Return the list of queue aliases by name
			       from queue attributes structure.
			       The first entry in the list is the queue
			       name itself.

       mos_que_attr_alias_add():
			       Adds one queue alias to the list of
			       queue aliases in the queue attributes
			       structure.

       mos_que_attr_alias_remove():
			       Removes one queue alias from the list of
			       queue aliases in the queue attributes
			       structure.

       mos_que_attr_alias_reset():
			       Sets the queue alias list to NULL in the queue
			       attributes structure.

       mos_que_attr_annotation_get():
			       Return queue annotation from queue attributes
			       structure.
       mos_que_attr_annotation_set():
			       Set queue annotation in queue attributes
			       structure.

       mos_que_attr_quemaxsize_get():
			       Return maximum queue size from queue
			       attributes structure.
       mos_que_attr_quemaxsize_set():
			       Set maximum queue size in queue attributes
			       structure.

       mos_que_attr_msgmaxsize_get():
			       Return maximum message size allowed on a queue
			       from queue attributes structure.
       mos_que_attr_msgmaxsize_set():
			       Set maximum message size allowed on a queue
			       in queue attributes structure.

       mos_que_attr_persistence_get():
			       Return queue persistence from queue attributes
			       structure.
       mos_que_attr_persistence_set():
			       Set queue persistence in queue attributes
			       structure.

       mos_que_attr_idletimeout_get():
			       Return queue idle timeout in relative time
			       from queue attributes structure.
       mos_que_attr_idletimeout_set():
			       Set queue idle timeout in relative time in
			       queue attributes structure.

       mos_que_attr_allowenq_get():
			       Return boolean that describes whether enqueuing
			       is allowed or not from queue attributes
			       structure.
       mos_que_attr_allowenq_set():
			       Turn enqueuing on or off in queue
			       attributes structure.

       mos_que_attr_allowdeq_get():
			       Return boolean that describes whether dequeuing
			       is allowed or not from queue attributes
			       structure.
       mos_que_attr_allowdeq_set():
			       Turn dequeuing on or off in queue
			       attributes structure.


    Queue Management Utilities (Applies to Message Queuing model only.):

       mos_que_mgmt_create():  Create one queue and commit its queue
			       attributes to be managed by one
			       queue manager.

       mos_que_mgmt_delete():  Delete one queue managed by the specified
			       queue manager.

       mos_que_mgmt_move():    Move or rename one queue within a Q-mgr or
			       from one Q-mgr to another.

       mos_que_mgmt_save():    Save all messages in the specified queue
			       to persistent storage.

       mos_que_mgmt_quecount_get():
			       Return number of queues managed by
			       specified Q-mgr.

       mos_que_mgmt_quename_list():
			       Return list of queues by name managed by
			       specified Q-mgr.

       mos_que_mgmt_msgid_list():
			       Return list of messages by UUID from the
			       specified queue that satisfy the selection
			       criteria.


    2.1 API Control

	This group of interfaces performs general initialization and
	cleanup of messaging and queuing facilities. They are called at
	the beginning and end of applications.

	2.1.1 mos_done()

	    2.1.1.1 mos_done() Synopsis

	    void
	    mos_done(
		     [out] error_status_t *        status
	    );

	    where
		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	    2.1.1.2  mos_done() Internal Description

		  Release all resources used in MOS for this application.

		  In the message queuing model, queues are not deleted
		  implicitly. The calling application must use
		  mos_que_mgmt_delete() explicitly for each queue that is no
		  longer required.


    2.2 Naming

       In DCE, naming is achieved via the RPC Naming Service Interface(NSI).
       MOS-API provides an interface to attach and detach to resources as
       well as creating groups of resources. A resource is a name in the
       namespace that may be a queue, a Q-mgr, a destination peer application,
       a specific NSI entry, group, or profile name.

       In MOS-API, name syntaxes are hardwired as "rpc_c_ns_syntax_default".
       An environment variable for the default queue manager is also
       provided:  MOS_DFLT_QUEMGR_NAME.

       For seasoned DCE application writers, the RPC-API may be used for
       manipulating NSI entries, groups, and profiles. For example, if
       a messaging application requires to work with profiles, then
       the RPC-API may be used.

	/*
	 * Generic name service handle
	 */
	typedef struct mos_rsrc_info_s_t * mos_handle_t;

	#define mos_c_dflt_name_syntax        rpc_c_ns_syntax_default




	/*
	 * Protection level for Message Queuing Model
	 */
	const long mos_c_protect_level_default =
		      rpc_c_protect_level_call;
	const long mos_c_protect_level_none =
		      rpc_c_protect_level_none; /* no authentication performed*/
	const long mos_c_protect_level_auth =
		      rpc_c_protect_level_call; /* on first pkt of each call */
	const long mos_c_protect_level_integ =
		      rpc_c_protect_level_pkt_integ; /* strong integrity chk */
	const long mos_c_protect_level_privacy =
		      rpc_c_protect_level_pkt_privacy; /* encrypt arguments */


	/*
	 * Additional Protection levels for Message Passing Model
	 */
	const long mos_c_protect_level_connect =
		      rpc_c_protect_level_connect; /* only on "connect" */
	const long mos_c_protect_level_pkt =
		      rpc_c_protect_level_pkt;     /* on each packet */

	/*
	 * Authentication services for Message Passing Model
	 *
	 * The various authentication schemes/protocols available to apps.
	 */
	const long mos_c_authn_none =
		      rpc_c_authn_none; /* no authentication */
	const long mos_c_authn_dce_secret =
		      rpc_c_authn_dce_secret;
					/* OSF DCE shared secret key auth */
	const long mos_c_authn_dce_public =
		      rpc_c_authn_dce_public;
				      /* OSF DCE public key auth (reserved) */
	const long mos_c_authn_dce_dummy =
		      rpc_c_authn_dce_dummy; /* OSF DCE non-crypto auth */
	const long mos_c_authn_dssa_public =
		      rpc_c_authn_dssa_public;
				      /* DSSA public key auth (reserved) */
	const long mos_c_authn_default =
		      rpc_c_authn_default; /* default for environment */

	/*
	 * Authorization services for Message Passing Model
	 *
	 * The various authorization schemes/protocol available to applications.
	 * The application's choice of authentication service determines the
	 * set of authorization services the application is allowed to use.
	 */
	const long mos_c_authz_none = rpc_c_authz_none;
	const long mos_c_authz_name = rpc_c_authz_name;
	const long mos_c_authz_dce = rpc_c_authz_dce;


       2.2.1 mos_rsrc_dflt_quemgr_get()

	  Returns the default queue manager used by a MOS application.

	  2.2.1.1 mos_rsrc_dflt_quemgr_get() Synopsis

	     void
	     mos_rsrc_dflt_quemgr_get(
			  [in]  sec_rgy_name_t          security_name,
			  [out] mos_rsrc_name_t         name,
			  [out] mos_handle_t *          resource_handle,
			  [out] error_status_t *        status
	     );

	      where
		security_name:
		    Security group name where the default queue manager
		    is a member.

		    If NULL is specified, caller trusts CDS. Not recommended.

		name:
		    Cell-relative name of default queue manager.

		resource_handle:
		    A context handle to the attached resource.

		    If NULL is specified, the resource handle is not
		    returned. Otherwise, it is the caller's responsibility
		    to release the resource and any allocated memory
		    within MOS via mos_rsrc_detach(). For example, the
		    caller may already have a resource handle to the
		    default queue manager.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	  2.2.1.2 mos_rsrc_dflt_quemgr_get() Internal Description

	    For DCE, this function performs the following:

		 * The search order is:
		      1) Determine if caller has previously obtained or
			 set a default queue manager.

		      2) Environment variable:
			   MOS_DFLT_QUEMGR_NAME
			   This points to the default Q-mgr.

		      3) Per host profile or hostdata object:
			   /.:/hosts/$HOSTNAME/msg.profile
			   This contains a list of Q-mgrs for this host
			   and their priority.

		      4) Per cell profile:
			   /.:/cell-profile
			   This contains an entry for the default Q-mgr.

		 * If STEP 1 was not performed, then:

		   * Obtain a partial binding handle from CDS.
		       - Use rpc_ns_binding_import_begin(),
			     rpc_ns_binding_import_next(),
			     rpc_ns_binding_import_done()
			 to import first server.
		       - Resolve the partial binding via
			 rpc_ep_resolve_binding().

		   * If the security name is NULL, bypass this check.
		     Determine if security name is a principal name or
		     a group name.
		     For a security group name, obtain the server's
		     principal name via rpc_mgmt_inq_server_princ_name().
		     Then validate that this principal is a member of the
		     security group he's supposed to be in.
		       - Obtain local cell name via dce_cf_get_cell_name().
		       - Bind to local cell registry via sec_rgy_site_open().
		       - Obtain principal's cell-relative name via
			 sec_id_parse_name().
			 - Determine whether principal is valid member of
			 security group via sec_rgy_pgo_is_member().
		      If this fails and this is a message passing model,
		      then determine whether the name is a principal via
		      sec_rgy_pgo-get_by_name().

		   * If the message queuing model, authentication and
		     authorization information bewteen clients and Q-mgrs
		     are set implicitly due to ACLs on queues.
		     "rpc_binding_set_auth_info()" is invoked with the
		     following defaults:
		       authentication service = rpc_c_authn_dce_secret,
		       authorization service  = rpc_c_authz_dce,
		       protection level       = rpc_c_protect_level_default


       2.2.1 mos_rsrc_dflt_quemgr_set()

	  Sets the default queue manager to be used by a MOS application.

	  2.2.1.1 mos_rsrc_dflt_quemgr_set() Synopsis

	     void
	     mos_rsrc_dflt_quemgr_set(
			  [in]  mos_rsrc_name_t         name,
			  [in]  sec_rgy_name_t          security_name,
			  [out] mos_handle_t *          resource_handle,
			  [out] error_status_t *        status
	     );

	      where
		name:
		    Name where the search for resources begins.
		    This can be either a global or cell-relative name.

		security_name:
		    Specifies the security group name where the default
		    queue manager is a member.

		    If NULL is specified, caller trusts CDS. Not recommended.

		resource_handle:
		    A context handle to the attached resource.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	  2.2.1.2 mos_rsrc_dflt_quemgr_set() Internal Description

	    For DCE, this function performs the following:

		 * Obtain a partial binding handle from CDS.
		     - Use rpc_ns_binding_import_begin(),
			   rpc_ns_binding_import_next(),
			   rpc_ns_binding_import_done()
		       to import first server.
		     - Resolve the partial binding via
		       rpc_ep_resolve_binding().

		 * If the security name is NULL, bypass this check.
		   Determine if security name is a principal name or
		   a group name.
		   For a security group name, obtain the server's
		   principal name via rpc_mgmt_inq_server_princ_name().
		   Then validate that this principal is a member of the
		   security group he's supposed to be in.
		     - Obtain local cell name via dce_cf_get_cell_name().
		     - Bind to local cell registry via sec_rgy_site_open().
		     - Obtain principal's cell-relative name via
		       sec_id_parse_name().
		     - Determine whether principal is valid member of
		       security group via sec_rgy_pgo_is_member().
		    If this fails and this is a message passing model,
		    then determine whether the name is a principal via
		    sec_rgy_pgo-get_by_name().

		 * If the message queuing model, authentication and
		   authorization information bewteen clients and Q-mgrs
		   are set implicitly due to ACLs on queues.
		   "rpc_binding_set_auth_info()" is invoked with the
		   following defaults:
		     authentication service = rpc_c_authn_dce_secret,
		     authorization service  = rpc_c_authz_dce,
		     protection level       = rpc_c_protect_level_default


       2.2.3 mos_rsrc_attach()

	  Finds one existing resource by name in the namespace.
	  It does not create any resources in the namespace.

	  2.2.3.1 mos_rsrc_attach() Synopsis

	     void
	     mos_rsrc_attach(
			  [in]  mos_rsrc_name_t         name,
			  [in]  sec_rgy_name_t          security_name,
			  [out] mos_handle_t *          resource_handle,
			  [out] error_status_t *        status
	     );

	      where
		name:
		    Name where the search for resources begins.
		    This can be either NULL, a simple, global or
		    cell-relative name.

		    If NULL or a simple name is specified, the default
		    queue manager is used.

		security_name:
		    Specifies either a principal name or the security group
		    name where the named resource is a member. In a message
		    queuing model, only a security group name is allowed.
		    In a message passing model, a sender knows what recipient
		    to trust and only has to specify a principal name, if
		    desired.

		    If NULL is specified, caller trusts CDS. Not recommended.

		resource_handle:
		    A context handle to the attached resource.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	  2.2.3.2 mos_rsrc_attach() Internal Description

	    For DCE, this function performs the following:

		 * Determine the resolved and unresolved components of
		   the name via rpc_ns_entry_inq_resolution().

		   Refer to OT 13614 to correctly resolve a name with
		   a CDS link in it.

		 * When caching resource information, reuse binding
		   handle if same Q-mgr during multiple calls to
		   mos_rsrc_attach().

		 * Using the resolved name, obtain a partial binding
		   handle from CDS. Note that the RPC-API determines
		   whether the name is an NSI entry, group, or profile.
		     - Use rpc_ns_binding_import_begin(),
			   rpc_ns_binding_import_next(),
			   rpc_ns_binding_import_done()
		       to import first server.
		     - Resolve the partial binding via
		       rpc_ep_resolve_binding().

		 * If there is no unresolved name, then this is not
		   a queue. Otherwise, using the unresolved name, talk
		   to the Q-mgr to see if queue exists.

		 * If the security name is NULL, bypass this check.
		   Determine if security name is a principal name or
		   a group name.
		   For a security group name, obtain the server's
		   principal name via rpc_mgmt_inq_server_princ_name().
		   Then validate that this principal is a member of the
		   security group he's supposed to be in.
		     - Obtain local cell name via dce_cf_get_cell_name().
		     - Bind to local cell registry via sec_rgy_site_open().
		     - Obtain principal's cell-relative name via
		       sec_id_parse_name().
		     - Determine whether principal is valid member of
		       security group via sec_rgy_pgo_is_member().
		    If this fails and this is a message passing model,
		    then determine whether the name is a principal via
		    sec_rgy_pgo-get_by_name().

		 * If the message queuing model, authentication and
		   authorization information bewteen clients and Q-mgrs
		   are set implicitly due to ACLs on queues.
		   "rpc_binding_set_auth_info()" is invoked with the
		   following defaults:
		     authentication service = rpc_c_authn_dce_secret,
		     authorization service  = rpc_c_authz_dce,
		     protection level       = rpc_c_protect_level_default


       2.2.4 mos_rsrc_detach()

	  Releases one resource and any allocated memory within MOS
	  associated with the named resource. It does not delete any
	  resources in the namespace.

	  It is the responsibility of the caller to release any resources
	  obtained via mos_rsrc_attach(), mos_rsrc_dflt_quemgr_get(),
	  mos_rsrc_dflt_quemgr_set(), or mos_que_mgmt_create().

	  2.2.4.1 mos_rsrc_detach() Synopsis

	     void
	     mos_rsrc_detach(
			  [in,out] mos_handle_t *       resource_handle,
			  [out] error_status_t *        status
	     );

	      where
		resource_handle:
		    A context handle to the attached resource.
		    If the detach operation succeeds, this parameter
		    returns the value NULL.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	  2.2.4.2 mos_rsrc_detach() Internal Description

	     This function releases binding handle resources via
	     "rpc_binding_free(). Any memory associated with this
	     binding handle is also freed.

	     When releasing resource information, take care that there
	     is not other cached queues to this server handle.


       2.2.5 mos_rsrc_name_get()

	  Returns the queue manager name, its security group name, its
	  principal name, and, if applicable, the queue name itself for the
	  specified resource handle.

	  2.2.5.1 mos_rsrc_name_get() Synopsis

	     void
	     mos_rsrc_name_get(
			  [in]  mos_handle_t         resource_handle,
			  [out] sec_rgy_name_t       security_name,
			  [out] sec_rgy_name_t       quemgr_prin_name,
			  [out] mos_rsrc_name_t      quemgr_name,
			  [out] mos_rsrc_name_t      que_name,
			  [out] error_status_t *     status
	     );

	      where
		resource_handle:
		    A context handle to the attached resource.

		security_name:
		    Security group name of the queue manager.
		    This is the name that was specified when the resource
		    was attached to, not the DCE groups of which the queue
		    manager principal is a member.  If no name was given,
		    a NULL string is returned.
                    If NULL, name is not returned.

		quemgr_prin_name:
		    Queue manager's principal name.
                    If NULL, name is not returned.

		quemgr_name:
		    Namespace entry where the queue manager is registered.
                    If NULL, name is not returned.

		que_name:
		    Name of the queue to which this resource is attached.
		    If the handle is to a queue manager itself, a NULL string
		    is returned.
                    If NULL, name is not returned.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	    Note that the space by for the returned information is provided
	    by the caller.

       2.2.6 mos_rsrc_group_attach()

	  Finds one existing NSI group by name in the namespace.
	  It does not create an NSI group. To create an NSI group,
	  use mos_rsrc_group_create().

	  Note that members of an NSI group may belong to different
	  security groups. As a result, a security group validation
	  can not performed on NSI groups.

	  2.2.6.1 mos_rsrc_group_attach() Synopsis

	     void
	     mos_rsrc_group_attach(
			  [in]  mos_rsrc_name_t      group_name,
			  [out] mos_handle_t *       resource_handle_to_group,
			  [out] error_status_t *     status
	     );

	      where
		group_name:
		    Specifies an existing NSI group name.
		    This can be either a global or cell-relative name.

		resource_handle_to_group:
		    A context handle to one or more attached resources.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	  2.2.6.2 mos_rsrc_group_attach() Internal Description

	    For DCE, this function performs the following:

		 * Obtain the name of each member of the group.
		     - Use rpc_ns_group_mbr_inq_begin(),
			   rpc_ns_group_mbr_inq_next(),
			   rpc_ns_group_mbr_inq_done()

		 * For each member, invoke mos_rsrc_attach() to
		   obtain its binding handle and other resource
		   information. Add each member's handle to the
		   group's list of member handles.

		 * Add this group handle to the list of group handles
		   maintained by the API.


       2.2.7 mos_rsrc_group_detach()

	  Releases one NSI group and any allocated memory within MOS
	  associated with the named group. It does not delete the NSI
	  group itself. To delete an NSI group, use mos_rsrc_group_delete().

	  It is the responsibility of the caller to release any resources
	  obtained via mos_rsrc_group_attach() or mos_rsrc_group_create().

	  2.2.7.1 mos_rsrc_group_detach() Synopsis

	     void
	     mos_rsrc_group_detach(
			  [in] mos_handle_t         resource_handle_to_group,
			  [out] error_status_t *    status
	     );

	      where
		resource_handle_to_group:
		    A context handle to one or more attached resources.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	  2.2.7.2 mos_rsrc_group_detach() Internal Description

	    For DCE, this function performs the following:

		 * For each member, invoke mos_rsrc_detach() to
		   release its binding handle and other resource
		   information. Remove each member's handle to the
		   group's list of member handles.

		 * Remove this group handle from the list of group handles
		   maintained by the API. Any memory associated with this
		   group is also freed.



       2.2.8 mos_rsrc_group_create()

	     Creates one NSI group with no members.

	   2.2.8.1 mos_rsrc_group_create() Synopsis

	     void
	     mos_rsrc_group_create(
			  [in]  mos_rsrc_name_t     group_name,
			  [out] mos_handle_t *      resource_handle_to_group,
			  [out] error_status_t *    status
	     );

	     where
		 group_name:
		    Specifies a NSI group name to create.
		    This can be either a global or cell-relative name.

		 resource_handle_to_group:
		    A context handle to one or more attached resources.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	   2.2.8.2  mos_rsrc_group_create() Internal Description

		 Invoke "rpc_ns_mgmt_entry_create()" to create an entry
		 in the name service database.

		 If successful, allocate the "resource_handle_to_group"
		 that holds the group name. Note that potentially a list of
		 binding handles to the group members are also maintained.

		 The "resource_handle_to_group" and the status are then
		 returned to the calling application.


       2.2.9 mos_rsrc_group_delete()

	     Delete one NSI group.

	   2.2.9.1 mos_rsrc_group_delete() Synopsis

	     void
	     mos_rsrc_group_delete(
			  [in] mos_handle_t *       resource_handle_to_group,
			  [out] error_status_t *    status
	     );

	     where
		 resource_handle_to_group:
		    A context handle to one or more attached resources.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	   2.2.9.2  mos_rsrc_group_delete() Internal Description

		Determine if the named group exists in the list of groups
		maintained by the API.

		Invoke "rpc_ns_group_delete()" to delete the NSI group.

		If successful, invoke "mos_rsrc_detach()" to release all
		binding handles obtained for each member of the group
		and release any allocated memory within MOS associated
		with the named group.

		Return the status to the calling application.


       2.2.10 mos_rsrc_group_mbr_add()

	     Add one member to a group.

	   2.2.10.1 mos_rsrc_group_mbr_add() Synopsis

	     void
	     mos_rsrc_group_mbr_add(
			  [in]  mos_handle_t *      resource_handle_to_group,
			  [in]  mos_rsrc_name_t     member_name,
			  [out] error_status_t *    status
	     );

	     where
		 resource_handle_to_group:
		    A context handle to one or more attached resources.

		 member_name:
		    Specifies a member name to be added to the
		    specified group. This can be either a global
		    or cell-relative name.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	   2.2.10.2  mos_rsrc_group_mbr_add() Internal Description

		Determine if the named group exists in the list of groups
		maintained by the API.

		Invoke "mos_rsrc_attach()" to determine if new member/queue
		exists and to obtain its handle information.

		Invoke "rpc_ns_group_mbr_add()".

		If successful, add this group member's handle information
		to the "resource_handle_to_group".

		Return the status to the calling application.



       2.2.11 mos_rsrc_group_mbr_remove()

	     Remove one member from the specified group.

	   2.2.11.1 mos_rsrc_group_mbr_remove() Synopsis

	     void
	     mos_rsrc_group_mbr_remove(
			  [in]  mos_handle_t *      resource_handle_to_group,
			  [in]  mos_rsrc_name_t     member_name,
			  [out] error_status_t *    status
	     );

	     where
		 resource_handle_to_group:
		    A context handle to one or more attached resources.

		 member_name:
		    Specifies a member name to be removed from the
		    specified group.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	   2.2.11.2  mos_rsrc_group_mbr_remove() Internal Description

		Determine if the named group exists in the list of groups
		maintained by the API.

		Invoke "rpc_ns_group_mbr_remove()".

		If successful, invoke "mos_rsrc_detach()" to release the
		binding handle obtained for this member of the group
		and release any allocated memory within MOS associated
		with this group member from the "resource_handle_to_group".

		Return the status to the calling application.


       2.2.12 mos_rsrc_group_mbr_list()

	     Returns all member names from a group.

	   2.2.12.1 mos_rsrc_group_mbr_list() Synopsis

	     void
	     mos_rsrc_group_mbr_list(
		       [in]  mos_handle_t           resource_handle_to_group,
		       [in]  unsigned32             space_avail,
		       [out] unsigned32 *           num_returned,
		       [out] mos_rsrc_name_t        mbr_name_list[],
		       [out] unsigned32 *           num_left,
		       [out] error_status_t *       status
	     );

	     where
		 resource_handle_to_group:
		    A context handle to one or more attached resources.

		 space_avail:
		    Specifies the size of the "mbr_name_list" array.
		    The caller is responsible for allocating the space
		    for "space_avail" member names.

		 num_returned:
		    The number of group member names from the specified
		    group returned in the "mbr_name_list".

		 mbr_name_list:
		    Array of group member names returned.
		    The size of the array is determined by "space_avail"
		    and the length by "num_returned".

		 num_left:
		    Number of group members that were found but could not
		    be returned because of space constraints of
		    "mbr_name_list" array. Note that this number may be
		    inaccurate if group members have been created/deleted
		    bewteen successive queries.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	   2.2.11.2  mos_rsrc_group_mbr_list() Internal Description

		Determine if the named group exists in the list of groups
		maintained by the API.

		Loop thru each member of the group to obtain all member
		names from the "resource_handle_to_group".

		All output parameters returned to the calling application.


    2.3 Conversation Management

	This group of interfaces do the actual work of getting messages
	from senders to recipients. Also, interfaces to send messages to
	groups of recipients are provided.

	2.3.1 mos_msg_enqueue()

	    Enqueue one message to a queue.

	    The caller must have the proper access rights to enqueue a
	    message to a queue.

	    2.3.1.1 mos_msg_enqueue() Synopsis

	    void
	    mos_msg_enqueue(
			 [in]  mos_handle_t             resource_handle,
			 [in]  unsigned32               flags,
			 [in]  mos_msg_attr_t           msg_attributes,
			 [in]  void *                   msg_buffer,
			 [out] uuid_t *                 msg_id,
			 [out] error_status_t *         status
	    );

	    where
		resource_handle:
		    A context handle to a resource.

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		flags:
		    Indicates the message delivery mode. Only one option
		    is allowed to be specified.
		    The default is mos_c_enqmode_async.

		    /*
		     * If mos_c_enqmode_async, the API will return immediately
		     * from the messaging system. The message delivery status
		     * is completely unknown when returning from the send
		     * operation. However, the sender can find out message
		     * delivery status through receipt of ACK messages
		     * requested via various notice options if specified.
		     */
		    #define mos_c_enqmode_async        0x00000000
		    /*
		     * If mos_c_enqmode_sync, the API will wait for a return
		     * result from the messaging system.
		     * Applies only to the message passing model.
		     */
		    #define mos_c_enqmode_sync         0x00000001
		    /*
		     * mos_c_enqmode_nowait_enq applies only in the message
		     * queuing model and synchronous communication mode.
		     * If mos_c_enqmode_nowait_enq, the API will return
		     * immediately with an error if the queue is full.
		     */
		    #define mos_c_enqmode_nowait_enq   0x00000002
		    /*
		     * mos_c_enqmode_wait_enq applies only in the message
		     * queuing model and synchronous communication mode.
		     * If mos_c_enqmode_wait_enq, the API will wait until the
		     * specified queue is no longer full.
		     * At this point, the message has been enqueued, but
		     * the "dequeue" delivery status is unknown. However,
		     * the sender can find out message delivery status
		     * through receipt of ACK messages requested via various
		     * notice options if specified.
		     */
		    #define mos_c_enqmode_wait_enq     0x00000004
		    /*
		     * mos_c_enqmode_wait_deq applies only in the message
		     * queuing model and synchronous communication mode.
		     * If mos_c_enqmode_wait_deq, the API will wait until a
		     * message has been retrieved.
		     */
		    #define mos_c_enqmode_wait_deq     0x00000008

		msg_attributes:
		    Use the utilities to allocate, set, and free message
		    attributes. This interface was provided so that the
		    application developer does not have to know what the
		    message attribute structure looks like and allows
		    flexibility to provide future message attributes.

		    typedef struct mos_mattr_s_t * mos_msg_attr_t;

		    If NULL is specified, the API automatically allocates
		    and set all defaults for the message attributes.
		    Otherwise, it is the caller's responsibility to release
		    the memory allocated for the message attributes structure
		    via mos_msg_attr_free().

		msg_buffer:
		    Opaque pointer to application-specific buffer contents.
		    An empty message buffer is supported. The queue manager
		    does not care about its contents and the application
		    designer could be using an empty message to signal an
		    event.

	       msg_id:
		    Unique message ID generated by the send API operations.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	    2.3.1.2 mos_msg_enqueue() Internal Description

		This API generates a unique message ID for the message
		and places it in the message attributes area of the message.
		If message queuing model, this API uses the end-to-end
		protection level in the message attributes area of the
		message to set the protection level bewteen sender and
		Q-mgr on every send operation via rpc_binding_set_auth_info().

		The API invokes the registered conversion function
		associated with the data type specified in the message
		attributes to encode the "msg_buffer".

		The "msg_buffer" and its "msg_attributes" are sent to
		the specified resource via the resource handle. It could
		be a Q-mgr or a destination peer application.

		The "msg_id" and the status are then returned to
		the calling application.


       2.3.2 mos_msg_group_enqueue()

	     Enqueue a message to all members of a specified NSI group
	     of queues. The caller must have the proper access rights to
	     enqueue a message to a queue.

	     For group delivery, the API attempts to send the message
	     once to all members of the group and return. If a failure
	     occurs with one or more members, it will not attempt to delete
	     the message from the other members of the group where the
	     operation was successful. If a sender wishes to specify
	     async/sync, enqueue_block/enqueue_nonblock, or
	     dequeue_block/dequeue_nonblock modes, then it should use
	     the naming APIs to loop thru each member of the group and
	     perform a send operation one by one. The default is
	     asynchronous. In a message queuing model, there is no waiting
	     for enqueuing or dequeuing.

	     For the same reason, the notice options and destination are
	     ignored in the message attributes. If a sender wishes to
	     receive ACKs, then it should use the naming APIs to loop
	     thru each member of the group and perform a send operation
	     one by one.

	   2.3.2.1 mos_msg_group_enqueue() Synopsis

	     void
	     mos_msg_group_enqueue(
		       [in]  mos_handle_t            resource_handle_to_group,
		       [in]  mos_msg_attr_t          msg_attributes,
		       [in]  void *                  msg_buffer,
		       [out] uuid_t *                msg_id,
		       [out] error_status_t *        status
	     );

	    where
		resource_handle_to_group:
		    A context handle to a group of queues.

		msg_attributes:
		    Use the utilities to allocate, set, and free message
		    attributes. This interface was provided so that the
		    application developer does not have to know what the
		    message attribute structure looks like and allows
		    flexibility to provide future message attributes.

		    typedef struct mos_mattr_s_t * mos_msg_attr_t;

		    If NULL is specified, the API automatically allocates
		    and sets all defaults for the message attributes.
		    Otherwise, it is the caller's responsibility to release
		    the memory allocated for the message attributes structure
		    via mos_msg_attr_free().

		msg_buffer:
		    Opaque pointer to application-specific buffer contents.
		    An empty message buffer is supported. The queue manager
		    does not care about its contents and the application
		    designer could be using an empty message to signal an
		    event.

	       msg_id:
		    Unique message ID generated by the send API operations.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	   2.3.2.2 mos_msg_group_enqueue() Internal Description

		First, this API generates one unique message ID.
		Then each member of the specified group is sent the
		message and its associated message attributes.

		The "msg_attributes" and the status are then returned to
		the calling application.


	2.3.3 mos_msg_dequeue()

	    Dequeue one message from a queue. If no selection criteria
	    is specified, then the first message in the queue is dequeued.
	    The queue manager returns the application-specific message
	    buffer along with its message attributes and deletes the
	    message from its queue.

	    The caller must have the proper access rights to dequeue a
	    message from a queue.

	    2.3.3.1 mos_msg_dequeue() Synopsis

	    void
	    mos_msg_dequeue(
			 [in]  mos_handle_t            resource_handle,
			 [in]  unsigned32              flags,
			 [in]  mos_msg_selfilter_t     msg_selection_filter,
			 [out] mos_msg_attr_t *        msg_attributes,
			 [out] mos_msg_buf_t *         msg_buffer,
			 [out] error_status_t *        status
	    );

	    where
		resource_handle:
		    A context handle to a resource.

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		flags:
		    Indicates the message retrieval mode. Only one option
		    is allowed to be specified.
		    The default is mos_c_deqmode_nowait.

		    /*
		     * mos_c_deqmode_nowait applies only in the message
		     * queuing model.
		     * If mos_c_deqmode_nowait, the API will return
		     * immediately with an error if the queue is empty or
		     * if the queue does not have any messages that meet the
		     * selection criteria.
		     */
		    #define mos_c_deqmode_nowait     0x00000000
		    /*
		     * mos_c_deqmode_wait applies only in the message
		     * queuing model.
		     * If mos_c_deqmode_wait, the API will wait until the
		     * specified queue is non-empty and the message meets
		     * the selection criteria.
		     */
		    #define mos_c_deqmode_wait       0x00000001

		msg_selection_filter:
		    Opaque pointer to the selection filter buffer.
		    Use the mos_msg_selfilter_alloc(), mos_msg_selfilter_free(),
		    and mos_msg_selmask_add() APIs to allocate, deallocate and
		    define one or more selection criteria. A message is
		    successfully retrieved following the rules of the logical
		    AND operator among all specified criteria.

		    A NULL value indicates no selection criteria and the
		    message at the top of the specified queue is returned.

		     /*
		      * Opaque pointer to selection filter structure
		      */
		     typedef struct mos_mask_list_s_t * mos_msg_selfilter_t;

		msg_attributes:
		    Use the utilities to get message attributes. This
		    interface was provided so that the application
		    developer does not have to know what the message attribute
		    structure looks like and allows flexibility to
		    provide future message attributes. For the
		    recipient, the security identity will be of interest
		    if authorization is to be performed.

		    typedef struct mos_mattr_s_t * mos_msg_attr_t;

		    If NULL is specified, the message attributes are not
		    returned. Otherwise, it is the caller's responsibility
		    to release the memory allocated for the message attributes
		    structure via mos_msg_attr_free().

		msg_buffer:
		    Opaque pointer to application-specific buffer contents.
		    An empty message buffer is supported. The queue manager
		    does not care about its contents and the application
		    designer could be using an empty message to signal an
		    event.

		    typedef struct mos_datatype_bytearray_s_t *mos_msg_buf_t;

		    It is the caller's responsibility to release the
		    memory allocated for the message buffer structure
		    via mos_msg_buf_free().

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	    2.3.3.2 mos_msg_dequeue() Internal Description

		If message queuing model, this API uses the end-to-end
		protection level selected in the selection criteria
		to set the protection level bewteen recipient and Q-mgr on
		every retrieve operation via rpc_binding_set_auth_info().

		Note that it is the queue manager that determines if the
		selection criteria is satisfied. This will reduce network
		traffic.

		If the sender's requested end-to-end protection level is
		higher, this API automatically negotiates a higher protection
		level to retrieve a message successfully. If the sender's
		requested end-to-end protection level is lower, this API
		returns an error message stating the protection level must
		be lowered in order to retrieve the message. The recipient
		must manually select another protection level or loop thru
		all protection levels to obtain the message with the proper
		encryption.

		The "msg_buffer", its "msg_attributes", and the status are
		then returned to the calling application. Note that the
		"msg_attributes" is not returned if specified as NULL.

	2.3.4 mos_msg_peek()

	    Returns a copy of one message from a queue. If no selection
	    criteria is specified, then the first message in the queue
	    is returned.
	    The queue manager returns the application-specific message
	    buffer along with its message attributes but does not delete
	    the message from its queue.

	    The caller must have the proper access rights to read a
	    message from a queue.

	    In the event that multiple recipients may want to retrieve
	    a message from the same queue, this API allows a copy to be
	    retrieved without deleting the message from the queue. An
	    example, may be a bulletin board.

	    2.3.4.1 mos_msg_peek() Synopsis

	    void
	    mos_msg_peek(
			 [in]  mos_handle_t            resource_handle,
			 [in]  unsigned32              flags,
			 [in]  mos_msg_selfilter_t     msg_selection_filter,
			 [out] mos_msg_attr_t *        msg_attributes,
			 [out] mos_msg_buf_t *         msg_buffer,
			 [out] error_status_t *        status
	    );

	    where
		resource_handle:
		    A context handle to a resource.

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		flags:
		    Indicates the message retrieval mode. Only one option
		    is allowed to be specified.
		    The default is mos_c_deqmode_nowait.

		    /*
		     * mos_c_deqmode_nowait applies only in the message
		     * queuing model.
		     * If mos_c_deqmode_nowait, the API will return
		     * immediately with an error if the queue is empty or
		     * if the queue does not have any messages that meet the
		     * selection criteria.
		     */
		    #define mos_c_deqmode_nowait     0x00000000
		    /*
		     * mos_c_deqmode_wait applies only in the message
		     * queuing model.
		     * If mos_c_deqmode_wait, the API will wait until the
		     * specified queue is non-empty and the message meets
		     * the selection criteria.
		     */
		    #define mos_c_deqmode_wait       0x00000001

		msg_selection_filter:
		    Opaque pointer to the selection filter buffer.
		    Use the mos_msg_selfilter_alloc(), mos_msg_selfilter_free(),
		    and mos_msg_selmask_add() APIs to allocate, deallocate and
		    define one or more selection criteria. A message is
		    successfully retrieved following the rules of the logical
		    AND operator among all specified criteria.

		    A NULL value indicates no selection criteria and the
		    message at the top of the specified queue is returned.

		     /*
		      * Opaque pointer to selection filter structure
		      */
		     typedef struct mos_mask_list_s_t * mos_msg_selfilter_t;

		msg_attributes:
		    Use the utilities to get message attributes. This
		    interface was provided so that the application
		    developer does not have to know what the message attribute
		    structure looks like and allows flexibility to
		    provide future message attributes. For the
		    recipient, the security identity will be of interest
		    if authorization is to be performed.

		    typedef struct mos_mattr_s_t * mos_msg_attr_t;

		    If NULL is specified, the message attributes are not
		    returned. Otherwise, it is the caller's responsibility
		    to release the memory allocated for the message attributes
		    structure via mos_msg_attr_free().

		msg_buffer:
		    Opaque pointer to application-specific buffer contents.
		    An empty message buffer is supported. The queue manager
		    does not care about its contents and the application
		    designer could be using an empty message to signal an
		    event.

		    typedef struct mos_datatype_bytearray_s_t *mos_msg_buf_t;

		    It is the caller's responsibility to release the
		    memory allocated for the message buffer structure
		    via mos_msg_buf_free().

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	    2.3.4.2 mos_msg_peek() Internal Description

		If message queuing model, this API uses the end-to-end
		protection level selected in the selection criteria
		to set the protection level bewteen recipient and Q-mgr on
		every retrieve operation via rpc_binding_set_auth_info().

		Note that it is the queue manager that determines if the
		selection criteria is satisfied. This will reduce network
		traffic.

		If the sender's requested end-to-end protection level is
		higher, this API automatically negotiates a higher protection
		level to retrieve a message successfully. If the sender's
		requested end-to-end protection level is lower, this API
		returns an error message stating the protection level must
		be lowered in order to retrieve the message. The recipient
		must manually select another protection level or loop thru
		all protection levels to obtain the message with the proper
		encryption.

		The "msg_buffer", its "msg_attributes", and the status are
		then returned to the calling application. Note that the
		"msg_attributes" is not returned if specified as NULL.

	2.3.5 mos_msg_delete()

	    Delete one message by message ID from a queue.
	    The queue manager does not return any application-specific
	    message buffer or its message attributes but just deletes the
	    message from its queue.

	    The caller must have the proper access rights to delete a
	    message from a queue.

	    2.3.5.1 mos_msg_delete() Synopsis

	    void
	    mos_msg_delete(
			 [in]  mos_handle_t            resource_handle,
			 [in]  uuid_t *                msg_id,
			 [out] error_status_t *        status
	    );

	    where
		resource_handle:
		    A context handle to a resource.

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		msg_id:
		    Unique message ID for message to be deleted.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	    2.3.5.2 mos_msg_delete() Internal Description

		The API sends the request to the Q-mgr managing the
		specified queue. If the caller has the proper access
		rights to delete a message from this queue and the
		message exists, the Q-mgr deletes it.

		The status is then returned to the calling application.

	2.3.6 mos_msg_move()

	    Move one message by message ID from one queue to another.

	    This is a synchronous operation. If an application wishes
	    to move messages asynchrously, create a thread to do the
	    work or dequeue/enqueue from the respective queues manually.
	    Note that a dequeue/enqueue move operation done manually does
	    not preserve the message ID and encoding/decoding of messages
	    occur if the data is not a byte array.

	    This API assumes that the source and destination queues
	    already exist. The caller must have the proper access rights
	    to dequeue from the source queue and enqueue to the destination
	    queue.


	    2.3.6.1 mos_msg_move() Synopsis

	    void
	    mos_msg_move(
			 [in]  mos_handle_t             src_resource_handle,
			 [in]  mos_handle_t             dest_resource_handle,
			 [in]  uuid_t *                 msg_id,
			 [out] error_status_t *         status
	    );

	    where
		src_resource_handle:
		    A context handle to a source queue.
		    Use mos_rsrc_attach() to get the source queue handle.

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		dest_resource_handle:
		    A context handle to a destination queue.
		    Use mos_rsrc_attach() to get the destination queue handle.

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		msg_id:
		    Unique message ID for message to be moved.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	    2.3.6.2 mos_msg_move() Internal Description

	     1) Note that the API does not invoke any encoding/decoding
		conversion functions during the message move operation.

	     2) Determine if caller has permission to dequeue from source
		queue and enqueue to destination queue.

	     3) Use the end-to-end protection level in the
		message attributes area of the message to set the
		protection level via rpc_binding_set_auth_info().

	     4) Retrieve message from source queue for copy specifying
		the message ID.

	     5) Send the message and its message attributes to the
		destination queue using the same message id.

	     6) Retrieve message from source queue for deletion specifying
		the message ID.

	     7) The status is then returned to the calling application.


    2.4 Security

       MOS-API adheres to the model specified in DCE Security AES. In
       addition, MOS-API provides an interface for an end-to-end protection
       level and a means to identify initial senders to recipients.

       For protection levels, all resources created or attached have
       a default protection level of "mos_c_protect_level_default". If
       callers wish to modify the protection level for communications
       made to a resource, then use the mos_rsrc_protectlvl_get() and
       mos_rsrc_protectlvl_set() interface. If senders and recipients wish
       to ensure an end-to-end protection level on messages, then on
       enqueue senders use the mos_msg_attr_protectlvl_get() and
       mos_msg_attr_protectlvl_set() interface to send a message with the
       desired protection level and on dequeue recipients use the
       selection filter facility with "mos_c_mask_type_protectlvl" to
       retrieve a message with the desired protection level.

       In MOS-API, the authentication service is hardwired as
       "rpc_c_authn_dce_secret". The authorization service is hardwired as
       "rpc_c_authz_dce". For identifying initial senders to recipients,
       performing authorization is left up to the recipient via the
       mos_msg_attr_secid_get() interface.

       For ACL support, DCE security may be used for manipulating acls
       on queues or queue managers, creating security groups of queue
       managers, and so forth. Use the "dcecp" interface to modify acls
       via the "acl" object and to create/modify security groups via
       the "group" object.


       2.4.1 mos_msg_attr_protectlvl_get()

	     Returns the end-to-end protection level of the initial sender
	     from message attributes structure. This API applies only to the
	     message queuing model.

	     If a recipient must manually select another protection level
	     in order to retrieve a message, obtain the message attributes
	     on a message via "mos_msg_attr_peek()", obtain the sender's
	     end-to-end protection level via "mos_msg_attr_protectlvl_get()"
	     and retrieve the message again using the same protection level
	     as a selection criteria.

	   2.4.1.1 mos_msg_attr_protectlvl_get() Synopsis

	     void
	     mos_msg_attr_protectlvl_get(
			    [in]  mos_msg_attr_t          msg_attributes,
			    [out] unsigned32 *            protect_level,
			    [out] error_status_t *        status
	     );

	     where
		msg_attributes:
		   Opaque pointer to message attributes structure obtained
		   via mos_msg_attr_alloc() or mos_msg_attr_peek().

		   typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		 protect_level:
		      Specifies how much of the information in messages
		      exchanged by principals is encrypted. Refer to
		      Section 2.2 for the list of valid protection level
		      constants for authenticated communications from
		      sender to recipient.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	   2.4.1.2  mos_msg_attr_protectlvl_get() Internal Description

	     Returns the end-to-end protection level from the message
	     attributes structure.


	2.4.2 mos_msg_attr_protectlvl_set()

	     Sets the end-to-end protection level of the initial sender
	     in the message attribute structure. This API applies only to
	     the message queuing model.

	     In a message queuing model due to ACLs on queues, all clients
	     specify authentication and authorization information implicitly
	     via mos_rsrc_attach(). However, clients, both
	     senders and recipients, may request an end-to-end protection
	     level. In order to ensure end-to-end security in the
	     message queueing model, three tasks are performed:
		1) During the send operation, the enqueue API obtains the
		   initial sender's requested end-to-end protection level
		   in the message attributes area of a message and ensures
		   that the protection level is set accordingly.
		2) During the retrieval operation, the dequeue/peek API
		   obtains the recipient's requested end-to-end protection
		   level specified in the selection filter via
		   "mos_c_mask_type_protectlvl" and ensures that the
		   protection level is set accordingly.
		3) At message retrieval time, the Q-mgr ensures that the
		   stronger end-to-end protection level requested from both
		   the sender and the recipient is satisfied. If the sender's
		   requested end-to-end protection level is higher, the
		   retrieve API automatically negotiates a higher protection
		   level to retrieve a message successfully. If the sender's
		   requested end-to-end protection level is lower, the
		   retrieve API returns an error message stating the
		   protection level must be lowered in order to retrieve
		   the message. The recipient must manually select another
		   protection level or loop thru all protection levels to
		   obtain the message with the proper protection.

	   2.4.2.1 mos_msg_attr_protectlvl_set() Synopsis

	     void
	     mos_msg_attr_protectlvl_set(
			    [in]     unsigned32              protect_level,
			    [in,out] mos_msg_attr_t          msg_attributes,
			    [out]    error_status_t *        status
	     );

	     where
		 protect_level:
		      Specifies how much of the information in messages
		      exchanged by principals is encrypted. Refer to
		      Section 2.2 for the list of valid protection level
		      constants for authenticated communications from
		      sender to recipient.

		 msg_attributes:
		   Opaque pointer to message attributes structure obtained
		   via mos_msg_attr_alloc() or mos_msg_attr_peek().

		   typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	   2.4.2.2  mos_msg_attr_protectlvl_set() Internal Description

	     Sets the end-to-end protection level in the message
	     attributes structure.


       2.4.3 Security Identity

	 Security identity is obtained on a per message basis. Only the
	 trusted Q-mgr will place the initial sender's authentication
	 information in the message attributes area of a message.

	 In the message queuing model, performing authorization is left up
	 to the recipient. The DCE security API can not help here.
	 In the message passing model, this API does not apply.

	 2.4.3.1  mos_msg_attr_secid_get() Synopsis

	    void
	    mos_msg_attr_secid_get(
			    [in]  mos_msg_attr_t      msg_attributes,
			    [out] sec_id_pa_t *       sec_id,
			    [out] error_status_t *    status
	    );

	    where
	       msg_attributes:
		   Opaque pointer to message attributes structure obtained
		   via mos_msg_attr_alloc() or mos_msg_attr_peek().

		   typedef struct mos_mattr_s_t *     mos_msg_attr_t;

	       sec_id:
		   For DCE, specifies the sender's identity as privilege
		   attributes. The recipient may or may not perform
		   authorization.

		   /* Privilege Attributes as defined in id_epac.idl */
		   typedef struct {
		      sec_id_t realm;
		      sec_id_t principal;
		      sec_id_t group;
		      unsigned16 num_groups;
		      sec_id_t *groups;
		      unsigned16 num_foreign_groupsets;
		      sec_id_foreign_groupset_t *foreign_groupsets;
		   } sec_id_pa_t;

	       status:
		  A pointer to the completion status. On successful
		  completion, the routine returns error_status_ok.
		  Otherwise, it returns an error.


       2.4.4 mos_rsrc_protectlvl_get()

	  Returns the protection level for communications made to a resource.
	  This is not to be confused with end-to-end protection levels.

	  2.4.4.1 mos_rsrc_protectlvl_get() Synopsis

	     void
	     mos_rsrc_protectlvl_get(
			  [in]      mos_handle_t        resource_handle,
			  [out]     unsigned32 *        protect_level,
			  [out]     error_status_t *    status
	     );

	      where
		resource_handle:
		    A context handle to the attached resource.

		protect_level:
		    Specifies how much of the information in messages
		    exchanged by principals is encrypted. Refer to
		    Section 2.2 for the list of valid protection level
		    constants for authenticated communications from
		    sender to attached resource.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.



       2.4.5 mos_rsrc_protectlvl_set()

	  Sets and registers the protection level for communications
	  made to a resource.
	  This is not to be confused with end-to-end protection levels.

	  2.4.5.1 mos_rsrc_protectlvl_set() Synopsis

	     void
	     mos_rsrc_protectlvl_set(
			  [in]      unsigned32          protect_level,
			  [in/out]  mos_handle_t        resource_handle,
			  [out]     error_status_t *    status
	     );

	      where
		protect_level:
		    Specifies how much of the information in messages
		    exchanged by principals is encrypted. Refer to
		    Section 2.2 for the list of valid protection level
		    constants for authenticated communications from
		    sender to attached resource.

		resource_handle:
		    A context handle to the attached resource.

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	  2.4.5.2 mos_rsrc_protectlvl_set() Internal Description

	    In the message queuing model, authentication and authorization
	    information bewteen clients and Q-mgrs are set implicitly due
	    to ACLs on queues.
	    "rpc_binding_set_auth_info()" is invoked with the following
	    defaults:
		     authentication service = rpc_c_authn_dce_secret,
		     authorization service  = rpc_c_authz_dce,
		     protection level       = rpc_c_protect_level_default

	    This API registers the "protection level" with the resource
	    and sets the new "protection level" with the binding handle.


    2.5 Marshalling

	Marshalling is achieved on a per message basis. If an application
	requires multiple data types for messages, each data type and
	its conversion function must be registered before performing any
	send and/or retrieve operations. An application-specific data type
	on a message should be set before a send operation. On the
	retrieving end, the data type can be obtained.

	Note that the registered data type and its conversion function is
	maintained by MOS in order to properly encode/decode messages
	sent/retrieved with a particular data type message attribute.

	There are two well-known data types within MOS. The NIL UUID,
	which is the default data type, refers to an array of bytes as
	defined by mos_datatype_bytearray_t and the "mos_datatype_ack" UUID
	refers to an ACK message as defined by mos_datatype_ack_t.
	Note that MOS provides no conversion for the default data type,
	a NIL UUID. Refer to Section 2.6 for more detail.


	2.5.1 Registering Data Types with a Conversion Function

	    Register and unregister one application-specific data type
	    and its associated conversion function with MOS to
	    encode/decode the data.

	    void
	    mos_api_datatype_register(
			    [in] uuid_t *                    datatype_id,
			    [in] mos_msg_attr_convfn_t       conv_fn,
			    [out] error_status_t *           status
	    );

	    void
	    mos_api_datatype_unregister(
			    [in] uuid_t *                    datatype_id,
			    [out] error_status_t *           status
	    );

	    where
		 datatype_id:
		    Application-specific data type represented as a UUID.

		 conv_fn:
		    Conversion function to encode/decode a message with
		    the specified data type.

		    /*
		     * Conversion function for data types
		     */
		    typedef void (*mos_msg_attr_convfn_t)(
		       [in]         handle_t               handle,
		       [in,out]     void *                 data,
		       [in,out]     error_status_t *       status
		    );


		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.5.2 Data Types on Messages

	    Obtain and modify the application-specific data type from
	    the message attribute structure. The message data type is a
	    read/write attribute.

	    void
	    mos_msg_attr_datatype_get(
			    [in]  mos_msg_attr_t           msg_attributes,
			    [out] uuid_t *                 datatype_id,
			    [out] error_status_t *         status
	    );

	    void
	    mos_msg_attr_datatype_set(
			    [in] uuid_t *                  datatype_id,
			    [in,out] mos_msg_attr_t        msg_attributes,
			    [out]    error_status_t *      status
	    );

	    where
	       datatype_id:
		   Application-specific data type represented as a UUID.
		   This data type must be registered via
		   mos_api_datatype_register().

	       msg_attributes:
		   Opaque pointer to message attributes structure obtained
		   via mos_msg_attr_alloc() or mos_msg_attr_peek().

		   typedef struct mos_mattr_s_t *     mos_msg_attr_t;

	       status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.5.3 Decoding Data Types

	    Decodes the message buffer returned by mos_msg_dequeue() or
	    mos_msg_peek().

	    This API invokes the registered conversion function associated
	    with the specified data type in order to decode the "msg_buffer".
	    Note that the datatype is obtained from the message attributes
	    returned by mos_msg_dequeue() or mos_msg_peek().

	    MOS provides no conversion for the default data type, a NIL UUID,
	    which refers to an array of bytes.

	    void
	    mos_msg_datatype_decode(
			    [in]     uuid_t *               datatype_id,
			    [in]     mos_msg_buf_t          msg_buffer,
			    [out]    void *                 decoded_msg_buffer,
			    [out]    error_status_t *       status
	    );

	    where
	       datatype_id:
		   Application-specific data type represented as a UUID.

	       msg_buffer:
		   Opaque pointer to message buffer structure obtained
		   via mos_msg_dequeue() or mos_msg_peek().

		   typedef struct mos_datatype_bytearray_s_t *mos_msg_buf_t;

	       decoded_msg_buffer:
		   Opaque pointer to the application-specific message
		   structure. It is the responsiblity of the caller to
		   provide an area to store the decoded application-specific
		   message data. In addition, it is the responsibility of
		   the caller to release any allocated portions of the
		   application-specific message.

	       status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.5.4 Releasing memory for the Default Data Type, NIL UUID

	    Releases memory used for the message buffer.
	    It is the responsibility of the caller to release the memory
	    if allocated by mos_msg_dequeue() or mos_msg_peek().

	    void
	    mos_msg_buf_free(
			    [in,out] mos_msg_buf_t *          msg_buffer,
			    [out]    error_status_t *         status
	    );

	    where
	       msg_buffer:
		   Opaque pointer to message buffer structure obtained
		   via mos_msg_dequeue() or mos_msg_peek(). If the
		   operation succeeds, this parameter returns the
		   value NULL.

		   typedef struct mos_datatype_bytearray_s_t *mos_msg_buf_t;

	       status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


    2.6 Message Attribute Utilities

       MOS-API provides many message attributes for applications to chose
       from. Application designers need to understand the message attributes
       that they may wish to use since their choices may affect performance.
       Another caveat is that once a message and its corresponding message
       attributes are sent, neither the message nor its message attributes
       can be modified. Each message attribute is fully described in the
       specified section numbers under column REFERENCE.

       An application designer is allowed to modify the following
       attributes on a message:

	   ATTRIBUTE           API ACCESS   DEFAULT VALUE              REFERENCE
	   ---------------------------------------------------------------------
	    message type        RDWR        mos_c_msg_attr_msgtype_data  2.6.6
	    priority            RDWR        mos_c_msg_attr_dflt_priority 2.6.7
	    time-to-live        RDWR        mos_c_msg_attr_dflt_ttl      2.6.8
	    time-to-receive     RDWR        mos_c_msg_attr_dflt_ttr      2.6.9
	    persistence         RDWR        mos_c_msg_attr_volatile      2.6.10
	    notice options      RDWR        mos_c_msg_attr_notice_none   2.6.11
	    notice destination  RDWR        NULL                         2.6.11
	    notice sec name     RDWR        NULL                         2.6.11
	    data type           RDWR        NIL-UUID                     2.5.2
	    sender's protectlvl RDWR        mos_c_protect_level_default  2.4.5

       The MOS-API implicitly places the following attributes on a message:

	   ATTRIBUTE           API ACCESS   DEFAULT VALUE  REFERENCE
	   ----------------------------------------------------------
	    message ID          RDONLY      NIL-UUID        2.6.4

       The message ID is generated by the send API operations.
       In addition, the mos_mcast() API generates the same message ID
       for a message to all members in a specified group. An application
       is not allowed to generate its own message IDs. Applications should
       use the "data type" message attribute to identify application-specific
       messages.

       Lastly, the queue manager places the following attributes on a message:

	   ATTRIBUTE           API ACCESS   DEFAULT VALUE  REFERENCE
	   ----------------------------------------------------------
	    sender's authn id   RDONLY      NULL            2.4.6
	    enqueue time_stamp  RDONLY      0               2.6.5

       The trusted queue manager places the initial sender's principal
       and group UUIDs for the sender's authentication identity. It is the
       responsibility of the recipient to perform authorization.
       The queue manager places an absolute time stamp on a message once
       it has been successfully enqueued. This time stamp is used
       internally by the Q-mgr to ensure when a message is allowed to be
       received(ttr) and message expiration(ttl). As a result, applications
       are allowed to view the time stamp.

       At message retrieval time, the trusted queue manager ensures that
       the stronger end-to-end protection level requested from both the
       sender and the recipient is satisfied. This validation ensures
       end-to-end security.

       The following sections describe allocating and deallocating the
       message attribute structure as well as obtaining and/or modifying
       each message attribute.

      The default data type is an array of bytes. It has a NIL UUID as a
      data type value. An application designer uses the following structure
      to send and receive an array of bytes. Note that there is no
      encoding/decoding performed by the messaging system.

	     /*
	      * Default data type: array of bytes
	      */
	     typedef struct mos_datatype_bytearray_s_t {
		unsigned32       size;
		[ptr,size_is(size)]
		byte *           data;
	     } mos_datatype_bytearray_t;


      The ACK/NAK data type, mos_datatype_ack, is used by the Q-mgr to
      send ACK/NAK messages once a notice is requested. An application
      designer uses the following structure to retrieve the ACK/NAK
      message. Note that encoding/decoding is performed automatically by
      the messaging system.

	     typedef struct {
		 uuid_t         msg_id;        /* msg_id in question */
		 unsigned32     notice_option; /* notice option requested */
		 error_status_t status;        /* status of notice */
	     } mos_datatype_ack_t;

	     /*
	      * Well-known ACK datatype UUID for mos_ack_convert().
	      *    e7daf4c6-bd70-11cf-87df-0800092474cc
	      * Agrees with ../idl/mos_ack.idl.
	      */
	     uuid_t mos_datatype_ack = {
	       0xe7daf4c6, 0xbd70, 0x11cf, 0x87, 0xdf,
	       {0x08, 0x00, 0x09, 0x24, 0x74, 0xcc}
	     };

/* ______________________________________________________________________
 * Copyright (c) 1996 The Open Group, Inc., Cambridge, MA USA
 * All rights reserved.
 * ______________________________________________________________________
 *
 *	M O S _ A C K . I D L
 *
 * Conversion functions, for serializing data (to be written to backing
 * stores and the ack structure).
 * ______________________________________________________________________
 *
 * $Log: mos_api.txt,v $
Revision 1.4  1996/12/03  14:39:04  salamone
mos_rsrc_name_get() names not returned if NULL

Revision 1.3  96/12/03  16:24:20  16:24:20  bowe (John Bowe)
Added discussion of mos_rsrc_name_get().

Revision 1.2  1996/11/26  21:13:18  bowe
Removed extraneous trailing blanks.

Revision 1.1  1996/11/21  13:09:54  salamone
Reviewed and approved internally

 * $EndLog$
 * ______________________________________________________________________
 */

[
    uuid(e7daf4c6-bd70-11cf-87df-0800092474cc),
    pointer_default(ptr),
    version(1.0)
]

interface mos_ack
{
    import "mos_base.idl";

    /* ________________________________________________________ */

    void mos_ack_convert(
	[in]		handle_t	h,
	[in,out]	mos_datatype_ack_t	*ack,
	[in,out]	error_status_t	*st
    );

    /* ________________________________________________________ */
}

/* ______________________________________________________________________
 * Copyright (c) 1996 The Open Group, Inc., Cambridge, MA USA
 * All rights reserved.
 * ______________________________________________________________________
 *
 *	M O S _ A C K . A C F
 * ______________________________________________________________________
 * $Log: mos_api.txt,v $
Revision 1.4  1996/12/03  14:39:04  salamone
mos_rsrc_name_get() names not returned if NULL

Revision 1.3  96/12/03  16:24:20  16:24:20  bowe (John Bowe)
Added discussion of mos_rsrc_name_get().

Revision 1.2  1996/11/26  21:13:18  bowe
Removed extraneous trailing blanks.

Revision 1.1  1996/11/21  13:09:54  salamone
Reviewed and approved internally

 * $EndLog$
 * ______________________________________________________________________
 */

interface mos_ack
{
    [encode,decode]     mos_ack_convert([comm_status] st);
}


	2.6.1 mos_msg_attr_alloc()

	     Allocates space for the attributes to be sent with each
	     message and returns a buffer with all defaults set.

	     It is the responsibilty of the caller to release memory
	     via mos_msg_attr_free().

	     void
	     mos_msg_attr_alloc(
			    [out]  mos_msg_attr_t *     msg_attributes,
			    [out]  error_status_t *     status
	     );

	     where
		 msg_attributes:
		    Opaque pointer to default message attributes structure.
		    Use the other mos_msg_attr_X_set() APIs to modify any
		    attributes.

		    typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


       2.6.2 mos_msg_attr_peek()

	   Returns an opaque pointer to the message attributes on an
	   existing message in the specified queue. If no selection
	   criteria is specified, then the first message's attributes
	   in the queue is returned.
	   This API applies only in a message queuing model.

	   It is the responsibilty of the caller to release memory
	   via mos_msg_attr_free().

	   2.6.2.1 mos_msg_attr_peek() Synopsis

	     void
	     mos_msg_attr_peek(
			  [in]  mos_handle_t            resource_handle,
			  [in]  unsigned32              flags,
			  [in]  mos_msg_selfilter_t     msg_selection_filter,
			  [out] mos_msg_attr_t *        msg_attributes,
			  [out] error_status_t *        status
	     );

	     where
		resource_handle:
		    A context handle to a resource.

		flags:
		    Indicates the message retrieval mode. Only one option
		    is allowed to be specified.
		    The default is mos_c_deqmode_nowait.

		    /*
		     * mos_c_deqmode_nowait applies only in the message
		     * queuing model.
		     * If mos_c_deqmode_nowait, the API will return
		     * immediately with an error if the queue is empty or
		     * if the queue does not have any messages that meet the
		     * selection criteria.
		     */
		    #define mos_c_deqmode_nowait     0x00000000
		    /*
		     * mos_c_deqmode_wait applies only in the message
		     * queuing model.
		     * If mos_c_deqmode_wait, the API will wait until the
		     * specified queue is non-empty and the message meets
		     * the selection criteria.
		     */
		    #define mos_c_deqmode_wait       0x00000001

		msg_selection_filter:
		    Opaque pointer to the selection filter structure.
		    Use the mos_msg_selfilter_alloc(), mos_msg_selfilter_free(),
		    and mos_msg_selmask_add() APIs to allocate, deallocate and
		    define one or more selection criteria. A message is
		    successfully retrieved following the rules of the logical
		    AND operator among all specified criteria.

		    A NULL value indicates no selection criteria and the
		    message's attributes at the top of the specified queue
		    is returned.

		     /*
		      * Opaque pointer to selection filter structure
		      */
		     typedef struct mos_mask_list_s_t * mos_msg_selfilter_t;

		msg_attributes:
		    Use the utilities to view the message attributes.
		    It is the caller's responsibility to release the
		    memory allocated for the message attributes buffer
		    via mos_msg_attr_free().

		    typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	   2.6.2.2 mos_msg_attr_peek() Internal Description

		A message's "msg_attributes" and the status are retrieved
		and then returned to the calling application.


	2.6.3 mos_msg_attr_free()

	     Releases memory used for attributes on a message.
	     It is the responsibility of the caller to
	     release the memory if allocated by mos_msg_attr_alloc()
	     or mos_msg_attr_peek().

	    void
	    mos_msg_attr_free(
			    [in,out]  mos_msg_attr_t *      msg_attributes,
			    [out] error_status_t *          status
	    );

	     where
		 msg_attributes:
		    Opaque pointer to message attributes structure to
		    be freed.
		    If the operation succeeds, this parameter
		    returns the value NULL.

		    typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.6.4 Message ID

	    Obtain the message ID from the message attributes structure.
	    Message ID is a read-only attribute.

	    void
	    mos_msg_attr_msgid_get(
			    [in]  mos_msg_attr_t            msg_attributes,
			    [out] uuid_t *                  msg_id,
			    [out] error_status_t *          status
	    );

	    where
		msg_id:
		  Unique message ID generated by the send API operations.

		msg_attributes:
		   Opaque pointer to message attributes structure obtained
		   via mos_msg_attr_alloc() or mos_msg_attr_peek().

		   typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.6.5 Message Enqueue Time Stamp

	    Obtain the message enqueue time stamp in absolute time from
	    the message attributes structure.
	    Message enqueue time stamp is a read-only attribute.

	    void
	    mos_msg_attr_enqtime_get(
			    [in]  mos_msg_attr_t           msg_attributes,
			    [out] utc_t *                  msg_enq_time,
			    [out] error_status_t *         status
	    );

	    where
		msg_enq_time:
		   Indicates when a message was enqueued successfully
		   by the messaging system.
		   Specified in absolute time only.

		msg_attributes:
		   Opaque pointer to message attributes structure obtained
		   via mos_msg_attr_alloc() or mos_msg_attr_peek().

		   typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.6.6 Message Type

	    Obtain and modify the message type from the message attributes
	    structure.

	    void
	    mos_msg_attr_msgtype_get(
			    [in]  mos_msg_attr_t            msg_attributes,
			    [out] mos_msg_attr_msgtype_t *  msg_type,
			    [out] error_status_t *          status
	    );

	    void
	    mos_msg_attr_msgtype_set(
			    [in]     mos_msg_attr_msgtype_t  msg_type,
			    [in,out] mos_msg_attr_t          msg_attributes,
			    [out]    error_status_t *        status
	    );

	    where
		msg_type:
		   Describes the message type for messaging system purposes.
		   The default is mos_c_msg_attr_msgtype_data.

		   A message type of "mos_c_msg_attr_msgtype_notice" is
		   only sent by a queue manager.

		   typedef enum {
		       mos_c_msg_attr_msgtype_data,     /* app-specific data */
		       mos_c_msg_attr_msgtype_notice    /* Q-mgr notice */
		   } mos_msg_attr_msgtype_t;

		msg_attributes:
		   Opaque pointer to message attributes structure obtained
		   via mos_msg_attr_alloc() or mos_msg_attr_peek().

		   typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.6.7 Message Priority

	    Obtain and modify the priority from the message attributes
	    structure.

	    void
	    mos_msg_attr_priority_get(
			    [in]     mos_msg_attr_t       msg_attributes,
			    [out]    unsigned32 *         priority,
			    [out]    error_status_t *     status
	    );

	    void
	    mos_msg_attr_priority_set(
			    [in]     unsigned32           priority,
			    [in,out] mos_msg_attr_t       msg_attributes,
			    [out]    error_status_t *     status
	    );

	     where
		 priority:
		    A number from 0 thru (2 to the power of 32-1),
		    where 0 indicates highest priority.
		    The default is mos_c_msg_attr_dflt_priority.

		    #define mos_c_msg_attr_dflt_priority      100

		 msg_attributes:
		    Opaque pointer to message attributes structure
		    obtained via mos_msg_attr_alloc() or mos_msg_attr_peek().

		    typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.6.8 Message Expiration (Time To Live)

	    Obtain and modify the ttl in absolute time from the message
	    attributes structure.

	    void
	    mos_msg_attr_ttl_get(
			    [in]  mos_msg_attr_t           msg_attributes,
			    [out] utc_t *                  ttl,
			    [out] error_status_t *         status
	    );

	    void
	    mos_msg_attr_ttl_set(
			    [in] utc_t *                   ttl,
			    [in,out] mos_msg_attr_t        msg_attributes,
			    [out] error_status_t *         status
	    );

	    where
		ttl:
		   Indicates the lifetime of the message if not retrieved.
		   Once a message has expired, its queue manager is free
		   to implicitly delete it at any time thereafter.
		   Specified in absolute time only.

		   The default message ttl is 24 hours.
		   A message ttl of NULL indicates that a message remains
		   indefinitely until explicitly dequeued via
		   mos_msg_dequeue() or mos_msg_delete().

		   /*
		    * Default ttl: msg lives for 24 hours if not retrieved
		    */
		   #define mos_c_msg_attr_dflt_ttl     24

		 msg_attributes:
		    Opaque pointer to message attributes structure
		    obtained via mos_msg_attr_alloc() or mos_msg_attr_peek().

		    typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

		    mos_s_msg_attr_inv           Invalid message attribute
						 structure.

		    mos_s_msg_attr_ttl_null      On mos_msg_attr_ttl_get(),
						 ttl is NULL.

	2.6.9 Message Time To Receive

	    Obtain and modify the ttr in absolute time from the message
	    attributes structure.

	    void
	    mos_msg_attr_ttr_get(
			    [in]     mos_msg_attr_t        msg_attributes,
			    [out]    utc_t *               ttr,
			    [out]    error_status_t *      status
	    );

	    void
	    mos_msg_attr_ttr_set(
			    [in] utc_t *                   ttr,
			    [in,out] mos_msg_attr_t        msg_attributes,
			    [out]    error_status_t *      status
	    );

	    where
		 ttr:
		    Indicates when a message is allowed to be retrieved.
		    Specified in absolute time only.

		    The default message ttr is NULL. A message ttr of
		    NULL indicates that a message is allowed to be
		    retrieved now.

		    /*
		     * Default ttr: msg allowed to be retrieved now
		     */
		    #define mos_c_msg_attr_dflt_ttr      0

		 msg_attributes:
		    Opaque pointer to message attributes structure
		    obtained via mos_msg_attr_alloc() or mos_msg_attr_peek().

		    typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

		    mos_s_msg_attr_inv           Invalid message attribute
						 structure.

		    mos_s_msg_attr_ttr_null      On mos_msg_attr_ttr_get(),
						 ttr is NULL.

	2.6.10 Message Persistence

	    Obtain and modify the message persistence from the message
	    attributes structure.

	    void
	    mos_msg_attr_persistence_get(
			    [in]  mos_msg_attr_t               msg_attributes,
			    [out] mos_msg_attr_persistence_t * persistence,
			    [out] error_status_t *             status
	    );

	    void
	    mos_msg_attr_persistence_set(
			    [in]     mos_msg_attr_persistence_t persistence,
			    [in,out] mos_msg_attr_t             msg_attributes,
			    [out]    error_status_t *           status
	    );

	    where
		 persistence:
		      Indicates whether the message is stored in memory or
		      on disk. The default message persistence is
		      mos_c_msg_attr_volatile.

		      typedef enum {
			 mos_c_msg_attr_volatile,    /* msg stored in memory */
			 mos_c_msg_attr_persistent   /* msg stored on disk   */
		      } mos_msg_attr_persistence_t;

		      Note that there is a persistence attribute on messages
		      as well as queues.  Refer to Section 2.8.12 for details
		      on message storage.

		 msg_attributes:
		    Opaque pointer to message attributes structure
		    obtained via mos_msg_attr_alloc() or mos_msg_attr_peek().

		    typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.6.11 Message Notice Options and Destination

	    Obtain and modify notice options/destination from the
	    message attributes structure.

	    When setting the notice information, mos_msg_attr_notice_set()
	    verifies that the "notice_destination" specified exists. In
	    addition, the API determines if a handle was already obtained
	    to this "notice_destination". If not and the caller has requested
	    a handle, then the API performs a mos_rsrc_attach() to this
	    "notice_destination".  Lastly, the API implicitly registers
	    the ACK datatype, mos_datatype_ack, along with its conversion
	    function if it is not already registered.

	    void
	    mos_msg_attr_notice_get(
			    [in]  mos_msg_attr_t      msg_attributes,
			    [out] unsigned32 *        notice_flags,
			    [out] mos_rsrc_name_t     notice_destination,
			    [out] sec_rgy_name_t      notice_security_name,
			    [out] error_status_t *    status
	    );

	    void
	    mos_msg_attr_notice_set(
			    [in]     unsigned32          notice_flags,
			    [in]     mos_rsrc_name_t     notice_destination,
			    [in]     sec_rgy_name_t      notice_security_name,
			    [in,out] mos_msg_attr_t      msg_attributes,
			    [out]    mos_handle_t *      resource_handle,
			    [out]    error_status_t *    status
	    );

	   where
		 notice_flags:
		     Informs messaging system when to notify the sender
		     of message delivery activity. For example, a sender
		     may only want to be notified if any of his messages
		     expired but not on every dequeue operation. One
		     exception may be that an administrator forces
		     a queue deletion on a non-empty queue.
		     The default is mos_c_msg_attr_notice_none.

		     In the Message Passing(MP) model, the following options
		     are allowed:
		       mos_c_msg_attr_notice_none
		       mos_c_msg_attr_notice_mp_ack

		     In the Message Queuing(MQ) model, the following options
		     are allowed:
		       mos_c_msg_attr_notice_none
		       mos_c_msg_attr_notice_enqueue
		       mos_c_msg_attr_notice_dequeue
		     A combination of several notice options is allowed within
		     the MQ model.

	    #define mos_c_msg_attr_notice_none       0x00000000 /* No notice  */
	    #define mos_c_msg_attr_notice_enqueue    0x00000001 /* Msg Enqued */
	    #define mos_c_msg_attr_notice_dequeue    0x00000002 /* Msg Dequed */
	    #define mos_c_msg_attr_notice_mp_ack     0x00000004
							/* Msg ACK in MP only */

		 notice_destination:
		    This is the notice destination location for
		    a notice sent by the messaging system. In the MQ
		    model, the notice destination is a queue name managed
		    by the same queue manager or a different one. In the MP
		    model, this may be a destination peer application.

		notice_security_name:
		    Specifies either a principal name or the security group
		    name where the named resource is a member.

		    In a message queuing model, only a security group name
		    is allowed. Since a "notice_destination" may be to a
		    different queue manager, the Q-mgr sending the notice
		    message to the "notice_destination" can verify the
		    security group.

		    In a message passing model, a sender knows what recipient
		    to trust and only has to specify a principal name, if
		    desired.

		    Specify NULL if same Q-mgr receives notice messages.
		    Otherwise, NULL may be specified, but caller trusts CDS.
		    Not recommended.

		 msg_attributes:
		    Opaque pointer to message attributes structure
		    obtained via mos_msg_attr_alloc() or mos_msg_attr_peek().

		    typedef struct mos_mattr_s_t *     mos_msg_attr_t;

		 resource_handle:
		    A context handle to the attached resource.

		    If NULL is specified, the resource handle is not
		    returned. Otherwise, it is the caller's responsibility
		    to release the resource and any allocated memory
		    within MOS via mos_rsrc_detach(). For example, the
		    caller may already have a resource handle when the
		    resource was created.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.



    2.7 Message Selection Filter Utilities

	This group of interfaces allow manipulation of selection criteria
	on messages to be retrieved.

	2.7.1 mos_msg_selfilter_alloc()

	    Allocates space for the selection filter.
	    The selection filter is comprised of one or more masks that
	    follow the rules of the logical AND operator among all
	    specified criteria when retrieving messages.

	    void
	    mos_msg_selfilter_alloc(
			  [out]  mos_msg_selfilter_t *   selection_filter,
			  [out]  error_status_t *        status
	    );

	     where
		 selection_filter:
		     Opaque pointer to selection filter large enough
		     to hold the specified number of mask specifications.

		     /*
		      * Pointer to selection filter structure
		      */
		     typedef struct mos_mask_list_s_t * mos_msg_selfilter_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.7.2 mos_msg_selfilter_free()

	    Releases memory used for the selection filter when retrieving
	    messages. It is the responsibility of the caller to release
	    the memory if allocated by mos_msg_selfilter_alloc().

	    void
	    mos_msg_selfilter_free(
			    [in,out]  mos_msg_selfilter_t * selection_filter,
			    [out] error_status_t *          status
	    );

	     where
		 selection_filter:
		     Pointer to selection filter buffer large enough
		     to hold the specified number of mask specifications.
		     If the operation is successful, this parameter
		     returns the value NULL.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


       2.7.3 mos_msg_selmask_add()

	    Adds one mask to the list of masks in the selection filter.
	    A mask is comprised of a selection criteria type, a selection
	    criteria value, and the relational operator to be performed.

	    Here's an example defining two masks to select on a range
	    of priorities:
		- message attribute type: mos_c_mask_type_priority
		- value:                  5
		- operation:              mos_c_mask_op_eq_less_than

		- message attribute type: mos_c_mask_type_priority
		- value:                  0
		- operation:              mos_c_mask_op_eq_greater_than

	    void
	    mos_msg_selmask_add(
			    [in]      mos_msg_selmask_type_t   mask_type,
			    [in]      mos_msg_selmask_value_t  mask_value,
			    [in]      mos_msg_selmask_op_t     mask_op,
			    [in,out]  mos_msg_selfilter_t      selection_filter,
			    [out]     error_status_t *         status
	    );

	     where
		 mask_type:
		     Type of selection criteria for specified mask.

		     /*
		      * Valid Mask types
		      */
		     typedef enum {
			mos_c_mask_type_msgid,
			mos_c_mask_type_msgtype,
			mos_c_mask_type_priority,
			mos_c_mask_type_datatype,
			mos_c_mask_type_protectlvl,  /* end-to-end protection */
			mos_c_mask_type_sender_prin, /* sender's principal */
			mos_c_mask_type_ttr          /* time-to-receive msgs */
		     } mos_msg_selmask_type_t;


		 mask_value:
		     Opaque pointer to the value of selection criteria
		     for specified mask.

		     mos_c_mask_type_msgid and mos_c_mask_type_datatype
		     are UUIDs. API expects (uuid_t *) for mask_value.
		     API expects the following for mask_op:
			"mos_c_mask_op_equal"
			"mos_c_mask_op_not_equal"

		     mos_c_mask_type_msgtype is an unsigned32.
		     API expects (unsigned32 *) for mask_value.
		     API expects the following for mask_op:
			"mos_c_mask_op_equal"
			"mos_c_mask_op_not_equal"

		     mos_c_mask_type_priority is an unsigned32.
		     API expects (unsigned32 *) for mask_value.
		     API expects the following for mask_op:
			"mos_c_mask_op_equal"
			"mos_c_mask_op_not_equal"
			"mos_c_mask_op_less_than"
			"mos_c_mask_op_eq_less_than"
			"mos_c_mask_op_greater_than"
			"mos_c_mask_op_eq_greater_than"

		     mos_c_mask_type_protectlvl is an unsigned32.
		     API expects (unsigned32 *) for mask_value.
		     API expects the following for mask_op:
			"mos_c_mask_op_equal"
			"mos_c_mask_op_eq_greater_than"

		     mos_c_mask_type_sender_prin is a principal name.
		     API expects (unsigned_char_t *) for mask_value. Note that
		     the API finds the UUID for the sender's principal name.
		     API expects the following for mask_op:
			"mos_c_mask_op_equal"
			"mos_c_mask_op_not_equal"

		     mos_c_mask_type_ttr takes no mask value or operation.
		     API expects (void *)NULL for mask_value.
		     API expects the following for mask_op:
			"mos_c_mask_op_none"
		     The caller must have the proper access rights to
		     request these ttr messages.

		     /*
		      * Opaque pointer to the mask value
		      */
		     typedef void *     mos_msg_selmask_value_t;

		 mask_op:
		     Relational operator to be performed on the "mask_type"
		     using the "mask_value".

		     /*
		      * Valid Mask operations
		      */
		     typedef enum {
			mos_c_mask_op_none,                /* No operation */
			mos_c_mask_op_equal,               /* =  */
			mos_c_mask_op_not_equal,           /* != */
			mos_c_mask_op_less_than,           /* <  */
			mos_c_mask_op_eq_less_than,        /* <= */
			mos_c_mask_op_greater_than,        /* >  */
			mos_c_mask_op_eq_greater_than      /* >= */
		     } mos_msg_selmask_op_t;

		 selection_filter:
		     Opaque pointer to selection filter structure allocated
		     via mos_msg_selfilter_alloc().

		     /*
		      * Opaque pointer to selection filter structure
		      */
		     typedef struct mos_mask_list_s_t * mos_msg_selfilter_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


    2.8 Queue Attribute Utilities

       MOS-API provides many queue attributes for applications to choose
       from. Unlike message attributes, queue attributes may be modified
       at any time. Each queue attribute is fully described in the specified
       section numbers under column REFERENCE.

       An application designer is allowed to modify the following
       attributes on a queue:

	   ATTRIBUTE         API ACCESS  DEFAULT VALUE                 REFERENCE
	   ---------------------------------------------------------------------
	    que name            RDWR     NULL                           2.8.9
	    que alias           RDWR     NULL                           2.8.9
	    annotation          RDWR     NULL                           2.8.10
	    que max size        RDWR     mos_c_que_attr_dflt_quemaxsize 2.8.11
	    msg max size        RDWR     mos_c_que_attr_dflt_msgmaxsize 2.8.12
	    persistence         RDWR     mos_c_que_attr_msgpersistence  2.8.13
	    que idle timeout    RDWR     mos_c_que_attr_dflt_idletime   2.8.14
	    allow_enqueue       RDWR     TRUE                           2.8.15
	    allow_dequeue       RDWR     TRUE                           2.8.16

       Lastly, the queue manager places the following attributes on a queue:

	   ATTRIBUTE          API ACCESS  DEFAULT VALUE                REFERENCE
	   ---------------------------------------------------------------------
	    que ID              RDONLY    NIL-UUID                      2.8.5
	    que current size    RDONLY    0                             2.8.6
	    creation timestamp  RDONLY    0                             2.8.7
	    last activity timestamp
				RDONLY    0                             2.8.8
	    que name            RDWR      generated if not specified    2.8.9

       At queue creation time, the queue manager generates a queue ID,
       a queue name if not specified, and the creation time stamp. As
       messages are enqueued and dequeued, the queue manager maintains
       the current queue size. The queue manager places an absolute time
       stamp on a queue once it has been successfully created and keeps
       the last activity timestamp up-to-date.

       The following sections describe allocating and deallocating the
       queue attribute structure as well as obtaining and/or modifying
       each queue attribute. If any queue attributes are modified on an
       existing queue, the modifications must be committed to the queue
       manager in order to take effect.


	2.8.1 mos_que_attr_alloc()

	    Allocates space for the attributes to be sent when creating
	    a queue and returns an opaque pointer to the queue attribute
	    structure with all defaults set.

	    It is the responsibility of the caller to release the memory
	    via mos_que_attr_free().

	    void
	    mos_que_attr_alloc(
			    [out]  mos_que_attr_t *     que_attributes,
			    [out]  error_status_t *     status
	    );

	     where
		 que_attributes:
		    Opaque pointer to default queue attributes structure.
		    Use the other mos_que_attr_X_set() APIs to modify any
		    attributes.

		       typedef struct mos_qattr_s_t * mos_que_attr_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.



       2.8.2 mos_que_attr_peek()

	   Returns an opaque pointer to the queue attributes on an
	   existing specified queue.

	   Use the mos_que_attr_X_get() APIs to view attributes.
	   Use the mos_que_attr_X_set() APIs to modify attributes
	   and mos_que_attr_commit() to commit modifications.

	   It is the responsibility of the caller to release the memory
	   via mos_que_attr_free().

	   2.8.2.1 mos_que_attr_peek() Synopsis

	     void
	     mos_que_attr_peek(
			       [in] mos_handle_t             resource_handle,
			       [out] mos_que_attr_t *        que_attributes,
			       [out] error_status_t *        status
	     );

	     where
		 resource_handle:
		    A context handle to the resource obtained via
		    mos_rsrc_attach().

		 que_attributes:
		    Opaque pointer to queue attributes on existing
		    specified queue.

		    typedef struct mos_qattr_s_t * mos_que_attr_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.8.3 mos_que_attr_free()

	    Releases memory used for attributes on a queue.
	    It is the responsibility of the caller to release the memory
	    if allocated by mos_que_attr_alloc() or mos_que_attr_peek().

	    void
	    mos_que_attr_free(
			    [in,out]  mos_que_attr_t *      que_attributes,
			    [out] error_status_t *          status
	    );

	    where
		 que_attributes:
		    Opaque pointer to queue attribute structure to
		    be freed.
		    If the operation is successful, this parameter
		    returns the value NULL.

		    typedef struct mos_qattr_s_t * mos_que_attr_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


       2.8.4 mos_que_attr_commit()

	   Commit queue attribute modifications on an existing queue.

	   2.8.4.1 mos_que_attr_commit() Synopsis

	     void
	     mos_que_attr_commit(
				 [in] mos_handle_t         resource_handle,
				 [in] mos_que_attr_t       queue_attributes,
				 [out] error_status_t *    status
	     );

	     where
		 resource_handle:
		    A context handle to the resource obtained via
		    mos_que_mgmt_create() or mos_rsrc_attach().

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		 que_attributes:
		    Opaque pointer to queue attributes to be modified
		    and commited to the specified queue manager.

		    typedef struct mos_qattr_s_t *     mos_que_attr_t;

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.8.5 Queue ID

	    Obtain the queue ID from the queue attributes structure.
	    Queue ID is a read-only attribute.

	    void
	    mos_que_attr_queid_get(
			    [in]  mos_que_attr_t            que_attributes,
			    [out] uuid_t *                  que_id,
			    [out] error_status_t *          status
	    );

	    where
	       que_id:
		   Unique queue ID generated by a queue manager.

	       que_attributes:
		  Opaque pointer to queue attributes structure obtained
		  via mos_que_attr_alloc() or mos_que_attr_peek().

		  typedef struct mos_qattr_s_t *     mos_que_attr_t;

	       status:
		  A pointer to the completion status. On successful
		  completion, the routine returns error_status_ok.
		  Otherwise, it returns an error.


	2.8.6 Queue Current Size

	    Obtain the current queue size from the queue
	    attributes structure.
	    Queue current size is a read-only attribute.

	    void
	    mos_que_attr_quecursize_get(
			    [in]  mos_que_attr_t            que_attributes,
			    [out] unsigned32 *              que_cur_size,
			    [out] error_status_t *          status
	    );

	    where
	       que_cur_size:
		  Indicates the current number of messages on the queue.

	       que_attributes:
		  Opaque pointer to the queue attributes structure obtained
		  via mos_que_attr_alloc() or mos_que_attr_peek().

		    typedef struct mos_qattr_s_t *     mos_que_attr_t;

	       status:
		  A pointer to the completion status. On successful
		  completion, the routine returns error_status_ok.
		  Otherwise, it returns an error.


	2.8.7 Queue Creation Time Stamp

	    Obtain the queue creation time stamp in absolute time from
	    the queue attributes structure.
	    Queue creation time stamp is a read-only attribute.

	    void
	    mos_que_attr_createtime_get(
			    [in]  mos_que_attr_t           que_attributes,
			    [out] utc_t *                  que_create_time,
			    [out] error_status_t *         status
	    );

	    where
	       que_create_time:
		  Indicates the time and date in absolute time when
		  the queue was created.

	       que_attributes:
		  Opaque pointer to the queue attributes structure obtained
		  via mos_que_attr_alloc() or mos_que_attr_peek().

		    typedef struct mos_qattr_s_t *     mos_que_attr_t;

	       status:
		  A pointer to the completion status. On successful
		  completion, the routine returns error_status_ok.
		  Otherwise, it returns an error.


	2.8.8 Queue Last Activity Time Stamp

	    Obtain the queue last activity time stamp from the queue
	    attributes structure. Queue last activity time stamp is a
	    read-only attribute.

	    void
	    mos_que_attr_activetime_get(
			    [in]  mos_que_attr_t           que_attributes,
			    [out] utc_t *                  que_active_time,
			    [out] error_status_t *         status
	    );

	    where
	       que_active_time:
		  Indicates the time and date in absolute time that the
		  last activity was performed on any messages within a
		  queue. Activities include peeking, enqueuing, and
		  dequeuing messages on a queue. It does not include
		  peeking and changing queue attributes.

	       que_attributes:
		  Opaque pointer to the queue attributes structure obtained
		  via mos_que_attr_alloc() or mos_que_attr_peek().

		    typedef struct mos_qattr_s_t *     mos_que_attr_t;

	       status:
		  A pointer to the completion status. On successful
		  completion, the routine returns error_status_ok.
		  Otherwise, it returns an error.


       2.8.9 Queue Name and Aliases

	  Obtain and modify queue aliases from the list of queue aliases
	  from the queue attributes structure.

	  Remember that all queues are treated as junction names from its
	  respective Q-mgr name. Since named links can not point to junction
	  names, aliases to queues are read/write attributes on a queue.
	  MOS also supports aliases to Q-mgrs. Aliases to Q-mgrs are
	  allowed via named links; use the dcecp link command. It is the
	  responsibility of the caller to create/delete the named link to
	  a queue manager.

	  mos_que_attr_alias_list() returns a list of queue aliases
	  for the specified queue. The first entry in the list is the
	  queue name itself. To modify/rename/move the queue name, use
	  mos_que_mgmt_move().

	  mos_que_attr_alias_add() adds one queue alias to the list of
	  queue aliases in the queue attributes structure. If the link name
	  parameter is specified and a named link does not already exist,
	  a named link is implicitly created to the respective queue
	  manager. It does not create the queue itself. To create a queue,
	  use mos_que_mgmt_create().
	  When adding an alias, the queue manager verifies that the new
	  alias name is unique among all queue names and aliases managed
	  by the specified queue manager.

	  Note that the queue manager verifies that new queue aliases
	  are unique amongst all queue names during a mos_que_mgmt_create()
	  or mos_que_attr_commit() operation.

	  mos_que_attr_alias_remove() removes one queue alias from the
	  list of queue aliases in the queue attributes structure. If the
	  link name parameter is specified and a named link exists,
	  a named link is implicitly removed from the respective queue
	  manager. It does not delete the queue itself. To delete a queue,
	  use mos_que_mgmt_delete().

	  mos_que_attr_alias_reset() sets the queue alias list to NULL in the
	  queue attributes structure. Note that the queue name itself is not
	  reset, since internally the queue name is stored separately from the
	  queue alias list. Also named links or the queue itself are not
	  removed; use mos_que_attr_alias_remove() and mos_que_mgmt_delete()
	  respectively.

	  void
	  mos_que_attr_alias_list(
			    [in]  mos_que_attr_t            que_attributes,
			    [in]  unsigned32                space_avail,
			    [out] unsigned32 *              num_returned,
			    [out] mos_rsrc_name_t           que_alias_list[],
			    [out] unsigned32 *              num_left,
			    [out] error_status_t *          status
	  );

	  void
	  mos_que_attr_alias_add(
			    [in]  mos_rsrc_name_t           link_name,
			    [in]  mos_rsrc_name_t           que_alias_name,
			    [in,out]  mos_que_attr_t        que_attributes,
			    [out] error_status_t *          status
	  );

	  void
	  mos_que_attr_alias_remove(
			    [in]  mos_rsrc_name_t           link_name,
			    [in]  mos_rsrc_name_t           que_alias_name,
			    [in,out]  mos_que_attr_t        que_attributes,
			    [out] error_status_t *          status
	  );

	  void
	  mos_que_attr_alias_reset(
			    [in,out]  mos_que_attr_t        que_attributes,
			    [out] error_status_t *          status
	  );

	  where
	     link_name:
		Indicates that the name is a named link to the queue
		manager in question. If NULL, a named link is not
		implicitly created or deleted. Otherwise, it is.

	     que_alias_name:
		Provides a mechanism for an application to access a queue
		by one or more names.

		#define mos_rsrc_name_maxsize   1024 /* Including NULL */
		typedef char   mos_rsrc_name_t[mos_rsrc_name_maxsize];

	     que_attributes:
		Opaque pointer to the queue attributes structure obtained
		via mos_que_attr_alloc() or mos_que_attr_peek().

		typedef struct mos_qattr_s_t *     mos_que_attr_t;

	     status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	For mos_que_attr_alias_list() API:

	     space_avail:
		    Specifies the size of the "que_alias_list" array.
		    The caller is responsible for allocating the space
		    for "space_avail" alias names.

	     num_returned:
		    The number of queue aliases for a queue returned in
		    the "que_alias_list".

	     que_alias_list:
		    Array of queue aliases returned.
		    The size of the array is determined by "space_avail"
		    and the length by "num_returned".

	     num_left:
		    Number of queue aliases that were found but could not
		    be returned because of space constraints of
		    "que_alias_list" array. Note that this number may be
		    inaccurate if queue aliases have been created/deleted
		    bewteen successive queries.


	2.8.10 Queue Annotation

	    Obtain and modify a queue's annotation from the
	    queue attributes structure.
	    Queue annotation is a read/write attribute.

	    void
	    mos_que_attr_annotation_get(
			    [in]  mos_que_attr_t            que_attributes,
			    [out] mos_que_attr_annotation_t annotation,
			    [out] error_status_t *          status
	    );


	    void
	    mos_que_attr_annotation_set(
			    [in] mos_que_attr_annotation_t  annotation,
			    [in,out]  mos_que_attr_t        que_attributes,
			    [out] error_status_t *          status
	    );

	   where
	       annotation:
		   Defines a character string comment about the queue.
		   The string is used by applications for informational
		   purposes only. The string can be up to 64 characters
		   long, including the NULL terminating character. A
		   NULL value indicates no annotation string.

		    #define mos_que_attr_annotation_maxsize     64
		    typedef char mos_que_attr_annotation_t[mos_que_attr_annotation_maxsize];

	       que_attributes:
		   Opaque pointer to the queue attributes structure obtained
		   via mos_que_attr_alloc() or mos_que_attr_peek().

		    typedef struct mos_qattr_s_t *     mos_que_attr_t;

	       status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.8.11 Queue Maximum Size

	    Obtain and modify the maximum queue size from the queue
	    attributes structure.
	    Queue maximum size is a read/write attribute.

	    To protect a queue manager's memory and disk resources, the
	    maximum amount of space required for a queue is the maximum
	    queue size multiplied by the maximum message size. If unlimited
	    queue and message sizes are requested(Refer to Sections 2.8.11
	    and 2.8.12) or if message persistence dicates(Refer to Section
	    2.8.13), then the maximum amount of space required for a queue
	    is uncertain.

	    void
	    mos_que_attr_quemaxsize_get(
			    [in]  mos_que_attr_t            que_attributes,
			    [out] unsigned32 *              que_maxsize,
			    [out] error_status_t *          status
	    );

	    void
	    mos_que_attr_quemaxsize_set(
			    [in] unsigned32                 que_maxsize,
			    [in,out]  mos_que_attr_t        que_attributes,
			    [out] error_status_t *          status
	    );

	    where
	       que_maxsize:
		  Maximum queue size allowed.
		  A default queue size of zero indicates that the number
		  of queue elements is unlimited but subject to the
		  availability of system resources.

		  /* Unlimited que size */
		  #define mos_c_que_attr_dflt_quemaxsize  0

	       que_attributes:
		   Opaque pointer to the queue attributes structure obtained
		   via mos_que_attr_alloc() or mos_que_attr_peek().

		    typedef struct mos_qattr_s_t *     mos_que_attr_t;

	       status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

L
	2.8.12 Message Maximum Size on Queue

	    Obtain and modify the maximum message size allowed on a queue
	    from the queue attributes structure.
	    Message maximum size is a read/write attribute.

	    To protect a queue manager's memory and disk resources, the
	    maximum amount of space required for a queue is the maximum
	    queue size multiplied by the maximum message size. If unlimited
	    queue and message sizes are requested(Refer to Sections 2.8.11
	    and 2.8.12) or if message persistence dicates(Refer to Section
	    2.8.13), then the maximum amount of space required for a queue
	    is uncertain.

	    void
	    mos_que_attr_msgmaxsize_get(
			    [in]  mos_que_attr_t            que_attributes,
			    [out] unsigned32 *              msg_maxsize,
			    [out] error_status_t *          status
	    );

	    void
	    mos_que_attr_msgmaxsize_set(
			    [in] unsigned32                 msg_maxsize,
			    [in,out]  mos_que_attr_t        que_attributes,
			    [out] error_status_t *          status
	    );

	    where
	       msg_maxsize:
		  Maximum message size allowed on a queue.
		  A default message size of zero indicates that a message
		  can be of any size but subject to the availability of
		  system resources.

		  /* Unlimited msg size */
		  #define mos_c_que_attr_dflt_msgmaxsize  0

	       que_attributes:
		   Opaque pointer to the queue attributes structure obtained
		   via mos_que_attr_alloc() or mos_que_attr_peek().

		    typedef struct mos_qattr_s_t *     mos_que_attr_t;

	       status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.8.13 Queue Persistence

	    Obtain and modify the queue persistence from the queue
	    attributes structure.
	    Queue persistence is a read/write attribute.

	    void
	    mos_que_attr_persistence_get(
		     [in]  mos_que_attr_t                que_attributes,
		     [out] mos_que_attr_persistence_t *  persistence,
		     [out] error_status_t *              status
	    );

	    void
	    mos_que_attr_persistence_set(
		     [in] mos_que_attr_persistence_t     persistence,
		     [in,out] mos_que_attr_t             que_attributes,
		     [out] error_status_t *              status
	    );

	    where
	       persistence:
		  Indicates whether the queue is in memory or on disk.
		  The default queue persistence is
		  mos_c_que_attr_msgpersistence.

		  typedef enum {
		     mos_c_que_attr_msgpersistence,
						 /* msg persistence dicates */
		     mos_c_que_attr_volatile,    /* queue stored in memory */
		     mos_c_que_attr_persistent   /* queue stored on disk */
		  } mos_que_attr_persistence_t;

		  Note that there is a persistence attribute on messages
		  as well as queues. If the message persistence is
		  "persistent" and the queue persistence is "volatile",
		  the queue manager stores the message in memory only and
		  returns a warning message to the caller of the send
		  operation. If the queue persistence is "msgpersistence",
		  then the queue manager stores the message where the message
		  persistence dicates. Note that if message persistence
		  dicates, then messages may be enqueued in memory as well
		  as on disk. The following table describes how a
		  message is stored based on the persistence attribute of
		  both the queue and the message itself.

			    | Use Msg     | Volatile   | Persistent
			    | Persistence | Queue      | Queue
		  -------------------------------------------------
		  Volatile  |             |            |
		  Message   | Volatile    | Volatile   | Persistent
			    |             |            |
		  -------------------------------------------------
		  Persisent |             |            |
		  Message   | Persistent  | Volatile   | Persistent
			    |             | w/warning  |


	       que_attributes:
		   Opaque pointer to the queue attributes structure obtained
		   via mos_que_attr_alloc() or mos_que_attr_peek().

		    typedef struct mos_qattr_s_t *     mos_que_attr_t;

	       status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.



	2.8.14 Empty Queue Idle Timeout

	    Obtain and modify the empty queue idle timeout in relative
	    time from the queue attributes structure.
	    Empty Queue idle timeout is a read/write attribute.

	    void
	    mos_que_attr_idletimeout_get(
			    [in]  mos_que_attr_t           que_attributes,
			    [out] utc_t *                  que_idle_timeout,
			    [out] error_status_t *         status
	    );

	    void
	    mos_que_attr_idletimeout_set(
			    [in] utc_t *                   que_idle_timeout,
			    [in,out] mos_que_attr_t        que_attributes,
			    [out] error_status_t *         status
	    );

	    where
	       que_idle_timeout:
		  Indicates the maximum amount of time where no activity
		  occurs on an empty queue. Once this timeout is reached,
		  its queue manager is free to implicitly delete the empty
		  queue at any time thereafter. If this value is not equal
		  to NULL, the queue manager starts the idle timer when a
		  queue is empty.
		  Specified in relative time only.

		  The default queue idle timeout is 24 hours. An empty
		  queue idle timeout of NULL indicates that a queue
		  remains indefinitely until explicitly deleted via
		  mos_que_mgmt_delete().

		  /*
		   * If empty queue is idle for 24 hours, it is deleted.
		   */
		   #define mos_c_que_attr_dflt_idletime  24

	       que_attributes:
		   Opaque pointer to the queue attributes structure obtained
		   via mos_que_attr_alloc() or mos_que_attr_peek().

		    typedef struct mos_qattr_s_t *     mos_que_attr_t;

	       status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

		    mos_s_que_attr_inv        Invalid queue attribute structure.

		    mos_s_que_attr_idletimeout_null
		       On mos_que_attr_idletimeout_get(), idletimeout is NULL.

	2.8.15 Queue Enqueue Service

	    Obtain and modify whether enqueuing is allowed or not from
	    the queue attributes structure.
	    Queue enqueue service is a read/write attribute.

	    void
	    mos_que_attr_allowenq_get(
			    [in]  mos_que_attr_t           que_attributes,
			    [out] boolean *                allow_enq,
			    [out] error_status_t *         status
	    );

	    void
	    mos_que_attr_allowenq_set(
			    [in] boolean                   allow_enq,
			    [in,out] mos_que_attr_t        que_attributes,
			    [out] error_status_t *         status
	    );

	    where
	       allowenq:
		   Indicates whether enqueuing is allowed or not.
		   The default is TRUE.

		   TRUE indicates allow enqueuing.
		   FALSE indicates inhibit enqueuing.

	       que_attributes:
		   Opaque pointer to the queue attributes structure obtained
		   via mos_que_attr_alloc() or mos_que_attr_peek().

		    typedef struct mos_qattr_s_t *     mos_que_attr_t;

	       status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	2.8.16 Queue Dequeue Service

	    Obtain and modify whether dequeuing is allowed or not from
	    the queue attributes structure.
	    Queue dequeue service is a read/write attribute.

	    void
	    mos_que_attr_allowdeq_get(
			    [in]  mos_que_attr_t           que_attributes,
			    [out] boolean *                allow_deq,
			    [out] error_status_t *         status
	    );

	    void
	    mos_que_attr_allowdeq_set(
			    [in] boolean                   allow_deq,
			    [in,out] mos_que_attr_t        que_attributes,
			    [out] error_status_t *         status
	    );

	    where
	       allow_deq:
		   Indicates whether dequeuing is allowed or not.
		   The default is TRUE.

		   TRUE indicates allow dequeuing.
		   FALSE indicates inhibit dequeuing.

	       que_attributes:
		   Opaque pointer to the queue attributes structure obtained
		   via mos_que_attr_alloc() or mos_que_attr_peek().

		    typedef struct mos_qattr_s_t *     mos_que_attr_t;

	       status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


    2.9 Queue Management Utilities

       This group of interfaces allow administration of queues.

       2.9.1 mos_que_mgmt_create()

	  Create one queue and commit its queue attributes to be managed
	  by one queue manager.

	  2.9.1.1 mos_que_mgmt_create() Synopsis

	     void
	     mos_que_mgmt_create(
			  [in]  mos_handle_t          qmgr_handle,
			  [in]  mos_rsrc_name_t       name,
			  [in]  mos_que_attr_t        que_attributes,
			  [out] mos_handle_t *        que_handle,
			  [out] error_status_t *      status
	     );

	      where
		 qmgr_handle:
		       A context handle to a queue manager.
		       To speed look-ups, a context handle to an NSI group
		       or profile is prohibited.

		       If NULL, the default queue manager is used.

		 name:
		       Specifies queue name to create.
		       If NULL, the name is generated from the queue
		       manager name concatenated with the queue UUID.
		       If a simple name, the simple name is created as
		       a junction from the queue manager name.

		 queue_attributes:
		       Specifies the queue attributes when creating a queue.
		       Use mos_que_attr_alloc() to allocate a buffer and use
		       the other mos_que_attr_X_set() APIs to modify any
		       attributes.

		       If NULL is specified, the API allocates the queue
		       attributes and sets the defaults. Otherwise, it is
		       the responsibility of the caller to release the
		       memory for the returned queue attributes structure
		       via mos_que_attr_free().

		 que_handle:
		    A context handle to the new queue.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	  2.9.1.2 mos_que_mgmt_create() Internal Description

	     Remember that only queue managers export to CDS, not queues.
	     All queues are treated as junction names under its respective
	     Q-mgr name.

	     First, the API generates a queue UUID.
	     If the specified name is NULL, the Q-mgr generates a queue name
	     of the queue manager name concatenated with the UUID of the queue.

		Ex:
		   /.:/subsys/mos/qm1         : Qmgr from handle
		   ""                         : input parameter; "entry_name"
		   /.:/subsys/mos/qm1/<UUID>  : queue name

	     If the specified name is a simple name:
		The Q-mgr creates a junction using the simple name
		under the Q-mgr name.

		 Ex:
		   /.:/subsys/mos/qm1         : Qmgr from handle
		   "jas"                      : input parameter; "entry_name"
		   /.:/subsys/mos/qm1/jas     : queue name


       2.9.2 mos_que_mgmt_delete()

	  Delete one queue managed by the specified queue manager.

	  Since a named link to a queue manager may still be required
	  to access another queue, the API does NOT delete all named
	  links on each queue alias. It is the responsibility of the
	  caller to delete any named link that was created implicitly
	  via mos_que_mgmt_create()/mos_que_mgmt_commit() or explicitly
	  via dcecp link create command. If a named link is no longer
	  required; use mos_que_mgmt_commit() in conjuction with
	  mos_que_attr_alias_remove() or use dcecp link delete command.

	  2.9.2.1 mos_que_mgmt_delete() Synopsis

	     void
	     mos_que_mgmt_delete(
			  [in]  mos_que_delete_op_t  flags,
			  [in,out]  mos_handle_t *   resource_handle,
			  [out] error_status_t *     status
	     );

	     where
		 flags:
		    Indicates what to do with queues that are non-empty.
		    The default is mos_c_delop_preserve.

		    typedef enum {
		       mos_c_delop_preserve,
					    /*
					     * Preserve queue if non-empty
					     */
		       mos_c_delop_force
					    /* Force deletion
					     * even if queue is non-empty
					     */
		    } mos_que_delete_op_t;

		 resource_handle:
		    A context handle to the resource obtained via
		    mos_que_mgmt_create() or mos_rsrc_attach().
		    If the delete operation succeeds, this parameter
		    returns the value NULL.

		    Note that the caller must have the access rights
		    to delete the queue.

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	  2.9.2.2 mos_que_mgmt_delete() Internal Description

	     Note that the Q-mgr verifies that the caller has the
	     proper access rights to delete the queue.

	     A handle is passed to the queue deletion API. The API has
	     the Q-mgr binding and the queue name. As a result, the Q-mgr
	     in question deletes the specified queue along with all queue
	     attributes.



       2.9.3 mos_que_mgmt_move()

	  Move or rename one queue within a Q-mgr or from one Q-mgr to
	  another. The caller must have the proper access rights to
	  create and/or delete queues as well as enqueuing and dequeuing
	  from the specified queues.

	  If the destination queue does not exist, this API implicitly
	  creates it using the "dest_qmgr_handle", the "new_que_name",
	  and the same queue attributes from the source queue,
	  "move_que_handle". Note that the source queue aliases are not
	  copied to the destination queue. This is due to the fact that
	  aliases may have been created with named links to queue managers.

	  If this operation is not a rename operation and the move operation
	  is successful, the source queue is implicitly deleted.

	  In the event of a queue move failure, the caller can be
	  assured that no messages are lost. However, some messages
	  may have been successfully moved to the destination queue and
	  the remaining messages are still sitting on the source queue.
	  Note that the source queue is not deleted, but the MOS-API
	  does not attempt any rollback operation. This event could
	  occur, for example, if the caller loses contact with the
	  the source queue manager due to a hardware failure on the
	  machine where the source queue manager resides.

	  2.9.3.1 mos_que_mgmt_move() Synopsis

	     void
	     mos_que_mgmt_move(
			  [in]      mos_handle_t          dest_qmgr_handle,
			  [in]      mos_rsrc_name_t       new_que_name,
			  [in]      unsigned32            flags,
			  [in/out]  mos_handle_t *        move_que_handle,
			  [out]     error_status_t *      status
	     );

	      where
		 dest_qmgr_handle:
		    A context handle to the destination Q-mgr.
		    Use mos_rsrc_attach() to get the Q-mgr handle.

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		    A NULL value indicates that the destination queue
		    manager is the same as the source queue manager.

		 dest_que_name:
		    Specifies new queue name.
		    The name specified must be a simple name.

		 flags:
		    Indicates the action to be performed on a queue
		    move or rename. The default is "mos_c_que_mv_none".

		    /*
		     * No options specified.
		     */
		    #define mos_c_que_mv_none      0x00000000
		    /*
		     * If the referral flag is set, the source queue name
		     * and the destination queue name is maintained by
		     * the source Q-mgr.
		     */
		    #define mos_c_que_mv_referral  0x00000001


		 move_resource_handle:
		    A context handle to an attached source queue resource.
		    Use mos_rsrc_attach() to get the source queue handle.

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		    If the move operation succeeds, this parameter
		    returns a handle to the destination queue resource.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	  2.9.3.2 mos_que_mgmt_move() Internal Description

	     The API performs the following:

	     1) If the referral flag is set, the source queue name and
		the destination queue name is maintained by the source Q-mgr.

	     2) Determine if destination queue manager is the same as
		the source queue manager.

		If equal and destination queue does not exist, rename source
		queue to the destination queue name and return.

		If equal and destination queue does exist, append messages
		from source queue to destination queue; go to step 4.

	     3) Here, the destination queue manager is not the same as the
		source queue manager.
		Determine if destination queue exists.
		If not, create destination queue.
		  Create destination queue via mos_que_mgmt_create() with
		  the same queue attributes of the source queue.

	     4) Disable enqueuing on source queue, if allowed.

	     5) Note that the API does not invoke any encoding/decoding
		conversion functions during the queue move operation.

	     6) Determine if caller has permission to dequeue from source
		queue and enqueue to destination queue.

	     7) In a loop for every message in source queue:
		  - Use the end-to-end protection level in the
		    message attributes area of the message to set the
		    protection level via rpc_binding_set_auth_info().
		  - Retrieve a copy of the message and its message
		    attributes from source queue.
		  - Send the message and its message attributes to the
		    destination queue.
		  - Purge the message from source queue.

	     8) Delete empty source queue via mos_que_mgmt_delete().

	     9) The status is then returned to the calling application.


       2.9.4 mos_que_mgmt_save()

	  Save all messages in the specified queue to persistent storage.

	  2.9.4.1 mos_que_mgmt_save() Synopsis

	     void
	     mos_que_mgmt_save(
			  [in]  mos_handle_t          resource_handle,
			  [out] error_status_t *      status
	     );

	      where
		 resource_handle:
		    A context handle to the queue.
		    Use mos_rsrc_attach() to get the queue handle.

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	  2.9.4.2 mos_que_mgmt_save() Internal Description

	     The API merely sends the request to the queue manager
	     managing the queue. The queue manager loops thru each message
	     in the queue to determine if it's already on disk. If not, the
	     message is written to the backing store.


       2.9.5 mos_que_mgmt_quename_list()

	    Return list of queues by name managed by specified Q-mgr.

	   2.9.5.1 mos_que_mgmt_quename_list() Synopsis

	     void
	     mos_que_mgmt_quename_list(
			  [in] mos_handle_t             resource_handle,
			  [in] unsigned32               space_avail,
			  [out] unsigned32 *            num_returned,
			  [out] mos_rsrc_name_t         que_name_list[],
			  [out] unsigned32 *            num_left,
			  [out] error_status_t *        status
	     );

	     where
		 resource_handle:
		    A context handle to the resource obtained via
		    mos_que_mgmt_create() or mos_rsrc_attach().

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		 space_avail:
		    Specifies the size of the "que_name_list" array.
		    The caller is responsible for allocating the space
		    for "space_avail" queue names.

		 num_returned:
		    The number of queues managed by the specified Q-mgr
		    returned in the "que_name_list".

		 que_name_list:
		    Array of queue names returned.
		    The size of the array is determined by "space_avail"
		    and the length by "num_returned".

		 num_left:
		    Number of queues that were found but could not
		    be returned because of space constraints of
		    "que_name_list" array. Note that this number may be
		    inaccurate if queues have been created/deleted
		    bewteen successive queries.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


       2.9.6 mos_que_mgmt_quecount_get()

	    Return number of queues managed by specified Q-mgr.

	   2.9.6.1 mos_que_mgmt_quecount_get() Synopsis

	     void
	     mos_que_mgmt_quecount_get(
			  [in] mos_handle_t             resource_handle,
			  [out] unsigned32 *            que_nbr,
			  [out] error_status_t *        status
	     );

	     where
		 resource_handle:
		    A context handle to the resource obtained via
		    mos_que_mgmt_create() or mos_rsrc_attach().

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		 que_nbr:
		    Return number of queues managed by specified Q-mgr.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.



       2.9.7 mos_que_mgmt_msgid_list()

	   Return list of messages by UUID from the specified queue that
	   satisfy the selection criteria.

	   2.9.7.1 mos_que_mgmt_msgid_list() Synopsis

	     void
	     mos_que_mgmt_msgid_list(
			  [in] mos_handle_t             resource_handle,
			  [in] mos_msg_selfilter_t      msg_selection_filter,
			  [in] unsigned32               space_avail,
			  [out] unsigned32 *            num_returned,
			  [out] uuid_t                  msg_id_list[],
			  [out] unsigned32 *            num_left,
			  [out] error_status_t *        status
	     );

	     where
		 resource_handle:
		    A context handle to the resource obtained via
		    mos_que_mgmt_create() or mos_rsrc_attach().

		    To speed look-ups, a context handle to an NSI group
		    or profile is prohibited.

		 msg_selection_filter:
		    Opaque pointer to the selection filter buffer.
		    Use the mos_msg_selfilter_alloc(), mos_msg_selfilter_free(),
		    and mos_msg_selmask_add() APIs to allocate, deallocate and
		    define one or more selection criteria. A message ID is
		    successfully retrieved following the rules of the logical
		    AND operator among all specified criteria.

		    A NULL value indicates no selection criteria.

		     /*
		      * Opaque pointer to selection filter structure
		      */
		     typedef struct mos_mask_list_s_t * mos_msg_selfilter_t;

		 space_avail:
		    Specifies the size of the "msg_id_list" array.
		    The caller is responsible for allocating the space
		    for "space_avail" message IDs.

		 num_returned:
		    The number of message IDs returned in the "msg_id_list".

		 msg_id_list:
		    Array of message IDs returned.
		    The size of the array is determined by "space_avail"
		    and the length by "num_returned".

		 num_left:
		    Number of messages not necessarily matching any
		    selection criteria that were found but could not
		    be returned because of space constraints of
		    "msg_id_list" array. Note that this number may be
		    inaccurate if the queue has enqueued/dequeued messages
		    bewteen successive queries.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


       2.9.8 Dumping queue contents

	    Use "mos_que_mgmt_msgid_list()" API to get all the
	    messages in the queue.

	    Loop thru all msg_ids using mos_msg_peek() API
	    and the selection filter with the msgid specified.



3.0 Code Examples for DCE's MOS-API

    3.1 basic_mq.c
/* ______________________________________________________________________
 * Copyright (c) 1996 The Open Group, Inc., Cambridge, MA USA
 * All rights reserved.
 * ______________________________________________________________________
 *
 * MODULE:       basic_mq.c
 *
 * DESCRIPTION:  Illustrates use of the four basic DCE MOS calls -
 *               attach, enqueue, dequeue, done
 *               This program will:
 *                   -Attach one queue by name
 *                   -Send ten messages to the attached queue
 *                   -Retrieve the messages from the attached queue
 *                   -Exit MOS
 *
 * ADDED NOTE:
 *               The "mbox" queue must already exist.
 *               The sender uses the default protection level(encryption) for
 *               authenticated communciations with the Q-mgr.
 *               All application-specific messages are the same data type;
 *                    an array of bytes
 *               Same data type within a queue
 *               No data marshalling for an array of bytes.
 *               Default message attributes are used:
 *                   message type        = mos_c_msg_attr_msgtype_data
 *                   priority            = mos_c_msg_attr_dflt_priority
 *                   time-to-live        = mos_c_msg_attr_dflt_ttl
 *                   time-to-receive     = mos_c_msg_attr_dflt_ttr
 *                   persistence         = mos_c_msg_attr_volatile
 *                   notice options      = mos_c_msg_attr_notice_none
 *                   data type           = NIL-UUID for an array of bytes
 *                   reply-to queue name = NULL
 *                   sender's protection_level
 *                                       = mos_c_protect_level_default
 * ______________________________________________________________________
 */
#include <stdio.h>
#include <string.h>
#include <dce/dce.h>
#include <dcemosmsg.h>
#include <dcemosmac.h>
#include <dcemossvc.h>
#include "../../api/mosif.h"

/*
 * DECLARATIONS
 */
#define GOOD_STATUS(stp)      ((stp)==NULL || (*stp) == error_status_ok)

/*
 * INTERNAL VARIABLES
 */
static unsigned_char_t  *que_name = (unsigned_char_t *)"/.:/subsys/Q/q2/jas";
static unsigned_char_t  *sec_name = (unsigned_char_t *)"test_queues";

/*
 * All messages are the same data type; an array of bytes
 */
static char *msgList[] = {
			  "First message",
			  "Second message",
			  "Third message",
			  "Fourth message",
			  "Fifth message",
			  "Sixth message",
			  "Seventh message",
			  "Eighth message",
			  "Ninth message",
			  "Tenth message"
			  };

void main()
{
   int                          i;
   error_status_t               status;
   mos_handle_t                 mbox_qh;
   mos_datatype_bytearray_t     in_msg_buf;  /* Default datatype */
   mos_msg_buf_t                out_msg_buf; /* Allocated by runtime */
   uuid_t                       msg_id;

   printf("\nDCE-MOS basic example started...\n");

   /*
    * Find all resources required for the application
    */
   mos_rsrc_attach(que_name,
		   sec_name,   /* security group */
		   &mbox_qh,
		   &status);

   /*
    * Enqueue all messages to the specified queue
    */
   for (i = 0; (GOOD_STATUS(&status) && i < 10); i++) {

      in_msg_buf.size = (strlen(msgList[i]) + 1);
      in_msg_buf.data = (unsigned_char_t *)msgList[i];
      mos_msg_enqueue(mbox_qh,
		      mos_c_enqmode_async,
		      NULL,          /* Use default message attributes */
		      &in_msg_buf,
		      &msg_id,
		      &status);
      if (GOOD_STATUS(&status)) {
	 printf("\nSent msg successfully: %s\n", in_msg_buf.data);
      } else {
	 printf("\nError sending msg: %d\n", status);
      }
   } /* End of loop thru all messages */

   /*
    * Dequeue all messages from the specified queue
    */
   while (GOOD_STATUS(&status)) {

      mos_msg_dequeue(mbox_qh,
		      mos_c_deqmode_nowait,
		      NULL,           /* No selection criteria */
		      NULL,           /* Message attributes not returned */
		      &out_msg_buf,
		      &status);
      if (GOOD_STATUS(&status)) {
	printf("\nRetrieved msg successfully: %s\n", out_msg_buf->data);
	mos_msg_buf_free(&out_msg_buf, &status);
      } else if (status == mos_empty_queue) {
	printf("\nEmpty queue; No msgs to retrieve\n");
      } else {
	printf("\nError retrieving msg: %d\n", status);
      }
   } /* End of loop thru all messages */

   /*
    * Exit from DCE-MOS
    */
   mos_done(&status);

   printf("\nDCE-MOS basic example complete...\n");

} /* End of main() */


    3.2 Telecommunications example

    3.2.1 charge_base.idl

/* ______________________________________________________________________
 * Copyright (c) 1996 The Open Group, Inc., Cambridge, MA USA
 * All rights reserved.
 * ______________________________________________________________________
 *
 * MODULE:       charge_base.idl
 *
 * DESCRIPTION:  Defines the "charge message" interface for all telcom
 *               test programs.
 * ______________________________________________________________________
 */

[
    uuid(fd1c7fd6-3975-11d0-94b7-0800095fae3a),
    pointer_default(ptr),
    version(1.0)
]

interface charge_base
{

   import "dce/utctypes.idl";

   /*
    * charge message examples
    *         "999-9999,111-1111,06/06/96,4 minutes,$15.00",
    *         "999-9999,222-2222,06/07/96,2 minutes,$10.30",
    *         "999-9999,333-3333,06/03/96,30 minutes,$90.00",
    *         "999-9999,444-4444,06/04/96,6 minutes,$11.30",
    *         "999-9999,555-5555,06/05/96,1 minute,$20.00",
    */
   typedef struct telcom_datatype_charge_s_t {
      [ptr,string] char *                   calling_party;
      [ptr,string] char *                   called_party;
		   utc_t                    timestamp;
		   unsigned32               duration;
		   unsigned32               cost;
   } telcom_datatype_charge_t;

}
    3.2.2 mwi_base.idl

/* ______________________________________________________________________
 * Copyright (c) 1996 The Open Group, Inc., Cambridge, MA USA
 * All rights reserved.
 * ______________________________________________________________________
 *
 * MODULE:       mwi_base.idl
 *
 * DESCRIPTION:  Defines the "mwi message" interface for all telcom
 *               test programs.
 * ______________________________________________________________________
 */

[
    uuid(7a0cd0fa-3975-11d0-9ef4-0800095fae3a),
    pointer_default(ptr),
    version(1.0)
]

interface mwi_base
{

    /*
     * Message waiting Indicator: off or on
     */
    const unsigned32 telcom_c_mwi_off    = 0x00000000;
    const unsigned32 telcom_c_mwi_on     = 0x00000001;

    /*
     * mwi message type examples
     *         "111-1111,ON",
     *         "222-2222,ON",
     *         "333-3333,ON",
     *         "444-4444,ON",
     *         "555-5555,ON",
     */
    typedef struct telcom_datatype_mwi_s_t {
       [ptr,string] char *                   phone_number;
		    unsigned32               mwi_status;
    } telcom_datatype_mwi_t;

}

    3.2.3 telcom_convert.idl

/* ______________________________________________________________________
 * Copyright (c) 1996 The Open Group, Inc., Cambridge, MA USA
 * All rights reserved.
 * ______________________________________________________________________
 *
 * MODULE:       telcom_convert.idl
 *
 * DESCRIPTION:  Defines the conversion functions necessary to support
 *               marshalling of "mwi" and "charge" messages for all
 *               telcom test programs.
 * ______________________________________________________________________
 */

[
    uuid(f0523f1a-3976-11d0-801c-0800095fae3a),
    pointer_default(ptr),
    version(1.0)
]

interface telcom_convert
{
    import "charge_base.idl";
    import "mwi_base.idl";

    void
    charge_conversion_func(
	  [in]        handle_t                     handle,
	  [in, out]   telcom_datatype_charge_t *   charge_data,
	  [in, out]   error_status_t *             status
    );

    void
    mwi_conversion_func(
	  [in]        handle_t                     handle,
	  [in, out]   telcom_datatype_mwi_t *      mwi_data,
	  [in, out]   error_status_t *             status
    );

}
    3.2.4 telcom_convert.acf

/* ______________________________________________________________________
 * Copyright (c) 1996 The Open Group, Inc., Cambridge, MA USA
 * All rights reserved.
 * ______________________________________________________________________
 *
 * MODULE:  telcom_convert.acf
 *
 * DESCRIPTION:  Defines the attributes to be used in conjunction with
 *               telcom_convert.idl to support marshalling of "mwi"
 *               and "charge" messages for all telcom test programs.
 * ______________________________________________________________________
 *
 * $Log: mos_api.txt,v $
Revision 1.4  1996/12/03  14:39:04  salamone
mos_rsrc_name_get() names not returned if NULL

Revision 1.3  96/12/03  16:24:20  16:24:20  bowe (John Bowe)
Added discussion of mos_rsrc_name_get().

Revision 1.2  1996/11/26  21:13:18  bowe
Removed extraneous trailing blanks.

Revision 1.1  1996/11/21  13:09:54  salamone
Reviewed and approved internally

Revision 1.1  96/11/20  17:14:25  17:14:25  salamone (Julie Salamone)
Initial version

 * $EndLog$
 * ______________________________________________________________________
 */
interface telcom_convert
{
    [encode,decode] charge_conversion_func([comm_status] status);
    [encode,decode] mwi_conversion_func([comm_status] status);
}


    3.2.5 telcom_deqall_mq.c

/* ______________________________________________________________________
 * Copyright (c) 1996 The Open Group, Inc., Cambridge, MA USA
 * All rights reserved.
 * ______________________________________________________________________
 *
 * MODULE:       telcom_deqall_mq.c
 *
 * DESCRIPTION:  Illustrates using MOS-API calls -
 *               This program will:
 *                   -Create or attach one queue by name
 *                   -Set messsage attributes
 *                   -Provide data encryption for authenticated communications
 *                   -Provide data marshalling
 *                   -Provide delivery notification
 *                   -Enqueue five "charge" messages
 *                   -Enqueue five "mwi" messages
 *                   -Dequeue all messages from the queue
 *                   -Exit MOS
 *
 * ADDED NOTE:
 *               Different datatypes are enqueued to one queue.
 *               The messages are then dequeued one by one starting at
 *               the top of the queue regardless of the message datatype.
 * ______________________________________________________________________
 */
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <dce/dce.h>
#include <dce/utc.h>

#include <dcemosmsg.h>
#include <dcemosmac.h>
#include <dcemossvc.h>
#include <telcom_convert.h>
#include "../../api/mosif.h"

/*
 * DECLARATIONS
 */
#define GOOD_STATUS(stp)      ((stp)==NULL || (*stp) == error_status_ok)

/*
 * INTERNAL VARIABLES
 */
static unsigned_char_t  *telcom_que_name = (unsigned_char_t *)"telcom";
static unsigned_char_t  *sec_group = (unsigned_char_t *)"test_queues";

/*
 * Phone number list
 */
static char *phoneList[] = {
			  "111-1111",
			  "222-2222",
			  "333-3333",
			  "444-4444",
			  "555-5555",
			  };
/*
 * Datatype for charge messeages in charge_base.idl:
 *    fd1c7fd6-3975-11d0-94b7-0800095fae3a
 */
static uuid_t charge_id = {
			    0xfd1c7fd6,
			    0x3975,
			    0x11d0,
			    0x94,
			    0xb7,
			    {0x08,0x00,0x09,0x5f,0xae,0x3a}
			  };
/*
 * Datatype for mwi messeages in mwi_base.idl:
 *   7a0cd0fa-3975-11d0-9ef4-0800095fae3a
 */
static uuid_t mwi_id = {
			 0x7a0cd0fa,
			 0x3975,
			 0x11d0,
			 0x9e,
			 0xf4,
			 {0x08,0x00,0x09,0x5f,0xae,0x3a}
			};

/*
 * Resource handles to the Q-mgr and telcom queues
 */
mos_handle_t     dflt_qmgrh;
mos_handle_t     telcom_qh;

/*
 * Message attributes for charge and mwi messages
 */
mos_msg_attr_t   charge_msg_attr;
mos_msg_attr_t   mwi_msg_attr;

/*
 * INTERNAL PROTOTYPES
 */
void telcom__register_datatypes(error_status_t *);
void telcom__find_resources(error_status_t *);
void telcom__set_msg_attributes(error_status_t *);
void telcom__enq_charge_msgs(error_status_t *);
void telcom__enq_mwi_msgs(error_status_t *);
void telcom__set_charge_msg_attr(error_status_t *);
void telcom__set_mwi_msg_attr(error_status_t *);
void telcom__deq_all_msgs(error_status_t *);
char *telcom__datatype_show(mos_msg_attr_t, mos_msg_buf_t, error_status_t *);
void telcom__done(error_status_t *);


/*
 * main driver
 */
void
main()
{
   error_status_t   status;

   printf("\nDCE-MOS telcom example started...\n");

   /*
    * Register all application-specific datatypes with the MOS
    */
   telcom__register_datatypes(&status);

   /*
    * Find all resources required for the application
    */
   if (GOOD_STATUS(&status)) {
       telcom__find_resources(&status);
   }

   /*
    * Allocate and set message attributes associated with messages
    */
   if (GOOD_STATUS(&status)) {
       telcom__set_msg_attributes(&status);
   }

   /*
    * Enqueue all charge messages to queue
    */
   if (GOOD_STATUS(&status)) {
       telcom__enq_charge_msgs(&status);
   }

   /*
    * Enqueue all mwi messages to queue
    */
   if (GOOD_STATUS(&status)) {
       telcom__enq_mwi_msgs(&status);
   }

   /*
    * Dequeue all messages from queue
    */
   if (GOOD_STATUS(&status)) {
       telcom__deq_all_msgs(&status);
   }

   /*
    * Exit from DCE-MOS
    */
   telcom__done(&status);

   printf("\nDCE-MOS telcom example complete...\n");

} /* End of main() */


void
telcom__register_datatypes(error_status_t *      status)
{
   /*
    * Register "charge" messages to be marshalled.
    */
   mos_api_datatype_register(&charge_id,
			     (mos_msg_attr_convfn_t)charge_conversion_func,
			     status);

   /*
    * Register "mwi" messages to be marshalled.
    */
   if (GOOD_STATUS(status)) {
      mos_api_datatype_register(&mwi_id,
				(mos_msg_attr_convfn_t)mwi_conversion_func,
				status);
   }

} /* End of telcom__register_datatypes() routine */


void
telcom__find_resources(error_status_t *      status)
{
   mos_rsrc_name_t         dflt_qmgr_name;

   mos_rsrc_dflt_quemgr_get(sec_group,
			    dflt_qmgr_name,
			    &dflt_qmgrh,
			    status);

   if (GOOD_STATUS(status)) {
       mos_que_mgmt_create(dflt_qmgrh,
			   telcom_que_name,
			   (void *)NULL,     /* Use default queue attributes */
			   &telcom_qh,
			   status);
       if (*status == mos_queue_already_exists) {
	   mos_rsrc_attach(telcom_que_name,
			   sec_group,        /* security group */
			   &telcom_qh,
			   status);
      }
   }

} /* End of telcom__find_resources() */


void
telcom__set_msg_attributes(error_status_t *      status)
{

   /*
    * Allocate and set message attributes for "charge" messages
    */
   telcom__set_charge_msg_attr(status);

   /*
    * Allocate and set message attributes for "mwi" messages
    */
   if (GOOD_STATUS(status)) {
       telcom__set_mwi_msg_attr(status);
   }

} /* End of telcom__set_msg_attributes() */



void
telcom__set_charge_msg_attr(error_status_t *      status)
{
   unsigned32 notice_op = 0;

   /*
    * Allocate message attributes for "charge" messages
    */
   mos_msg_attr_alloc(&charge_msg_attr,
		      status);

   /*
    * Set "charge" messages to be sent.
    */
   if (GOOD_STATUS(status)) {
       mos_msg_attr_datatype_set(&charge_id,
				 charge_msg_attr,
				 status);
   }

   /*
    * Ensure persistence on "charge" messages
    */
   if (GOOD_STATUS(status)) {
       mos_msg_attr_persistence_set(mos_c_msg_attr_persistent,
				    charge_msg_attr,
				    status);
   }

   /*
    * Set notice options and destination of ACK/NAKs on "charge" messages.
    */
   if (GOOD_STATUS(status)) {
      notice_op = mos_c_msg_attr_notice_enqueue|mos_c_msg_attr_notice_dequeue;
      mos_msg_attr_notice_set(notice_op,
			      telcom_que_name,
			      sec_group,
			      charge_msg_attr,
			      (mos_handle_t *)NULL,  /* Use hdl from create */
			      status);
   }

} /* End of telcom__set_charge_msg_attr() */


void
telcom__set_mwi_msg_attr(error_status_t *      status)
{
   utc_t                        generic_time;
   char                         gmTime[UTC_MAX_STR_LEN];

   /*
    * Allocate message attributes for "mwi" messages
    */
   mos_msg_attr_alloc(&mwi_msg_attr,
		      status);

   /*
    * Set "mwi" messages to be sent.
    */
   if (GOOD_STATUS(status)) {
      mos_msg_attr_datatype_set(&mwi_id,
				mwi_msg_attr,
				status);
   }

   /*
    * Set expiration date on "mwi" messages
    */
   if (GOOD_STATUS(status)) {
      strcpy((char *)gmTime, "1999-10-17");
      utc_mkasctime(&generic_time, gmTime);
      mos_msg_attr_ttl_set(&generic_time,
			   mwi_msg_attr,
			   status);
   }

} /* End of telcom__set_mwi_msg_attr() */


void
telcom__enq_charge_msgs(error_status_t *      status)
{
   int                         i, j;
   uuid_t                      msg_id;
   unsigned_char_t *           msg_id_string;
   telcom_datatype_charge_t    charge_msg_buf;
   error_status_t              tmp_status;

   /*
    * Enqueue five charge messages
    */
   for (i = 0; i < 5; i++) {

      /*
       * Build charge message
       */
      charge_msg_buf.calling_party = (idl_char *)strdup("999-9999");
      charge_msg_buf.called_party = (idl_char *)strdup(phoneList[i]);
      charge_msg_buf.duration = 1800;  /* 30 minutes */
      charge_msg_buf.cost = 10;        /* 10 dollars */
      utc_gettime(&charge_msg_buf.timestamp);

      /*
       * Send charge message
       */
      mos_msg_enqueue(telcom_qh,
		      mos_c_enqmode_async,
		      charge_msg_attr,
		      &charge_msg_buf,
		      &msg_id,
		      status);

      if GOOD_STATUS(status) {
	 uuid_to_string(&msg_id, &msg_id_string, &tmp_status);
	 printf("Sent charge msg %s for calling party %s to called party %s\n",
		       msg_id_string,
		       charge_msg_buf.calling_party,
		       charge_msg_buf.called_party);
	 free(charge_msg_buf.calling_party);
	 free(charge_msg_buf.called_party);
	 rpc_string_free(&msg_id_string, &tmp_status);
      } else {
	 printf("Error sending msg: %d:%s\n", *status,
					      charge_msg_buf.called_party);
	 free(charge_msg_buf.calling_party);
	 free(charge_msg_buf.called_party);
	 break;
      }

   } /* End of loop thru all messages */

} /* End of telcom__enq_charge_msgs() */


void
telcom__enq_mwi_msgs(error_status_t *      status)
{
   int                         i, j;
   uuid_t                      msg_id;
   unsigned_char_t *           msg_id_string;
   telcom_datatype_mwi_t       mwi_msg_buf;
   error_status_t              tmp_status;

   /*
    * Enqueue five mwi messages
    */
   for (i = 0; i < 5; i++) {

      /*
       * Build mwi message
       */
      mwi_msg_buf.phone_number = (idl_char *)strdup(phoneList[i]);
      mwi_msg_buf.mwi_status = telcom_c_mwi_on;

      /*
       * Send mwi message
       */
      mos_msg_enqueue(telcom_qh,
		      mos_c_enqmode_async,
		      mwi_msg_attr,
		      &mwi_msg_buf,
		      &msg_id,
		      status);

      if GOOD_STATUS(status) {
	 uuid_to_string(&msg_id, &msg_id_string, &tmp_status);
	 printf("Sent MWI msg %s with indicator [%d] for phone number %s\n",
		       msg_id_string,
		       mwi_msg_buf.mwi_status,
		       mwi_msg_buf.phone_number);
	 free(mwi_msg_buf.phone_number);
	 rpc_string_free(&msg_id_string, &tmp_status);
      } else {
	 printf("Error sending msg: %d:%s\n", *status,
					      mwi_msg_buf.phone_number);
	 free(mwi_msg_buf.phone_number);
	 break;
      }

   } /* End of loop thru all messages */

} /* End of telcom__enq_mwi_msgs() */


void
telcom__deq_all_msgs(error_status_t *      status)
{
   char *                 		datatype_string;
   uuid_t                 		msg_id;
   unsigned_char_t *      		msg_id_string;
   error_status_t         		tmp_status;
   mos_msg_attr_t         		msg_attributes;
   mos_msg_buf_t    	                msg_buf;

   while (GOOD_STATUS(status)) {

      /*
       * Retrieve messages.
       */
      mos_msg_dequeue(telcom_qh,
		      mos_c_deqmode_nowait,
		      NULL,            /* No selection criteria specified */
		      &msg_attributes,
		      &msg_buf,
		      status);

      if (GOOD_STATUS(status)) {
	 mos_msg_attr_msgid_get(msg_attributes, &msg_id, status);
	 uuid_to_string(&msg_id, &msg_id_string, &tmp_status);
	 datatype_string = telcom__datatype_show(msg_attributes,
						 msg_buf,
						 status);
	 if (GOOD_STATUS(status)) {
	     printf("Retrieved %s msg %s\n",
				  datatype_string,
				  msg_id_string);
	 }
	 rpc_string_free(&msg_id_string, &tmp_status);
	 mos_msg_attr_free(&msg_attributes, &tmp_status);
	 mos_msg_buf_free(&msg_buf, &tmp_status);
      }
      else if (*status == mos_empty_queue) {
	 printf("\nEmpty queue; No msgs to retrieve\n");
	 *status = 0;
	 break;
      } else if (*status == mos_item_not_found) {
	 printf("\nNo more msgs to retrieve\n");
	 *status = 0;
	 break;
      } else {
	 printf("\nError retrieving msg: %d\n", *status);
      }

   } /* End of loop thru all messages */

} /* End of telcom__deq_all_msgs() */


char *
telcom__datatype_show(mos_msg_attr_t       msg_attributes,
		      mos_msg_buf_t        msg_buf,
		      error_status_t *     status)
{
    error_status_t              tmp_status;
    uuid_t                      msg_datatype;
    unsigned_char_t *           msg_id_string;
    telcom_datatype_charge_t    charge_msg_buf;
    telcom_datatype_mwi_t       mwi_msg_buf;
    mos_datatype_ack_t          ack_msg_buf;

    mos_msg_attr_datatype_get(msg_attributes, &msg_datatype, &tmp_status);
    if (uuid_equal(&msg_datatype, &charge_id, &tmp_status)) {
	mos_msg_datatype_decode(&charge_id,
				msg_buf,
				&charge_msg_buf,
				status);
	if (GOOD_STATUS(status)) {
	   printf("\n\t Calling Party: %s\n", charge_msg_buf.calling_party);
	   printf("\t Called Party: %s\n", charge_msg_buf.called_party);
	   printf("\t Duration: %d\n", charge_msg_buf.duration);
	   printf("\t Cost: %d\n", charge_msg_buf.cost);
	   /* Release allocated parts of charge message */
	   free(charge_msg_buf.calling_party);
	   free(charge_msg_buf.called_party);
	}
	return("CHARGE");
    }
    if (uuid_equal(&msg_datatype, &mwi_id, &tmp_status)) {
	mos_msg_datatype_decode(&mwi_id,
				msg_buf,
				&mwi_msg_buf,
				status);
	if (GOOD_STATUS(status)) {
	   printf("\n\t Phone Number: %s\n", mwi_msg_buf.phone_number);
	   printf("\t MWI Indicator: %d\n", mwi_msg_buf.mwi_status);
	   /* Release allocated parts of mwi message */
	   free(mwi_msg_buf.phone_number);
	}
	return("MWI");
    }
    if (uuid_equal(&msg_datatype, &mos_datatype_ack, &tmp_status)) {
	mos_msg_datatype_decode(&mos_datatype_ack,
				msg_buf,
				&ack_msg_buf,
				status);
	if (GOOD_STATUS(status)) {
	   uuid_to_string(&ack_msg_buf.msg_id, &msg_id_string, &tmp_status);
	   printf("\n\t Notice on msg: %s\n", msg_id_string);
	   printf("\t Notice option: %d\n", ack_msg_buf.notice_option);
	   printf("\t Status: %d\n", ack_msg_buf.status);
	   rpc_string_free(&msg_id_string, &tmp_status);
	}
	return("ACK");
    }
    if (uuid_is_nil(&msg_datatype, &tmp_status)) {
	printf("\n\t Array: %s\n", msg_buf->data);
	return("ARRAY OF BYTES");
    }

    return("UNKNOWN");

} /* End of telcom__datatype_to_string() routine */


void
telcom__done(error_status_t *      status)
{

   /*
    * Free message attributes
    */
   mos_msg_attr_free(&charge_msg_attr,
		     status);
   mos_msg_attr_free(&mwi_msg_attr,
		     status);

   /*
    * Delete telcom queue
    */
   mos_que_mgmt_delete(mos_c_delop_force,
		       &telcom_qh,
		       status);

   /*
    * Exit MOS
    */
   mos_done(status);

} /* End of telcom__done() */

4.0 Future Enhancements

    4.1 Support Message Passing Model.

	In a message passing model, a source peer application sends
	messages to the destination peer application. The destination
	peer application must be available since there is no queuing
	performed by MOS. In a message queuing model, a source peer
	application sends messages to a queue manager/queue regardless if
	the destination peer application is available.

	With a future MOS-API, a distributed application can use either
	messaging model or both. We can envision that a distributed
	application may initially use a message passing model for
	one aspect of communication and a message queuing model for
	another.

	In the message passing model, a recipient looks like a DCE server.
	Whether we hide this fact or not is still under discussion.

	We have done some experiments and found that we can acheive a
	two-way channel bewteen a sender and recipient in the message
	passing model. This is done by building both sender and recipient
	applications with each others stub code and IDL interface. In
	addition, the sender application must register the interface with
	the RPC runtime via "rpc_server_register_if()".


    4.2 Performance Gain with Protection Level bewteen Clients and
	Queue Managers.

	If the Q-mgr is on the same host as the client, the send/retrieve
	APIs may ignore the end-to-end protection level requested by
	the client and set the protection level bewteen client and
	Q-mgr to "none". This allows better performance.


    4.3 Allow multiple combinations in one Selection Filter.

	Combinations like:

	      ((data type = 05 and priority of 1) ||
	       (data type = 01 and priority of 2))

	Circumvention:
	      Multiple combinations described above can be acheived
	      with our API by invoking a retrieve operation with
		   (data type = 05 and priority of 1)
	      then invoke another retrieve operation with
		   (data type = 01 and priority of 2)
	      or by creating two threads to do the same.


    4.4 Allow message attributes to be changed once enqueued.

	Once a message and its corresponding message attributes are sent,
	neither the message nor its message attributes can be modified.

	However in the message queuing model, allow message attributes to
	be changed once enqueued.


    4.5 Provide API support to obtain information from a notice message type.

	Refer to Section 2.6 ACK/NAK message type description.


    4.6 Support cancelling messages.

       Defer mos_msg_cancel() and mos_mcast_cancel(). There are issues
       that this feature does not fit into the DCE security model.

       4.6.1 mos_msg_cancel()

	     Cancel one message previously sent via mos_msg_enqueue().
	     This API applies only to the message queuing model.

	     In a message delivery cancel, there are no guarantees that a
	     message was deleted.  For instance, the message may have
	     already been retrieved when the cancel request was sent.

	   4.6.1.1 mos_msg_cancel() Synopsis

	     void
	     mos_msg_cancel(
		       [in] mos_handle_t            resource_handle,
		       [in] uuid_t *                msg_id,
		       [out] error_status_t *       status
		       );

	      where
		resource_handle:
		    A context handle to a resource.

		msg_id:
		    Use mos_msg_attr_msgid_get() to obtain the message ID
		    in the message attributes of the message sent via
		    mos_msg_enqueue().

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	   4.6.1.2 mos_msg_cancel() Internal Description

		Using the message ID specified, the API attempts to delete
		the message from the specified queue. Note that there are
		no attempts to track a message that may still be in a
		thread in the local runtime. If the request to delete the
		specified message no longer exists, then an error message
		is returned.

		First, the Q-mgr ensures that the principal making the
		cancel request has "cancel" permission on the queue.
		Next, the Q-mgr verifies that the principal who
		requested a particular message to be cancelled is the
		same principal who sent the original message. This is
		achieved by comparing principal UUIDs from the client's
		PAC on the authenticated RPC and the security identity
		stored on the message. In addition, the Q-mgr ensures that
		the principal has "cancel" permission on the queue.


       4.6.2 mos_mcast_cancel()

	     Cancel a multicast associated with a group.
	     This API applies only to the message queuing model.

	     In a group delivery cancel, there are no guarantees that a
	     message was deleted from all members of the group. For
	     instance, three of six group members may have already
	     retrieved the message when a cancel request was sent.

	   4.6.2.1 mos_mcast_cancel() Synopsis

	     void
	     mos_mcast_cancel(
		       [in] unsigned_char_t *       group_name,
		       [in] uuid_t *                msg_id,
		       [out] error_status_t *       status
		       );

	      where
		group_name:
			 Specifies a NSI group name.

		msg_id:
		    Use mos_msg_attr_msgid_get() to obtain the message ID
		    in the message attributes of the message sent via
		    mos_mcast().

		status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	   4.6.2.2 mos_mcast_cancel() Internal Description

		Using the message ID specified, the API attempts to delete
		the message from all members of the group. If the request
		to delete the specified message no longer exists on any
		member of the group, then it is ignored.


	4.6.3 During "cancel" message request, track messages in local runtime.

	    In a message delivery cancel, there are no guarantees that a
	    message was deleted. Refer to Section 2.3.3.

	    We can provide a little more "guarantee" by attempting to track a
	    message that may still be in a thread in the local runtime and
	    not yet sent to the Q-mgr. However, a message may still not be
	    cancelled since it may have already been retrieved when the cancel
	    request was sent.

	    The "value" of this work is still under discussion.




    4.7 Support additional naming APIs.

       *Provide APIs to return a handle to a member from a group handle.
	"resource_handle_to_group" has all the binding information to
	each member of the group. Why allow the caller to get a particular
	member again via mos_rsrc_attach().

       *Low priority. Defer:  mos_entry_object_list()
			      mos_group_mbr_list()
			      mos_profile_mbr_list()

	Change these routines so that the caller allocates suffient space.
	Refer to APIs: mos_que_mgmt_quename_list()
		       mos_que_mgmt_msgid_list()

       4.7.1 mos_entry_object_list()

	   Combination of the following APIs:
	       mos_entry_object_inq_begin()
	       mos_entry_object_inq_next()
	       mos_entry_object_inq_done()
	   to return a list of all object IDs in the specified name
	   service entry.

	   4.7.1.1 mos_entry_object_list() Synopsis

	     void
	     mos_entry_object_list(
			   [in] unsigned_char_t *    entry_name,
			   [out] unsigned32 *        object_id_nbr,
			   [out] mos_obj_id_t **     object_id_list,
			   [out] error_status_t *    status
			   );

	     where
		 entry_name:
		       Specifies entry name to view.

		 object_id_nbr:
			 Number of Object IDs in list.

		 object_id_list:
			 List of Object IDs stored in name service entry.
			 Application is responsible for allocating enough
			 space for the list.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	   4.7.1.2 mos_entry_object_list() Internal Description

	       The following APIs will be called:
		   mos_entry_object_inq_begin()
		   mos_entry_object_inq_next()
		   mos_entry_object_inq_done()
	       to return a list of all object IDs in the specified name
	       service entry.


       4.7.2 mos_group_mbr_list()

	     Returns a list of all members from a group.

	   4.7.2.1 mos_group_mbr_list() Synopsis

	     void
	     mos_group_mbr_list(
			   [in] unsigned_char_t *    group_name,
			   [out] unsigned32 *        member_name_nbr,
			   [out] unsigned_char_t **  member_name_list,
			   [out] error_status_t *    status
			   );

	     where
		 group_name:
		       Specifies group name to view.

		 member_name_nbr:
			 Number of member names in list.

		 member_name_list:
			 List of member names in specified group.
			 Application is responsible for allocating enough
			 space for the list.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.


	   4.7.2.2  mos_group_mbr_list() Internal Description

	     This function will call the following APIs to return a list
	     of group member names:
				 mos_group_mbr_inq_begin()
				 mos_group_mbr_inq_next()
				 mos_group_mbr_inq_done()


       4.7.3 mos_profile_mbr_list()

	     Combination of the following APIs:
		 mos_profile_mbr_inq_begin()
		 mos_profile_mbr_inq_next()
		 mos_profile_mbr_inq_done()
	     to return a list of all profile member names
	     from the specified profile.

	   4.7.3.1 mos_profile_mbr_list() Synopsis

	     void
	     mos_profile_mbr_list(
			   [in] unsigned_char_t *     profile_name,
			   [out] unsigned32 *         member_name_nbr,
			   [out] unsigned_char_t **   member_name_list,
			   [out] error_status_t *     status
			   );

	     where
		 profile_name:
		       Specifies profile name to view.

		 member_name_nbr:
		       Number of member names in list.

		 member_name_list:
		       List of member names in the specified profile.
		       Application is responsible for allocating enough
		       space for the list.

		 status:
		    A pointer to the completion status. On successful
		    completion, the routine returns error_status_ok.
		    Otherwise, it returns an error.

	   4.7.3.2  mos_profile_mbr_list() Internal Description

	     This function will call the following APIs to return the list:
				 mos_profile_mbr_inq_begin()
				 mos_profile_mbr_inq_next()
				 mos_profile_mbr_inq_done()



5.0 Revision History

    Version             Date                Comments
    --------------------------------------------------------------------
    Version 1.0         06/03/96            Initial outline.

    Version 1.1         06/24/96            Initial version.

    Version 1.2         06/26/96            Modifications made:
					    - General:
					      Reword default data type is
					      "array of bytes" not "string"
					    - Section 2.3:
					      Distinguish bewteen
					      communication mode and
					      blocking mode. Changed APIs
					      accordingly.
					    - Section 2.4.1.2:
					      Set time stamp for multicast.
					    - Section 2.5.4:
					      Modified gms_sec_id_t to include
					      both prin and grp UUIDs.
					    - Section 2.6:
					      Define an explicit
					      "register datatype" API.
					    - Section 2.7:
					      Added 1 notice option:
						gms_c_msg_attr_notice_enqueue
					      Changed default priority to
						gms_c_msg_attr_dflt_priority

    Version 1.3         06/27/96            Modifications made:
					    -Section 2.7:
					     Added another persistent type:
					     gms_c_msg_attr_pv_both
					    -Section 2.8:
					     Added more queue utilities.

    Version 1.4         07/09/96            Modifications made:
					    - Section 2.3:
					      Distinguish bewteen
					      comm_mode, enq_mode,
					      and deq_mode. Changed APIs
					      accordingly.
					    - Section 2.4.1:
					      Notice options ignored on
					      group send.
					      Removed comm_mode and
					      blocking mode for same reason.
					    - Section 2.7:
					     *Message IDs generated by send
					      API operations.
					     *Changed default priority to
					      arbitriary value in middle.
					     *Changed notice options:
					      Removed:
						gms_c_msg_attr_notice_expire
						gms_c_msg_attr_notice_error
					      These events will be part of
						gms_c_msg_attr_notice_dequeue
					      Added:
						gms_c_msg_attr_notice_mp_ack
					    - Section 2.8:
					      Removed "dequeue order" API.

    Version 1.5         07/17/96            Modifications made:
					    - Section 2.0:
					      Removed macros:
					       gns_mgmt_server_prin_name_get()
					       gns_auth_info_set()
					      Add APIs:
					       gms_msg_cancel()
					       gms_msg_attr_sec_protectlvl_get()
					       gms_msg_attr_sec_protectlvl_set()
					    - Section 2.1.1:
					      Added an intro section.
					      Added security_info parameter
					      for the security group when
					      finding and authenticating
					      resources.
					      Added model_type parameter.
					      Validate CDS binding with
					      security group.
					      In MQ model, set authz, authn,
					      & default protection level in
					      init().
					    - Section 2.2.1:
					      Added security_info parameter
					      for the security group when
					      finding and authenticating
					      resources.
					    - Section 2.3.1.2 & 2.3.2.2:
					      Added desc for end-to-end
					      protection level.
					    - Section 2.3.2:
					      Added end-to-end protection
					      level as selection criteria
					      for recipient.
					    - Section 2.3.3:
					      gms_msg_cancel() description
					    - Section 2.3.4.1:
					      Changed parameter deq_mode for
					      gms_msg_attr_recv().
					    - Section 2.4.2:
					      Stated no guarantees in mcast
					      cancel.
					    - Section 2.5:
					      Applies only to message queuing:
					       gms_auth_info_set()
					      Added detail for:
					       gms_msg_attr_sec_protectlvl_get()
					       gms_msg_attr_sec_protectlvl_set()
					    - Section 2.7:
					      Added message attribute:
					       sender's protection_level
					      with description.
					    - Section 3.0:
					      Updated sample application code
					      examples.
    Version 1.6         07/19/96           Modifications made:
					    - Section 2.0:
					      Added macros:
					       gns_mgmt_server_prin_name_get()
					       gns_auth_info_set()
					      Added APIs:
					       gms_sel_filter_alloc()
					       gms_sel_filter_free()
					       gms_sel_mask_set()
					      Removed APIs:
					       gms_msg_attr_msgid_set()
					    - Section 2.5.3:
					       gns_auth_info_set() may be used
					       by both models.
					    - New Section 2.9
					      Selection filter details
					    - Section 2.3.2 and 2.3.4:
					      After every retrieve operation,
					      caller must free the message
					      attributes returned.
					    - Section 2.7:
					      Removed gms_msg_attr_msgid_set()
					      An application is not allowed
					      to generate its own message IDs.
					    - Section 3.2:
					      Updated sample application code
					      examples. telcom_client.c uses
					      a selection filter.

    Version 1.7         08/19/96            Modifications made after MQ group
					    review, outstanding issues resolved
					    from formal review, & resolved
					    Naming issues:
					    - General:
					      error_status_t for status.
					      uuid_t for msgid, datatype, qid.
					      utc_t for ttl, ttr, timestamps.
					      unsigned_char_t for names.
					      Opaque ptrs: not "_p_t".

					      Provide valid values for name
					      service syntax constants.

					    - Section 2.0
					      *Removed gms_init();
					       gms_rsrc_attach() is sufficient.

					      Defined "resource".

					      Renamed macros:
					       gms_sec_server_prin_name_get()
					       gms_sec_auth_info_set()
					       gms_sec_auth_info_get()

					      Renamed APIs
					       gms_api_datatype_register()

					    - Section 2.2:
					      *Define protection levels as
					       they apply to MQ model.

					      *Added more clarity to
					       gms_rsrc_attach().

					      *If msg passing model, allow
					       principal or group name to
					       be specified in
					       gms_rsrc_attach().

					      *Added APIs:
					       gms_rsrc_detach().

					      *Defer APIs to Section 4.0 Future:
						 gns_entry_object_list_get()
						 gns_group_mbr_list_get()
						 gns_profile_mbr_list_get()

					     -Section 2.3:
					      *Consolidated "Conversion
					       Management" section with
					       "Multicast" section.

					      *Added APIs:
						 gms_msg_move()

					      *Renamed APIs:
						 gms_mcast_send()

					      *Combined enq_mode, deq_mode,
					       and comm_mode into one
					       "flags" parameter on
					       gms_msg_send().

					      *Added msg_id output parameter
					       to send APIs. And chged
					       msg_attributes parameter from
					       [in,out] to [in] parameter.

					      *Stated async/nowait as default
					       during multicast.

					     -Section 2.4:
					      *For security identity, a
					       principal may belong to multiple
					       groups.

					      *gms_sec_auth_info_set() applies
					       only to MP model.

					      *Renamed APIs:
					       gms_msg_attr_protectlvl_get()
					       gms_msg_attr_protectlvl_set()
					       gms_msg_attr_secid_get()

					      *Use "sec_id_pa_t" as parameter
					       to gms_msg_attr_secid_get().

					     -Section 2.5:
					      Added more description about
					      application-specific data types.

					     -Section 2.6:
					      *State that once msg sent,
					       msg attributes can NOT be
					       modified.

					      *State "API ACCESS" on all
					       message attributes.

					      *Removed msg type constant:
						 gms_c_msg_attr_msgtype_any

					      *Added APIs:
						 gms_msg_attr_enqtime_get()

					      *Removed APIs:
						 gms_msg_attr_msglen_get()

					      *Renamed APIs:
						 gms_msg_attr_peek()

					      *Described msg ttl and ttr
					       defaults. Default msg ttl is
					       24 hours.

					     -Section 2.7:
					      *Renamed APIs:
						 gms_msg_selfilter_alloc()
						 gms_msg_selfilter_free()
						 gms_msg_selmask_set()

					      * Added mask type:
						 gms_c_mask_type_ttr

					     -Section 2.8:
					      *Added queue attributes:
						 queue aliases
						 queue annotation
						 queue idle timeout
						 queue current length
						 persistence
						 Allow enqueue
						 Allow dequeue
						 creation time stamp
						 last modification time stamp

					      *Removed queue attributes:
						 queue owner

					      *State "API ACCESS" on all
					       queue attributes.

					      *Added APIs:
						 gms_que_attr_qlen_get()
						 gms_que_attr_createtime_get()
						 gms_que_attr_activetime_get()
						 gms_que_attr_qalias_add()
						 gms_que_attr_qalias_remove()
						 gms_que_attr_qalias_list_get()
						 gms_que_attr_qdesc_get()
						 gms_que_attr_qdesc_set()
						 gms_que_attr_persistence_get()
						 gms_que_attr_persistence_set()
						 gms_que_attr_idletimeout_get()
						 gms_que_attr_idletimeout_set()
						 gms_que_attr_allowenq_get()
						 gms_que_attr_allowenq_set()
						 gms_que_attr_allowdeq_get()
						 gms_que_attr_allowdeq_set()

					      *Table describes how a msg
					       is stored based on the
					       persistence attribute of both
					       the queue and the msg itself.

					      *Renamed APIs:
						 gms_que_attr_commit()
						 gms_que_attr_peek()

					      *Added annotation parameter to:
						 gms_que_attr_qname_get()
						 gms_que_attr_qname_set()

					     -Section 2.9:
					      New section for Queue Management
					      Utilities.

					      *Added APIs:
						 gms_que_mgmt_save()

					      *Renamed APIs:
						 gms_que_mgmt_create()
						 gms_que_mgmt_delete()
						 gms_que_mgmt_move()
						 gms_que_mgmt_qcount_get()
						 gms_que_mgmt_qname_list_get()
						 gms_que_mgmt_msgid_list_get()

					      *Added Q-mgr handle and
					       queue annotation as input
					       parameters and chged queue
					       attr parameter from [in,out]
					       to [in] on gms_que_mgmt_create().

					      *Added more implementation
					       detail when creating, deleting,
					       and moving queues.

					      *State that gms_que_mgmt_move()
					       does a move or rename. Specify
					       source queue as a handle.
					       Added "referral" parameter.

					      *Handle space constraints for
					       variable-length lists:
						 gms_que_mgmt_qname_list_get()
						 gms_que_mgmt_msgid_list_get()

					     -Section 2.10:
					      Added sender's principal name
					      as a selection criteria.

					     -Section 4.0:
					      New section for Future
					      Enhancements.


    Version 1.8         08/22/96            Minor Modifications:
					    -General:
					      *Stated where appropriate that
					       single queue operations do
					       not allow NSI groups or profiles.

					    -Section 2.2:
					      *Again, defined protection
					       levels as they apply to
					       MQ & MP models.

					      *Refer to OT 13614 in
					       gms_rsrc_attach() desc.

					     -Section 2.6:
					      *Changed notice_destination
					       parameter to a name:
						gms_msg_attr_notice_get()
						gms_msg_attr_notice_set()

					      *Stated that when message or
					       queue expiration timeouts occur,
					       Q-mgr is free to delete the
					       object at any time thereafter.

					     -Section 2.8:
					      *Added link name as input
					       parameter to APIs:
						gms_que_attr_qalias_add()
						gms_que_attr_qalias_remove()

					      *Removed APIs:
						gms_que_attr_qname_get()
						gms_que_attr_qname_set()
					       First entry is the queue name
					       itself:
						gms_que_attr_qalias_list_get()
					       To change qname, use
						gms_que_mgmt_move().

					     -Section 2.9:
					      *Removed queue annotation as
					       input parameter to
					       gms_que_mgmt_create().

    Version 1.9         09/11/96            Modifications after formal review
					    open to all of OSF on 08/29 and
					    the usual daily flow of comments:

					    -General:
					     "mos" is now used as a DCE
					     acronym/svc-component. Remove
					     all references to "gms" and "gns".

					    -Section 1.0:
					     Updated the Introduction.

					    -Section 2.2:
					     *Removed APIs:
					      gns_entry_object_inq_begin()
					      gns_entry_object_inq_next()
					      gns_entry_object_inq_done()
					      gns_group_mbr_inq_begin()
					      gns_group_mbr_inq_next()
					      gns_group_mbr_inq_done()
					      gns_profile_mbr_inq_begin()
					      gns_profile_mbr_inq_next()
					      gns_profile_mbr_inq_done()
					      gns_handle_import_begin()
					      gns_handle_import_next()
					      gns_handle_import_done()
					      gns_handle_resolve()
					      gns_mgmt_handle_exp_age_set()
					      gns_mgmt_exp_age_set()
					      gns_mgmt_exp_age_get()

					     *Added APIs:
					      mos_rsrc_dflt_quemgr_get()
					      mos_rsrc_dflt_quemgr_set()
					      mos_rsrc_group_attach()
					      mos_rsrc_group_detach()
					      mos_rsrc_group_create()
					      mos_rsrc_group_delete()
					      mos_rsrc_group_mbr_add()
					      mos_rsrc_group_mbr_remove()
					      mos_rsrc_group_mbr_list()
					      See Section 4.7 1st paragraph.

					     *Hardwire rpc_c_ns_syntax_default.
					      Remove name_syntax parameters
					      from all applicable APIs.

					     *Added environment variable:
					      MOS_DFLT_QUEMGR_NAME

					    -Section 2.3:
					     *Renamed APIs:
					      mos_msg_dequeue()
					      mos_msg_enqueue()
					      mos_msg_group_enqueue()

					     *Added APIs:
					      mos_msg_delete()
					      mos_msg_peek()

					     *Renamed flags:
						mos_c_enqmode_async
						mos_c_enqmode_sync
						mos_c_enqmode_nowait_enq
						mos_c_enqmode_wait_enq
						mos_c_enqmode_wait_deq
						mos_c_deqmode_nowait
						mos_c_deqmode_wait

					     *mos_c_enqmode_sync applies
					      only to message passing model.

					     *Removed mos_msg_copy_t parameter
					      from mos_msg_dequeue().

					     *Removed flags parameter from
					      mos_msg_move(). Sync operation
					      only.

					     *Use handle parameter instead
					      of group name parameter on
					      mos_msg_group_enqueue().

					    -Section 2.4:
					     *Added intro section

					     *Removed Security APIs(for MP only)
						mos_sec_auth_info_get()
						mos_sec_server_prin_name_get()
						mos_sec_auth_info_set()

					    -Section 2.6:
					     *Added 2 notice options again:
					      mos_c_msg_attr_notice_expire
					      mos_c_msg_attr_notice_exception

					    -Section 2.7:
					     *Added mos_c_mask_op_none to
					      mos_msg_selmask_op_t. Explained
					      what API expects for mask_value.

					     *Added security parameter:
						mos_msg_attr_notice_get()

					     *Added security name and handle
					      parameter:
						mos_msg_attr_notice_set()

					    -Section 2.8:
					     *Added another queue persistence
					      type to indicate that msg
					      persistence dicates. This is the
					      new queue persistence default.

					     *Added APIs:
					      mos_que_attr_msgmaxsize_get()
					      mos_que_attr_msgmaxsize_set()
					      mos_que_attr_alias_reset()

					     *Renamed APIs:
					      mos_que_attr_queid_get()
					      mos_que_attr_quecursize_get()
					      mos_que_attr_quemaxsize_get()
					      mos_que_attr_quemaxsize_set()
					      mos_que_attr_alias_list()
					      mos_que_attr_alias_add()
					      mos_que_attr_alias_remove()
					      mos_que_attr_annotation_get()
					      mos_que_attr_annotation_set()

					     *Added new types:
					      mos_que_attr_name_t
					      mos_que_attr_annotation_t

					     *Changed name parameters to
					      mos_que_attr_name_t:
						mos_que_attr_alias_list()
						mos_que_attr_alias_add()
						mos_que_attr_alias_remove()

					     *Changed name parameters to
					      mos_que_attr_annotation_t:
						mos_que_attr_annotation_get()
						mos_que_attr_annotation_set()

					    -Section 2.9:
					     *Renamed APIs:
					      mos_que_mgmt_quecount_get()
					      mos_que_mgmt_quename_list()
					      mos_que_mgmt_msgid_list()

					     *msg_id_list is an array of
					      uuids: mos_que_mgmt_msgid_list()

					     *que_name_list is an array of
					      queue names:
					      mos_que_mgmt_quename_list()

    Version 1.10        09/18/96            Modifications:

					    -General:
					    *sec_rgy_name_t for all security
					     name specifications.

					    *mos_rsrc_name_t for all resource
					     name specifications.

					    *Use boolean instead of boolean32.

					    *All list APIs work consistently:
					     mos_rsrc_group_mbr_list()
					     mos_que_attr_alias_list()
					     mos_que_mgmt_quename_list()
					     mos_que_mgmt_msgid_list()
					     All make caller alloc space.

					    *All time APIs work consistently:
					     mos_msg_attr_enqtime_get()
					     mos_msg_attr_ttl_get/set()
					     mos_msg_attr_ttr_get/set()
					     mos_que_attr_idletimeout_get/set()
					     mos_que_attr_createtime_get()
					     mos_que_attr_activetime_get()
					     All use utc_t to specify time.

					    -Section 2.6:
					     *Removed 2 notice options again:
					      mos_c_msg_attr_notice_expire
					      mos_c_msg_attr_notice_exception
					      For reliability purposes, apps
					      need both ACKs and NAKs; not
					      just NAKs.

					     *mos_msg_attr_ttl_get/set()
					      mos_msg_attr_ttr_get/set()
					      Only absolute time allowed.

					    -Section 2.8:
					     *Removed boolean values; use
					      TRUE and FALSE:
					       mos_c_que_attr_enq_on
					       mos_c_que_attr_enq_off
					       mos_c_que_attr_deq_on
					       mos_c_que_attr_deq_off

					     *mos_que_attr_idletimeout_get/set()
					      Only relative time allowed.

    Version 1.13        11/11/96            Modifications:

					    -General:
					     Added "status" parameter to
					     all _get() functions.

					     Handle is [in,out] parameter.
					     On out, pointer set to NULL.
					       mos_rsrc_detach()
					       mos_que_mgmt_delete()
					       mos_msg_attr_free()
					       mos_msg_selfilter_free()
					       mos_que_attr_free()

					     mos_handle_t is now
					     "struct mos_rsrc_info_s_t *"
					     not "void *"

					     mos_msg_selfilter_t is now
					     "struct mos_mask_list_s_t *"
					     not "void *"
					     _add() function using
					     mos_msg_selfilter_t chged.

					     mos_msg_attr_t is now
					     "struct mos_mattr_s_t *"
					     not "void *"
					     All _set() functions using
					     mos_msg_attr_t chged.

					     mos_que_attr_t is now
					     "struct mos_qattr_s_t *"
					     not "void *"
					     All _set() functions,
					     mos_que_attr_alias_add(),
					     mos_que_attr_alias_remove(),
					     mos_que_attr_alias_reset()
					     using mos_que_attr_t chged.

					    -Section 2.2:
					     mos_rsrc_dflt_quemgr_get()
					     A NULL resource handle indicates
					     handle not returned.

					    -Section 2.3:
					     "mos_msg_buf_t" and
					     "mos_msg_attr_t" are returned:
					       mos_msg_dequeue()
					       mos_msg_peek()

					    -Section 2.4:
					     New APIs:
					     mos_rsrc_protectlvl_get()
					     mos_rsrc_protectlvl_set()

					    -Section 2.5:
					     New APIs:
					     mos_api_datatype_unregister()

					    -Section 2.6:
					     Added to mos_datatype_ack_t

					    -Section 2.7:
					     Removed "nbr_of_masks" parameter
					     in mos_msg_selfilter_alloc().

					     Renamed mos_msg_selmask_set()
					     to mos_msg_selmask_add().

					    -Section 2.8
					     mos_que_attr_annotation_get()
					     annotation parmeter chged

					    -Section 2.9
					     mos_que_mgmt_move()
					      API parameters chged and
					      more doc on its operation.

					     mos_que_mgmt_msgid_list()
					      Removed cursor parameter.

					    -Section 3.2
					     Provided idl file support to
					     handle application-specfic
					     datatypes in telcom example.

    Version 1.14        11/21/96            Modifications:

					    -Section 2.2
					     Added more internal desc to
					     mos_rsrc_attach() and _detach().

					    -Section 2.3
					     Runtime allocates message buffer
					     in mos_msg_dequeue() and
					     mos_msg_peek(). Caller responsible
					     to free it.

					     Only one option is allowed to
					     be specified for "flags".

					    -Section 2.4
					     Added more desc concerning
					     end-to-end protectlvls and
					     resource protectlvls.

					    -Section 2.5
					     Added APIs:
					       mos_msg_datatype_decode()
					       mos_msg_buf_free()

					    -Section 2.6
					     mos_msg_attr_notice_set()
					     Implicit register of ACK

					     Document "mos_datatype-ack"
					     information.

					    -Section 2.8
					     mos_que_attr_alias_reset()
					     Queue name itself not reset.

					    -Section 3.0
					     Updated example programs.

    Version 1.15        12/03/96            Modifications:

					    -Section 3.2
					     Added API:
						mos_rsrc_name_get()
