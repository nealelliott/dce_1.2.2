/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1996 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 */
/*
 * HISTORY
 * $Log: with.c,v $
 * Revision 1.1.6.2  1996/02/18  19:30:44  marty
 * 	Update OSF copyright years
 * 	[1996/02/18  18:12:02  marty]
 *
 * Revision 1.1.6.1  1995/12/08  15:12:17  root
 * 	Submit OSF/DCE 1.2.1
 * 	[1995/12/08  14:41:11  root]
 * 
 * Revision 1.1.4.3  1994/08/03  19:01:28  mccann
 * 	include file cleanup
 * 	[1994/07/19  17:43:38  mccann]
 * 
 * Revision 1.1.4.2  1994/06/09  18:37:54  devsrc
 * 	cr10871 - expand copyright
 * 	[1994/06/09  18:09:58  devsrc]
 * 
 * Revision 1.1.4.1  1994/03/12  22:01:24  peckham
 * 	DEC serviceability and i18n drop
 * 	[1994/03/12  14:07:45  peckham]
 * 
 * Revision 1.1.2.2  1992/12/30  13:26:48  zeliff
 * 	Embedding copyright notices
 * 	[1992/12/29  22:43:04  zeliff]
 * 
 * Revision 1.1  1992/01/19  15:20:21  devrcs
 * 	Initial revision
 * 
 * $EndLog$
 */
/*
 * COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1990-1994. ALL RIGHTS RESERVED.
 *
 * THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 * ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 * INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 * COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 * OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 * TRANSFERRED.
 *
 * THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 * AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 * CORPORATION.
 *
 * DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 * SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
 */

/* this module does most of the processing related to the WITH phrase. */
/* there is a with list containing attribute blocks. */
/* most of the cmds that work on the attr list also work on the with list. */
/* the exception is those that find the list header. */
/* before each command is processed, make the with list empty. */
/* while parsing the command, between the parsing of attributes and */
/* the parsing of the with phrases, remember the last attr on the attr list. */
/* the last one is the one before the head of the list. */
/* be sure to not change this pointer if there are several WITH phrases. */
/* with phrases can then be parsed the same as attributes that are to be */
/* modified by SET, ADD, or REMOVE commands. */
/* after parsing the command, but before dispatching to the code that */
/* executes the command, transfer the attribute records that correspond to */
/* WITH phrases from the attribute list to the with list. */
/* since the lists are double linked with a dummy header, it is easy */
/* to get the transfer right, even with one or two null sets. */
/* there is no need to supply a default WITH record if the list is empty. */
/* be sure to remove the with blocks before doing any special processing of */
/* an empty attribute list */

/* during parsing, WITH phrases are handled like other attribute phrases. */
/* during execution of the command, they are entirely different. */
/* each entity that is nominated (by being mentioned in the command, */
/* or by being generated by wildcard expansion) is matched against */
/* the entire with list. */
/* only by passing each test, ie failing none, is the entity selected. */
/* this is handled by the function selected_ent, currently in visit.c. */

#include <cdscp.h>
#include <prsdef.h>

static struct attrblk withbh;		/* head of the with list */
static struct attrblk *withnext 	/* ptr to last pre with blk */
			= &withbh;	/* not a constant */

struct attrblk *
withlist_pointer (void)			/* return ptr to head of with list */
{
    return(&withbh);			/* this particular static one */
}

void
withblock_init (			/* initialize any with block */
    struct attrblk *wbp)		/* ptr to the block */
{
    attrblk_init(wbp);			/* basically it is an attr block */
}

void
withhead_init (			/* initialize head of with list */
    struct attrblk *wbp)		/* ptr to the head block */
{
    attrblk_init(wbp);			/* basically it is an attr block */
    wbp->blkalloc = 0;			/* the list head is static, perm */
    return;				/* no value from void routine */
}

void
make_withlist_empty (
    struct attrblk *p)			/* ptr to head of with list */
{
    delete_attr_list(p);		/* use existing routine */
    withnext = &withbh;			/* avoid pointing into space */
    return;				/* no value from void routine */
}

int
after_this_is_with (			/* A PARSER ACTION ROUTINE */
    struct prs *pcbp)			/* ptr to parser context block */
{
    withnext = (get_attrblk_ptr())->bck;	/* this is not the with list */
    return(ACT_SUCCESS);
}

void
cut_after_paste_after_attr (
    struct attrblk *fromp,
    struct attrblk *top)
{
    /* fromp points to an attribute block, */
    /* but it might be the dummy block at the head of the list. */
    /* we are not interested in the block that fromp points to */
    /* take the 0 or more attrblks after fromp, and before the end/head. */
    /* top also points to an attribute block. */
    /* it also might be the dummy block at the head of a list */
    /* transfer the selected blocks from the first list to the second list. */
    /* insert them after the block that top points to, */
    /* and before whatever is next. */
    /* all the selected attributes are moved at once. */
    /* this takes some care. */

    struct attrblk *p;			/* loop control */

    if (fromp->fwd != fromp->head)
	{
	for (p=fromp->fwd; p != fromp->head; p=p->fwd)
	    p->head = top->head;	/* change pointer to head */
	fromp->head->bck->fwd		/* cut list fwd ptr */
	    = top->fwd;			/* hooks to insert point */
	top->fwd->bck			/* next after insert point */
	    = fromp->head->bck;		/* points back to inserted list */
	top->fwd = fromp->fwd;		/* fwd link into new list */
	fromp->fwd->bck = top;		/* back from inserted list to item */
	fromp->fwd = fromp->head;	/* with list gone, next is head */
	fromp->head->bck = fromp;	/* back link around cut out list */
	}
    return;				/* no value from void routine */
}

void
form_with_list (void)			/* transfer with blks from attr list */
{					/* to withblock list */
    cut_after_paste_after_attr(
	withnext,			/* ptr to attrblk before with blks */
	withlist_pointer());		/* ptr to where to to put them */
    return;				/* no value from void routine */
}
