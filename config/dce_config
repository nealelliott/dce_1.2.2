#!/bin/ksh
#
# @OSF_COPYRIGHT@
# COPYRIGHT NOTICE
# Copyright (c) 1990, 1991, 1992, 1993, 1996 Open Software Foundation, Inc.
# ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
# src directory for the full copyright text.
#
# HISTORY 
# $Log: dce_config,v $
# Revision 1.2.69.5  1996/10/15  20:44:18  arvind
# 	Don't complain about pkss on HP.
# 	[1996/10/04  16:11 UTC  psn  /main/DCE_1.2.2/psn_gg/3]
#
# 	Remove typo error.
# 	[1996/10/03  21:36 UTC  psn  /main/DCE_1.2.2/psn_gg/2]
#
# 	Do not install pkss_helper if international bits.
# 	[1996/10/03  21:01 UTC  psn  /main/DCE_1.2.2/psn_gg/1]
#
# Revision 1.2.69.4  1996/10/04  20:25:24  arvind
# 	OSF DCE 1.2.2 Drop 4
# 	[1996/10/04  20:24:46  arvind]
# 
# Revision /main/DCE_1.2.2/9  1996/09/23  21:52 UTC  arvind
# 	Do not try to install pkss_helper on HP-UX
# 	[1996/09/12  18:46 UTC  arvind  /main/DCE_1.2.2/arvind_pkss/1]
# 
# Revision /main/DCE_1.2.2/8  1996/09/09  21:17 UTC  arvind
# 	Fix call to config_pkss_clt
# 	[1996/09/09  18:54 UTC  arvind  /main/DCE_1.2.2/arvind_pkss_bl06/3]
# 
# 	PKSS drop from DEC
# 	[1996/09/04  21:17 UTC  arvind  /main/DCE_1.2.2/arvind_pkss_bl06/1]
# 
# 	Fix CRT CHFts19425: /opt/dcelocal/bin/rpcd was not created
# 	[1996/07/31  20:08 UTC  psn  /main/DCE_1.2.2/psn_bugfix/2]
# 	#
# 	Fix OT 13573: dce_config doesn't install DCE headers
# 	[1996/07/19  20:06 UTC  psn  /main/DCE_1.2.2/psn_bugfix/1]
# 	#
# 	Merge from cuti_pk_export to DCE_1.2.2
# 	[1996/06/30  21:59 UTC  cuti  /main/DCE_1.2.2/3]
# 	#
# 	config_krb5client: insert missing '=' sign in /etc/krb5.conf domain_realm section.
# 	[1996/06/27  19:09 UTC  mullan_s  /main/DCE_1.2.2/mullan_dce122_bugs_1/2]
# 	#
# 	config_sec: call config_krb5client *after* changing cell_admin password
# 	in rgy_init.
# 	[1996/06/14  20:42 UTC  mullan_s  /main/DCE_1.2.2/mullan_dce122_bugs_1/1]
# 	#
# 	Set mods on /krb5/krb.realms to 644.
# 	Link /etc/v5srvtab to /krb5/srvtab.
# 	Ask user (or use env. var) for domain name if cannot be
# 	automatically determined.
# 	[1996/05/30  21:14 UTC  mullan_s  /main/DCE_1.2.2/1]
# 	#
# 	Merge krb5 work to DCE1.2.2 mainline
# 	[1996/05/30  20:07 UTC  arvind  /main/mullan_dce1.2.2_krb5_drop/2]
# 	#
# 	Use LIST variable to install rutils.
# 	[1996/05/30  20:04 UTC  mullan_s  /main/mullan_dce1.2.2_krb5_drop/2]
# 	#
# 	Use LIST variable to install rutils.
# 	[1996/05/29  20:28 UTC  mullan_s  /main/mullan_dce1.2.2_krb5_drop/1]
# 	#
# 	Incorrect /etc/resolv.conf parsing to get domain name.
# 	[1996/05/16  16:59 UTC  mullan_s  /main/DCE_1.2/mullan_dce_k5_bsd44_rutils/2]
# 	#
# 	Add support for creation of bare-bones /etc/krb5.conf file
# 	[1996/05/03  13:48 UTC  mullan_s  /main/DCE_1.2/mullan_dce_k5_bsd44_rutils/1]
# 	#
# 	Add config_krb5() for krb5 rutil and client configuration
# 	[1996/01/29  17:17 UTC  psn  /main/DCE_1.2/4]
# 	#
# 	Install dced_acl_patcher.
# 	[1996/01/24  23:16 UTC  psn  /main/DCE_1.2/3]
# 	#
# 	Fix DCE_ETC install time setting.
# 	[1996/01/03  19:05 UTC  psn  /main/DCE_1.2/1]
# 	#
# 
# 	Merge from cuti_pk_export to DCE_1.2.2
# 	[1996/06/27  19:44 UTC  cuti  /main/DCE_1.2.2/cuti_pk_export/2]
# 
# 	Put sticky bit back for pk_file
# 	[1996/06/27  13:50 UTC  cuti  /main/DCE_1.2.2/cuti_pk_export/1]
# 
# 	Add /var/security/pk_file
# 	[1996/06/14  21:02 UTC  mullan_s  /main/DCE_1.2.2/2]
# 
# 	Merge to DCE 1.2.2
# 	[1996/06/14  20:42 UTC  mullan_s  /main/DCE_1.2.2/mullan_dce122_bugs_1/1]
# 
# 	Set mods on /krb5/krb.realms to 644.
# 	Link /etc/v5srvtab to /krb5/srvtab.
# 	Ask user (or use env. var) for domain name if cannot be
# 	automatically determined.
# 	[1996/05/30  21:14 UTC  mullan_s  /main/DCE_1.2.2/1]
# 
# 	Merge krb5 work to DCE1.2.2 mainline
# 	[1996/05/30  20:07 UTC  arvind  /main/mullan_dce1.2.2_krb5_drop/2]
# 
# 	Use LIST variable to install rutils.
# 	[1996/05/30  20:04 UTC  mullan_s  /main/mullan_dce1.2.2_krb5_drop/2]
# 
# 	Use LIST variable to install rutils.
# 	[1996/05/29  20:28 UTC  mullan_s  /main/mullan_dce1.2.2_krb5_drop/1]
# 
# 	Incorrect /etc/resolv.conf parsing to get domain name.
# 	[1996/05/16  16:59 UTC  mullan_s  /main/DCE_1.2/mullan_dce_k5_bsd44_rutils/2]
# 
# 	Add support for creation of bare-bones /etc/krb5.conf file
# 	[1996/05/03  13:48 UTC  mullan_s  /main/DCE_1.2/mullan_dce_k5_bsd44_rutils/1]
# 
# 	Add config_krb5() for krb5 rutil and client configuration
# 	[1996/01/29  17:17 UTC  psn  /main/DCE_1.2/4]
# 
# 	Install dced_acl_patcher.
# 	[1996/01/24  23:16 UTC  psn  /main/DCE_1.2/3]
# 
# 	Fix DCE_ETC install time setting.
# 	[1996/01/03  19:05 UTC  psn  /main/DCE_1.2/1]
# 
# 	Merge krb5 work to DCE1.2.2 mainline
# 	[1996/05/30  20:07 UTC  arvind  /main/mullan_dce1.2.2_krb5_drop/2]
# 
# 	Use LIST variable to install rutils.
# 	[1996/05/30  20:04 UTC  mullan_s  /main/mullan_dce1.2.2_krb5_drop/2]
# 
# 	Use LIST variable to install rutils.
# 	[1996/05/29  20:28 UTC  mullan_s  /main/mullan_dce1.2.2_krb5_drop/1]
# 
# 	Incorrect /etc/resolv.conf parsing to get domain name.
# 	[1996/05/16  16:59 UTC  mullan_s  /main/DCE_1.2/mullan_dce_k5_bsd44_rutils/2]
# 
# 	Add support for creation of bare-bones /etc/krb5.conf file
# 	[1996/05/03  13:48 UTC  mullan_s  /main/DCE_1.2/mullan_dce_k5_bsd44_rutils/1]
# 
# 	Add config_krb5() for krb5 rutil and client configuration
# 	[1996/01/29  17:17 UTC  psn  /main/DCE_1.2/4]
# 
# 	Install dced_acl_patcher.
# 	[1996/01/24  23:16 UTC  psn  /main/DCE_1.2/3]
# 
# 	Correct the test clause.
# 	[1996/01/24  00:17 UTC  psn  /main/DCE_1.2/final_1.2.1_merge/1]
# 
# 	Fix DCE_ETC install time setting.
# 	[1996/01/03  19:05 UTC  psn  /main/DCE_1.2/1]
# 
# 	Fix a test..
# 	[1995/12/04  22:35 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/8]
# 
# 	Install sec_salvage_db
# 	[1995/11/17  20:30 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/7]
# 
# 	Fix $BINDING for configuring gda.
# 	[1995/11/17  17:12 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/5]
# 
# 	DCE 1.2.1 merge w/ CDS
# 	[1995/11/16  21:20 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/4]
# 
# 	DCE 1.2.1 merged config w/o CDS.
# 	[1995/11/13  21:59 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/3]
# 
# 	Config now succeeds with secd and cdsd server configuration.
# 	[1995/11/10  17:23 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/2]
# 
# 	Add in support for new libraries.
# 	[1995/11/10  14:10 UTC  jrr  /main/DCE1_1_WP/jrr_1.2_mothra/1]
# 
# 	Config that works until acl setting.
# 	[1995/11/10  14:09 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/1]
# 
# 	Merges changes to create new cds.conf file.
# 	[1995/05/08  14:40 UTC  jrr  /main/DCE1_1_WP/1]
# 
# 	Fix writing of cds.conf file for cellalias work.
# 	[1995/05/08  14:37 UTC  jrr  /main/jrr_wp/1]
# 
# 	Update OSF copyright year
# 	[1996/03/09  22:27:48  marty]
# 
# 	DCE 1.2.1 final drop from HP
# 	[1996/02/07  16:13:23  parul]
# 
# 	DCE 1.2.1 final drop from HP
# 
# Revision /main/DCE_1.2.2/7  1996/08/15  20:31 UTC  psn
# 	Fix CHFts19809: change dce1.1 -> dce1.2.
# 	[1996/08/14  15:09 UTC  psn  /main/DCE_1.2.2/psn_bugfix/3]
# 
# Revision /main/DCE_1.2.2/6  1996/08/01  15:31 UTC  psn
# 	Fix CRT CHFts19425: /opt/dcelocal/bin/rpcd was not created
# 	[1996/07/31  20:08 UTC  psn  /main/DCE_1.2.2/psn_bugfix/2]
# 
# Revision /main/DCE_1.2.2/5  1996/07/19  20:16 UTC  psn
# 	Fix OT 13573: dce_config doesn't install DCE headers
# 	[1996/07/19  20:06 UTC  psn  /main/DCE_1.2.2/psn_bugfix/1]
# 
# Revision /main/DCE_1.2.2/4  1996/07/09  19:47 UTC  mullan_s
# 	Merge from cuti_pk_export to DCE_1.2.2
# 	[1996/06/30  21:59 UTC  cuti  /main/DCE_1.2.2/3]
# 
# 	Put sticky bit back for pk_file
# 	[1996/06/27  19:44 UTC  cuti  /main/DCE_1.2.2/cuti_pk_export/2]
# 
# 	Add /var/security/pk_file
# 	[1996/06/27  13:50 UTC  cuti  /main/DCE_1.2.2/cuti_pk_export/1]
# 
# 	Merge to DCE 1.2.2
# 	[1996/06/14  21:02 UTC  mullan_s  /main/DCE_1.2.2/2]
# 
# Revision /main/DCE_1.2.2/mullan_dce122_bugs_1/3  1996/06/27  19:13 UTC  mullan_s
# 	config_krb5client: insert missing '=' sign in /etc/krb5.conf domain_realm section.
# 
# Revision /main/DCE_1.2.2/mullan_dce122_bugs_1/2  1996/06/27  19:09 UTC  mullan_s
# 	config_sec: call config_krb5client *after* changing cell_admin password
# 	in rgy_init.
# 
# Revision /main/DCE_1.2.2/mullan_dce122_bugs_1/1  1996/06/14  20:42 UTC  mullan_s
# 	Set mods on /krb5/krb.realms to 644.
# 	Link /etc/v5srvtab to /krb5/srvtab.
# 	Ask user (or use env. var) for domain name if cannot be
# 	automatically determined.
# 
# Revision /main/DCE_1.2.2/1  1996/05/30  21:14 UTC  mullan_s
# 	Merge krb5 work to DCE1.2.2 mainline
# 
# Revision /main/mullan_dce1.2.2_krb5_drop/2  1996/05/30  20:07 UTC  arvind
# 	Use LIST variable to install rutils.
# 
# Revision /main/mullan_dce1.2.2_krb5_drop/2  1996/05/30  20:04 UTC  mullan_s
# 	Use LIST variable to install rutils.
# 
# Revision /main/mullan_dce1.2.2_krb5_drop/1  1996/05/29  20:28 UTC  mullan_s
# 	Update OSF copyright year
# 	[1996/03/09  22:27:48  marty]
# 	#
# 
# 	DCE 1.2.1 final drop from HP
# 	[1996/02/07  16:13:23  parul]
# 
# 	DCE 1.2.1 final drop from HP
# 
# Revision /main/DCE_1.2/mullan_dce_k5_bsd44_rutils/3  1996/05/22  19:08 UTC  mullan_s
# 	Incorrect /etc/resolv.conf parsing to get domain name.
# 
# Revision /main/DCE_1.2/mullan_dce_k5_bsd44_rutils/2  1996/05/16  16:59 UTC  mullan_s
# 	Add support for creation of bare-bones /etc/krb5.conf file
# 
# Revision /main/DCE_1.2/mullan_dce_k5_bsd44_rutils/1  1996/05/03  13:48 UTC  mullan_s
# 	Add config_krb5() for krb5 rutil and client configuration
# 
# Revision /main/DCE_1.2/4  1996/01/29  17:17 UTC  psn
# 	Install dced_acl_patcher.
# 
# Revision /main/DCE_1.2/3  1996/01/24  23:16 UTC  psn
# 	Correct the test clause.
# 	[1996/01/24  00:17 UTC  psn  /main/DCE_1.2/final_1.2.1_merge/1]
# 
# Revision /main/DCE_1.2/2  1996/01/03  21:42 UTC  psn
# 	Fix DCE_ETC install time setting.
# 
# Revision /main/DCE_1.2/1  1996/01/03  19:05 UTC  psn
# 	Fix a test..
# 	[1995/12/04  22:35 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/8]
# 
# 	Install sec_salvage_db
# 	[1995/11/17  20:30 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/7]
# 
# 	Fix $BINDING for configuring gda.
# 	[1995/11/17  17:12 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/5]
# 
# 	DCE 1.2.1 merge w/ CDS
# 	[1995/11/16  21:20 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/4]
# 
# 	DCE 1.2.1 merged config w/o CDS.
# 	[1995/11/13  21:59 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/3]
# 
# 	Config now succeeds with secd and cdsd server configuration.
# 	[1995/11/10  17:23 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/2]
# 
# 	Add in support for new libraries.
# 	[1995/11/10  14:10 UTC  jrr  /main/DCE1_1_WP/jrr_1.2_mothra/1]
# 
# 	Config that works until acl setting.
# 	[1995/11/10  14:09 UTC  psn  /main/DCE1_1_WP/jrr_1.2_mothra/1]
# 
# 	Merges changes to create new cds.conf file.
# 	[1995/05/08  14:40 UTC  jrr  /main/DCE1_1_WP/1]
# 
# 	Fix writing of cds.conf file for cellalias work.
# 	[1995/05/08  14:37 UTC  jrr  /main/jrr_wp/1]
# 
# Revision 1.2.61.2  1994/10/18  17:44:37  tom
# 	Integrate fix for 11548.
# 	[1994/10/18  17:44:06  tom]
# 
# Revision 1.2.61.1  1994/10/13  17:25:48  blazin
# 	For CR 12446 added default audit filters.
# 	[1994/10/13  17:25:14  blazin]
# 
# Revision 1.2.56.33  1994/10/18  17:29:30  tom
# 	OT11548: create preauth directory for dced.
# 	[1994/10/18  17:28:48  tom]
# 
# Revision 1.2.56.32  1994/09/29  20:08:12  tom
# 	Bug 12402 - Make sure security replica is all set to go
# 	before exiting config_secreplica.
# 	[1994/09/29  19:56:12  tom]
# 
# Revision 1.2.56.31  1994/09/27  20:53:57  tom
# 	Bug 12267 - make sure any replica registries are up to date
# 	before doing a keytab operation for cds replicas.
# 	[1994/09/27  20:53:24  tom]
# 
# Revision 1.2.56.30  1994/09/27  12:33:03  melman
# 	removed merge lines
# 	[1994/09/27  12:26:41  melman]
# 
# Revision 1.2.56.29  1994/09/26  20:31:46  blazin
# 	Merged with changes from 1.2.56.28
# 	[1994/09/26  20:31:19  blazin]
# 
# 	For CR 12300, added support to install libaudit.a.
# 	[1994/09/26  20:25:27  blazin]
# 
# Revision 1.2.56.28  1994/09/23  20:24:41  tom
# 	Bug 11945 - Install any and all audit ec files in etc/audit/ec.
# 	[1994/09/23  20:23:59  tom]
# 
# Revision 1.2.56.27  1994/09/20  18:17:39  blazin
# 	For CR 12223 needed to install two new audit ec files.
# 	[1994/09/20  18:16:32  blazin]
# 
# Revision 1.2.56.26  1994/09/16  16:03:29  rsalz
# 	Stop installing rpcd and sec_clientd (OT CR 11488).
# 	[1994/09/16  15:56:23  rsalz]
# 
# Revision 1.2.56.25  1994/09/15  20:20:59  tom
# 	Bug 11960 - make sure gda_config creates the gda principal, etc
# 	not the cds server config routines.
# 	Allow unconfig of cds and security replica servers (OT 11479, 10949).
# 	If we just unconfig'd this host, shutdown dce.
# 	[1994/09/15  20:19:36  tom]
# 
# Revision 1.2.56.24  1994/09/12  20:53:47  aha
# 	CR12134: in config_pwd_mgmt(), perform test for pwd_strengthd already
# 	running only if attempting to configure, not if attempting to
# 	unconfigure.
# 	[1994/09/12  20:18:29  aha]
# 
# Revision 1.2.56.23  1994/09/09  19:55:01  jd
# 	Generate server principals on a secondary host when the server is configured.
# 	Also create the necessary namespace entries but only when the server is
# 	configured.
# 	[1994/09/09  19:46:22  jd]
# 
# Revision 1.2.56.22  1994/09/06  18:27:53  bowe
# 	Added "dcecf_postproc" [CR 11705]
# 	Added "svcdumplog" [CR 11871]
# 	[1994/09/06  18:25:55  bowe]
# 
# Revision 1.2.56.21  1994/08/30  21:45:30  baum
# 	Don't look for sec_client anymore (OT #11959)
# 	[1994/08/30  21:45:02  baum]
# 
# Revision 1.2.56.20  1994/08/25  21:21:11  tom
# 	For security OT 11623:
# 	  Register rpriv v1.1 interface in cell-profile too
# 	[1994/08/25  21:15:58  tom]
# 
# 	Bug 8702 -  Use new dtsdate command to check times.
# 	Bug 11830 - install pwd_strengthd for sec server.
# 	Bug 11852 - Don't install libdce.a since it is no longer built.
# 	Bug 11854 - Don't add cds server principals for cds client.
# 	Bug 11375 - Single space dcecf.db entries.
# 	Remove TCP warning message for endpoint map, since runtime
# 	will now do the right thing for wellknown endpoints.
# 	[1994/08/25  19:51:25  tom]
# 
# Revision 1.2.56.19  1994/08/25  19:56:59  baum
# 	Fixed rc.dce update of sec_client service (OT 11891)
# 	[1994/08/25  19:56:33  baum]
# 
# Revision 1.2.56.18  1994/08/24  16:28:53  baum
# 	Merged with changes from 1.2.56.17
# 	[1994/08/24  16:28:23  baum]
# 
# 	dced secval is now startable from config
# 	[1994/08/24  16:24:49  baum]
# 
# Revision 1.2.56.17  1994/08/23  15:28:27  keutel
# 	OT 10919: gda_child can be removed
# 	[1994/08/23  14:51:10  keutel]
# 
# Revision 1.2.56.16  1994/08/22  19:07:32  tom
# 	Remove extra newline
# 	[1994/08/22  19:06:39  tom]
# 
# Revision 1.2.56.15  1994/08/22  17:58:32  tom
# 	Bug 11613 - Remove install of sec_salvage_db.
# 	[1994/08/22  17:58:12  tom]
# 
# Revision 1.2.56.14  1994/08/19  11:31:44  keutel
# 	OT 10954: log_msg enhancements in gds installation
# 	[1994/08/19  10:47:54  keutel]
# 
# 	OT 10954: gds client installation introduced
# 	[1994/08/18  15:56:11  keutel]
# 
# Revision 1.2.56.13  1994/08/18  19:23:59  tom
# 	Remove old uuid formats. (OT 11761)
# 	[1994/08/18  19:23:13  tom]
# 
# Revision 1.2.56.12  1994/08/16  19:43:42  tom
# 	Bug 11716 - prevent config_cdsclient from being called twice.
# 	[1994/08/16  19:41:20  tom]
# 
# Revision 1.2.56.11  1994/08/12  19:06:06  blazin
# 	For CR 11431 added the audit-admin group and put cell-admin into it.
# 	[1994/08/12  19:05:11  blazin]
# 
# Revision 1.2.56.10  1994/08/08  14:23:11  mdf
# 	Hewlett Packard Security Code Drop
# 	[1994/08/04  19:56:18  mdf]
# 
# Revision 1.2.56.8  1994/07/29  20:24:49  gmd
# 	Removed unnecessary word "Error/error" from string
# 	arguments to chk_* routines.
# 	[1994/07/29  20:02:25  gmd]
# 
# Revision 1.2.56.7  1994/07/26  14:09:47  keutel
# 	OT 9314,11224,11433,11434: gds stuff
# 	[1994/07/26  11:14:56  keutel]
# 
# Revision 1.2.56.6  1994/07/25  15:08:16  proulx
# 	Export serviceability interface for CDS clerk, server & GDA
# 	[1994/07/25  15:05:53  proulx]
# 
# Revision 1.2.56.5  1994/07/22  18:49:34  cbrooks
# 	    CR11395 - don't test, just rm dtsdate link
# 	    [1994/07/22  17:58:55  cbrooks]
# 
# 	    CR11395 - remove dtsdate from /usr/bin before doing the link
# 	    [1994/07/22  17:35:41  cbrooks]
# 
# Revision 1.2.56.4  1994/07/15  17:07:03  cbrooks
# 	CR10792 - add symlink /usr/bin/dtsdate to DECLOCAL/bin/dtsd
# 	[1994/07/15  14:03:05  cbrooks]
# 
# Revision 1.2.56.3  1994/07/13  17:43:45  keutel
# 	OT 11274: cd ... ---> (cd ...) for install_gds stuff
# 	[1994/07/13  16:54:26  keutel]
# 
# Revision 1.2.56.2  1994/07/11  21:05:54  keutel
# 	OT 10732, OT 8876: gds changes
# 	[1994/07/11  20:50:51  keutel]
# 
# Revision 1.2.56.1  1994/07/11  17:21:53  marty
# 	CR # 11125 - Trim the submission branch of this file for performance (bco).  The old
# 	submission branch is labeled DCE1_1_TRIMMED.
# 	[1994/07/11  17:21:26  marty]
# 
# Revision 1.2.50.31  1994/07/07  14:51:48  zeliff
# 	ot11192: remove auditcp
# 	ot11193: re-install libdsal if it has been previously installed
# 	         on 486.
# 	[1994/07/07  12:34:49  zeliff]
# 
# Revision 1.2.50.30  1994/06/28  20:12:41  rsalz
# 	Always build rpcd directory for now (OT CR 11116).
# 	[1994/06/28  19:39:56  rsalz]
# 
# Revision 1.2.50.29  1994/06/23  16:56:14  tom
# 	Call menu99 from main to remove dce_login_noexec link.
# 	[1994/06/23  16:55:38  tom]
# 
# Revision 1.2.50.28  1994/06/21  16:55:29  tom
# 	dce.clean is now called dce_shutdown will link to dce.clean.
# 	All Executing: log messages should be DETAIL, not VERBOSE.
# 	[1994/06/21  16:44:42  tom]
# 
# Revision 1.2.50.27  1994/06/21  14:40:46  marrek
# 	gds changes
# 	[1994/06/21  14:38:16  marrek]
# 
# Revision 1.2.50.26  1994/06/20  21:03:18  salamone
# 	Provide auto-loading procedure support.
# 	[1994/06/20  18:06:20  salamone]
# 
# Revision 1.2.50.25  1994/06/03  19:17:15  rsalz
# 	Merged with changes from 1.2.50.24
# 	[1994/06/03  19:16:36  rsalz]
# 
# 	Always create dced directory.
# 	[1994/06/03  19:11:45  rsalz]
# 
# 	Finish correct installation of dced (OT CR 10749).
# 	[1994/06/02  20:09:21  rsalz]
# 
# Revision 1.2.50.24  1994/06/02  20:36:05  mdf
# 	Merged with changes from 1.2.50.23
# 	[1994/06/02  20:34:40  mdf]
# 
# 	Merged with changes from 1.2.50.22
# 	[1994/06/02  20:10:39  mdf]
# 
# 	Merged with changes from 1.2.50.21
# 	[1994/06/02  19:08:01  mdf]
# 
# 	 hp_sec_to_osf_3 merge
# 	[1994/06/02  18:45:12  mdf]
# 
# Revision 1.2.50.21  1994/06/01  15:58:36  rsalz
# 	Add dced support (OT CR 10749, 9768)
# 	[1994/06/01  15:27:32  rsalz]
# 
# Revision 1.2.50.20  1994/05/25  20:21:53  tom
# 	Bug 10760 - start_daemon is messing up dtsd arguments, remove it all.
# 	Bug 10765 - Diskless is no longer part of dce.
# 	[1994/05/25  20:20:21  tom]
# 
# Revision 1.2.50.19  1994/05/25  17:25:43  zeliff
# 	ot10770: need to create var/audit/client
# 	[1994/05/25  17:15:40  zeliff]
# 
# Revision 1.2.50.18  1994/05/18  19:57:11  tom
# 	Bug 10628 - Use new dtsd switches instead of rc.dts.
# 	Bug 10627 - Time Providers now put themselves into the background.
# 	[1994/05/18  19:56:25  tom]
# 
# Revision 1.2.50.17  1994/05/12  14:37:45  zeliff
# 	ot10609: change gdssvcstep gdsstep
# 	[1994/05/12  14:37:10  zeliff]
# 
# Revision 1.2.50.16  1994/05/05  17:52:46  kevins
# 	OT10531 tcl/dcecp fail to install when installation already exists
# 	[1994/05/05  17:52:12  kevins]
# 
# Revision 1.2.50.15  1994/04/22  17:04:15  jd
# 	Put the call to dump clerk cache back. Since it gets its information
# 	from the local cache it works much faster than waiting for the show
# 	dir to fail.
# 	[1994/04/22  14:13:06  jd]
# 
# Revision 1.2.50.14  1994/04/21  15:54:02  tom
# 	Merged with changes from 1.2.50.13
# 	[1994/04/21  15:53:29  tom]
# 
# 	Bug 10382 - Install svc routing file.
# 	Bug 9641 - Change dce1.0 references to dce1.1, fix verify() logic.
# 	[1994/04/20  20:05:35  tom]
# 
# Revision 1.2.50.13  1994/04/20  19:23:00  jd
# 	Remove grep of cell name.
# 	[1994/04/20  19:22:12  jd]
# 
# 	cdscp dump cache server is hanging. Replace it with show dir /.: until
# 	it works.
# 	[1994/04/20  17:53:58  jd]
# 
# Revision 1.2.50.12  1994/04/20  11:32:22  kevins
# 	CR 9771 add installation for dcecp and tcl
# 	[1994/04/20  11:31:46  kevins]
# 
# Revision 1.2.50.11  1994/04/06  17:33:59  tom
# 	Bug 10131 (again) - start_daemon only starts the daemon if debug is
# 	turned on.
# 	[1994/04/06  17:33:05  tom]
# 
# Revision 1.2.50.10  1994/03/30  15:33:34  tom
# 	Bug 9557 - In config(), call settimezone, auth_login and verify_auth
# 	 before configuring a security replica, auditing, or gda.
# 	Bug 10131 - in config_secreplica, start secd with start_daemon.
# 	Bug 9953 - Fix up time check code to look for daytime in services file.
# 	Bug 9833 - Fix pthread_exc.h error message.
# 	Bug 9662 - Use log_msg instead of echo in config_ntp_provider.
# 	Bug 9621 - Word multiple lan question a little better.
# 	Bug 9611 - Only need read permissions for /dev/lan0 on HP-UX.
# 	Bug 9556, 9569 - Fix menu calls from config_morecds.
# 	Bug 9504 - Use DIR_REPLICATE variable to help auto cds replication.
# 	Bug 8654 - Reword filesystem prompt for install.
# 	Remove all explicit calls to menu functions, replace with returns.
# 	Clean up appdev install not to complain about existing links.
# 	When configuring a CDS replica, don't warn that cdsadv is running.
# 	[1994/03/30  15:26:38  tom]
# 
# Revision 1.2.50.9  1994/03/23  16:07:31  keutel
# 	error message for init.gdscp changed
# 	[1994/03/23  14:56:30  keutel]
# 
# 	gdscp,init.gdscp and gdssvcstep added
# 	[1994/03/23  13:38:00  keutel]
# 
# Revision 1.2.50.8  1994/03/16  16:06:08  zeliff
# 	OT9839: install DTS and AUD event class files
# 	[1994/03/16  16:05:38  zeliff]
# 
# Revision 1.2.50.7  1994/03/15  23:14:49  zeliff
# 	Changed error message in config_audit
# 	[1994/03/15  23:12:52  zeliff]
# 
# 	Added provision for starting auditd without start_daemon
# 	[1994/03/15  23:01:35  zeliff]
# 
# 	- Moved audit configuration to 'additional servers' menu
# 	- changed config_audit to use start_daemon()
# 	[1994/03/15  22:29:46  zeliff]
# 
# 	fix last problem
# 	[1994/03/15  20:23:24  zeliff]
# 
# 	Changed name of directory for audit client bindings
# 	[1994/03/15  13:17:00  zeliff]
# 
# 	OT9625:  added auditd and auditcp to install_common.
# 	Created config_audit().
# 	[1994/03/09  21:08:21  zeliff]
# 
# Revision 1.2.50.6  1994/02/22  15:19:19  marrek
# 	xoischema from directory/xoms added
# 	[1994/02/21  07:58:48  marrek]
# 
# Revision 1.2.50.5  1994/02/18  20:33:55  zeliff
# 	OT 9322:  libNDS.so caused /etc/lib_admin to complain in
# 	certain situations.  This was fixed by always re-installing
# 	libNDS.so on OSF/1 machines which had previously had it
# 	installed.
# 
# 	OT 9382:  goes away because of fix to 9322.
# 	[1994/02/18  19:17:35  zeliff]
# 
# Revision 1.2.50.4  1994/02/15  19:08:46  delgado
# 	Fix date syntax for RIOS
# 	[1994/02/15  19:07:50  delgado]
# 
# Revision 1.2.50.3  1994/02/14  15:56:04  delgado
# 	move install of static libdce.a on HPUX to the application development
# 	environment installation
# 	[1994/02/14  15:55:05  delgado]
# 
# Revision 1.2.50.2  1994/02/02  20:34:51  zeliff
# 	Minor changes
# 	[1994/02/02  19:55:24  zeliff]
# 
# 	OT9873: fix installation of XDS headers
# 	[1994/02/02  16:42:58  zeliff]
# 
# Revision 1.2.50.1  1993/12/29  19:22:05  rsalz
# 	Don't install dce_cf_sts.h, private header file now removed.
# 	Part of move dce_cf_XXX from config to dce/utils/dcecf (OT CR 9663).
# 	[1993/12/29  18:23:09  rsalz]
# 
# Revision 1.2.45.19  1993/11/08  21:26:55  zeliff
# 	OT9403: install gda_child
# 	[1993/11/08  20:56:35  zeliff]
# 
# Revision 1.2.45.18  1993/10/25  20:36:15  zeliff
# 	Bco'd by mistake. ODE won't let you undo a bco anymore.
# 	[1993/10/22  14:56:43  zeliff]
# 
# 	Backing out submission of fix 9075
# 	[1993/10/22  14:49:49  zeliff]
# 
# Revision 1.2.45.16  1993/10/19  22:01:35  zeliff
# 	OT9122: Install libNDS correctly
# 	[1993/10/19  20:43:04  zeliff]
# 
# Revision 1.2.45.15  1993/10/15  19:41:43  tom
# 	Bug 8501 - preserve rc.dce if modified so you can reinstall without
# 	reconfiguring.
# 	[1993/10/15  19:41:20  tom]
# 
# Revision 1.2.45.14  1993/10/14  21:49:01  tom
# 	Bug 8875 - Install dfs_config in client() so you can RE-install dfs
# 	after answering yes to the remove question.
# 	Install DCE client before calling dfs_config (so it will be there).
# 	[1993/10/14  21:44:27  tom]
# 
# Revision 1.2.45.13  1993/10/14  18:29:55  tom
# 	Merged with changes from 1.2.45.12
# 	[1993/10/14  18:29:19  tom]
# 
# 	Bug 9103 - call set_cell_name before invoking user command file.
# 	Bug 9097 - change err_exit to x_exit in menu_hp1 warning message.
# 	Bug 9118 - Fix libNDS to use SHLIB_SUF variable.
# 	Remove commented out echo code.
# 	[1993/10/14  18:20:56  tom]
# 
# Revision 1.2.45.11  1993/10/13  17:28:10  keutel
# 	October 1993 code drop (CR 9047)
# 	[1993/10/13  11:48:15  keutel]
# 
# Revision 1.2.45.10  1993/10/08  21:06:39  tom
# 	Bug 9068 - Handle HPUX /usr/lib/libdce.a symlink correctly.
# 	[1993/10/08  21:05:31  tom]
# 
# Revision 1.2.45.9  1993/10/04  18:10:16  tom
# 	Bug 7239 - install pthread files in /usr/include/dce too.
# 	Check for group nobody and ignore.
# 	[1993/10/04  18:09:42  tom]
# 
# Revision 1.2.45.8  1993/09/27  21:18:15  jd
# 	The cdscp program isn't as forgiving as it used to be on attribute
# 	names. Changed all instances of class-> CDS_Class and
# 	classversion-> CDS_ClassVersion.
# 	[1993/09/27  21:05:43  jd]
# 
# Revision 1.2.45.7  1993/09/27  20:29:33  tom
# 	Bug 8695 - Make sure we install all but dfs message catalogs.
# 	[1993/09/27  20:08:32  tom]
# 
# Revision 1.2.45.6  1993/09/27  17:06:26  tom
# 	Bug 8684 - correct path of HP-UX libdce.a.
# 	Bug 8686 - In check_app_prereq, correctly check for libdce.
# 	[1993/09/27  17:05:36  tom]
# 
# Revision 1.2.45.5  1993/09/17  21:27:07  tom
# 	Automation:
# 	  Use getopt to parse command line for COMMAND_FILE and CONFIG_FILE.
# 	  Add config() and install(), which get invoked by user script.
# 	  Rename install to install_list and move to dce_com_utils.
# 	  Call remove_install, instead of duplicating code.
# 	  Put prompt code in clean_and_remove, controlled by argument.
# 	  CP_OR_SYMLINK changed to CPCMD which isn't user settable.
# 	DFS config:
# 	  Install DFS /etc files in install_dfs_common.
# 	  Add new item to Configure menu: DFS Client.
# 	  Never ask about DFS client config.
# 	  Install only dce message catalogs, let DFS install there own.
# 	When configing a CDS replica, make sure we config as CDS client.
# 	Fix HP-UX install of libdce.a.
# 	[1993/09/17  21:26:15  tom]
# 
# Revision 1.2.45.4  1993/09/13  14:18:53  tom
# 	Bug 8583 - Ask about multiple lans on CDS client config
# 	Bug 8582 - Move all variables out to dce_com_env.
# 	[1993/09/10  22:28:59  tom]
# 
# Revision 1.2.45.3  1993/09/08  21:22:18  tom
# 	Bug 8566 - Adjust get_server_time() because RIOS prints out
# 	connection closed message on stdout, not stderr.
# 	[1993/09/08  20:51:52  tom]
# 
# Revision 1.2.45.2  1993/09/07  17:34:16  tom
# 	Bug 8556 - don't include the 'nobody' user or the 'nogroup' group
# 	in calculating the highest unix ids.
# 	[1993/09/03  21:35:19  tom]
# 
# Revision 1.2.45.1  1993/09/02  19:41:54  tom
# 	Bug 8548 - set umask 0 so user umask doesn't affect installation.
# 	Make sure DCELOCAL and ETC are used in all the right places.
# 	[1993/09/02  19:40:13  tom]
# 
# Revision 1.2.36.17  1993/08/26  22:32:05  tom
# 	Bug 8514 - change grep -v to grep -q to suppress ps output.
# 	Bug 8408 - Fix security replica config to ask for name if not provided.
# 	[1993/08/26  22:28:55  tom]
# 
# Revision 1.2.36.16  1993/08/20  20:44:19  tom
# 	Bug 7627 - rpccp should print error message to stderr
# 	Make sure all rpccp and cdscp executions redirect stderr.
# 	Also, call do_multiple_lans after we check the results of cdscp.
# 	[1993/08/20  20:29:47  tom]
# 
# Revision 1.2.36.15  1993/08/19  20:28:44  tom
# 	Bug 8438 - Remove parse_nls and use the one in dce_com_utils.
# 	[1993/08/19  20:27:17  tom]
# 
# Revision 1.2.36.14  1993/08/11  13:42:29  marrek
# 	Chmod 777 of ipc, because applications create named pipes
# 	in that directory.
# 	[1993/08/09  09:01:21  marrek]
# 
# Revision 1.2.36.13  1993/08/06  14:30:58  eperkins
# 	Removed the program repclient from the install_opt_util() routine.
# 	[1993/08/06  14:29:52  eperkins]
# 
# Revision 1.2.36.12  1993/08/05  20:05:49  eperkins
# 	Removed the HP product specific includes form
# 	the application development installation.
# 	[1993/08/05  20:04:37  eperkins]
# 
# Revision 1.2.36.11  1993/08/05  17:21:57  eperkins
# 	Added sec_salvage_db to the install_sec() and install_secreplica() routines.
# 	[1993/08/05  17:20:44  eperkins]
# 
# Revision 1.2.36.9  1993/08/02  17:08:34  eperkins
# 	Added removal of $DCELOCAL/etc/zoneinfo to install_dts. This directory
# 	get created anew in the next step of the install.
# 	[1993/08/02  17:07:07  eperkins]
# 
# Revision 1.2.36.8  1993/07/28  21:26:21  tom
# 	No need to create zoneinfo directory structure, cp does it for us.
# 	[1993/07/28  21:05:30  tom]
# 
# Revision 1.2.36.7  1993/07/27  21:50:46  tom
# 	Bug 8372 - Add -update to all rgy_edit commands.
# 	Fix date setting routine to use %02d, not %02s to get leading zeros.
# 	[1993/07/27  21:49:16  tom]
# 
# Revision 1.2.36.6  1993/07/22  18:16:43  tom
# 	Truncate revision history.
# 	[1993/07/22  16:34:49  tom]
# 
# Revision 1.2.36.5  1993/07/21  21:55:09  tom
# 	Correct some menu backtracking.
# 	[1993/07/21  21:53:34  tom]
# 
# Revision 1.2.36.4  1993/07/20  22:46:08  tom
# 	Post HP additions:
# 	 SHLIB_RDN set in dce_com_env.
# 	 All $PARENT calls removed and changed to 'return's.
# 	 Put back install #6 - DCE client, DFS Client now #10.
# 	 Ask once if we should remove previous install on any selection.
# 	 If dfs install doesn't work, don't try to install client.
# 	 All explicit calls to menus are changed to returns.
# 	 Added support for FILESYSTEM, MEDIA, CP_OR_SYMLINK, DTS_CONFIG.
# 	 Add support USE_DEF_MSG_PATH, for OSF1: USE_ETHER_FILE, DO_LIB_ADMIN.
# 	 Do better checking for not repeating client installation.
# 	 install_dts re-written
# 	 multiple lan question now comes early in CDS process.
# 	 Support existing MULTIPLE_LAN and LAN_NAME variables.
# 	 Configure DTS when doing DCE client (can say no dts at all).
# 	 Make rc.dce and rc.dfs live in /etc, always use RC_DFS/RC_DCE variable.
# 	 Remove install_dfsclient, its in dfs_config
# 	 Don't create subsys/dfs/bak directory in cds.
# 	[1993/07/20  22:31:28  tom]
# 
# Revision 1.2.36.3  1993/07/19  19:26:16  zeliff
# 	HP port of DFS
# 	[1993/07/19  18:20:00  zeliff]
# 
# $EndLog$
#
#
#  OSF DCE Version 1.0 
#
#
# "Big Bang" install/config/start-up script
#
#
#------------------------------------------------------
# Initialize global/default variables
#------------------------------------------------------

#------------------------------------------------------
# Must be running as root
ID=`id -u`
if [ ${ID} -ne 0 ]; then
    echo "You must have root permission to run \"dce_config\"."
    exit 1
fi

trap 'stty echo;exit' 2

# make sure user umask doesn't affect installation.
umask 000

set -- `getopt ic:e: $*`
if [ $? != 0 ]
then
	echo "Usage: dce_config [-i] [-e environment_file] [-c command_file]"
	exit 1
fi
while [ $1 != -- ]
do
	case $1 in
	-i)	INSTALL=y;;
	-c)
		slash=`expr $2 : "\(/\)"`
		if [ "$slash" = "/" ]
		then
			COMMAND_FILE=$2
		else
			COMMAND_FILE="./$2"
		fi
		shift;;
	-e)
		slash=`expr $2 : "\(/\)"`
		if [ "$slash" = "/" ]
		then
			CONFIG_FILE=$2
		else
			CONFIG_FILE="./$2"
		fi
		export CONFIG_FILE
		shift;;
	esac
	shift
done
shift

: ${INSTALL:="n"}
if [ "$INSTALL" = "y" -o "$1" = "install" ]
then
	ETC="."
	DCE_ETC="."
else
	ETC="/etc"
	DCE_ETC="/etc"
fi

export ETC DCE_ETC
	
# DEBUG?
D=$1
export D

if [ "$D" = "D" ]
then
	set -x
fi

if [ -x ${ETC}/dce_config_utils ]
then
	. ${ETC}/dce_config_utils
else
	echo "dce_config: ${ETC}/dce_config_utils is not available or not executable.  Exiting"
	exit 1
fi

echo "*****************************************************************" >>$logfile
echo "dce_config V$Revision: 1.2.69.5 $($Date: 1996/10/15 20:44:18 $) executed: `date`" >>$logfile 
echo "*****************************************************************" >>$logfile

# Report the values of the environment variables to the config log file
log_env_values

#------------------------------------------------------
# Utilities for installation/configuration routines
#------------------------------------------------------

#
# These routines automate the configuration process
# by parsing a file with configuration instructions
# in it (COMMAND_FILE).  This is fairly crude and not really intended
# to be a robust end-user interface

#-----------------------------------------------------
#
#  install <what>
#  <what> :=		sec	appdev		sec-replica
#			cds	dts	cdsbrowser
#			client	nidl_to_idl pkssd
#
#  install gds  <which>
#               <which> := client|server
#
#  install dfs	<which> 
#  		<which> := client|scm|privatefs|fs|fldb
#			
install()
{
	what=$1
	which=$2
	if [ -z "$install_init" ]
	then
		install_init=1
		get_binary_loc
		remove_install
		create_dirstruct
	fi
	case $what in
		sec)		install_sec; client;;
		cds)		install_cds; client;;
		dts)		install_dts; client;;
		pkssd)		install_pkssd; client;;
		gds)		case $which in
				  client)
					client; install_gds_client;;
				  *)
					client; install_gds;;
				esac
				;;
		client)		client;;
		appdev) 	install_appdev;;
		sec-replica) 	install_secreplica; client;;
		cdsbrowser)	LIST="cdsbrowser"; install_list;;
		nidl_to_idl)	LIST="nidl_to_idl"; install_list;;

				# client | scm | privatefs | fs | fldb
		dfs)		case $which in
				  client) 
					dfs_config_call install_dfsclient; 
					client;;
				  *) 
					DFS_SERVER_INSTALL="$which";
					export DFS_SERVER_INSTALL;
					dfs_config_call install_dfs; 
					client;;
				esac
				;;
		*)
			log_msg ERROR "No such target to install: $1";
			exit 1 ;;

	esac
}

#-----------------------------------------------------
#  config  <component> <how>
#
#  <component> := 
#			client
#			sec	<how> :=	client|server|replica
#			pkss	<how> :=	client|server
#			cds	<how> :=	client|server|replica
#			gda
#
#			dts	<how> :=	clerk|local|global|server|none
#						ntp-provider|null-provider
#
#			dfs	<how> :=	client|scm|privatefs|fs|fldb
config()
{
	comp=$1
	how=$2

	# go check if they want to shutdown and remove
	clean_and_remove prompt

	case $comp in

		client)
			log_msg SUMMARY "Configuring DCE client...";
			settimezone; auth_login; verify_auth; config_client
			;;
		sec)
			case $how in
			  server)
				log_msg SUMMARY "Configuring Security Server...";
			 	settimezone; config_sec;;
			  client) 
				log_msg SUMMARY "Configuring Security Client...";
				settimezone; auth_login; verify_auth; config_secclient;;
			  rep*)
				log_msg SUMMARY "Configuring Security Replication";
				settimezone; auth_login; verify_auth; config_secreplica;;
			  *)
				log_msg ERROR "Can not config sec '$how'";
				exit 1;;
			esac
			;;

		pkss)
			case $how in
			  server)
				log_msg SUMMARY "Configuring Private Key Storage Server...";
				auth_login; verify_auth; config_pkss_svr;;
			  client) 
				log_msg SUMMARY "Configuring Private Key Storage
 Client...";
				config_pkss_clt;;
			  *)
				log_msg ERROR "Can not config Private Key Storage Service '$how'";
				exit 1;;
			esac
			;;

		cds)
			auth_login; verify_auth; 
			case $how in
			  server) 
				log_msg SUMMARY "Configuring CDS Server...";
				config_cds;;
			  client) 
				log_msg SUMMARY "Configuring CDS Client...";
				config_cdsclient;;
			  rep*)
				log_msg SUMMARY "Configuring additional CDS Server...";
				config_morecds;;
			  *)
				log_msg ERROR "Can not config cds '$how'";
				exit 1;;
			esac
			;;

		gda)
			log_msg SUMMARY "Configuring GDA Server...";
			settimezone; auth_login; verify_auth; config_gda
			;;
		dts)
			verify_auth; 
			case $how in
			  clerk)
				log_msg SUMMARY "Configuring DTS Clerk...";
				config_dtsclerk;;
			  server|local)  
				log_msg SUMMARY "Configuring DTS Local Server...";
				config_dtslocal;;
			  global) 
				log_msg SUMMARY "Configuring DTS Global Server...";
				config_dtsglobal;;
			  none)   ;;
			  null*)
				log_msg SUMMARY "Configuring a Null Time Provider...";
				config_nulltimeprovider;;
			  ntp*)
				log_msg SUMMARY "Configuring an NTP Time Provider...";
				config_ntptimeprovider;;

			  
			  *)
				log_msg ERROR "Can not config dts '$how'";
				exit 1;;
			esac
			;;
		audit)
			log_msg SUMMARY "Configuring Audit...";
			settimezone; auth_login; verify_auth; config_audit
			;;
		dfs)
			settimezone;
			auth_login;
			verify_auth;
			case $how in
			  client) 
				log_msg SUMMARY "Configuring DFS Client...";
				dfs_config_call config_dfs_client;;
			  scm)
				log_msg SUMMARY "Configuring DFS System Control Machine...";
				check_app_prereqs;
                                dfs_config_call config_dfsscm
			  ;;
			  privatefs)
				log_msg SUMMARY "Configuring DFS Private File Server...";
				check_app_prereqs;
				dfs_config_call config_dfsprivatefs
			  ;;
			  fs)
				log_msg SUMMARY "Configuring DFS File Server...";
				check_app_prereqs;
				dfs_config_call config_dfsfs
			  ;;
			  fldb)
				log_msg SUMMARY "Configuring DFS Fileset Location Database Server...";
				check_app_prereqs;
				dfs_config_call config_dfsfldb
			  ;;
			  *)
				log_msg ERROR "Can not config dfs '$how'";
				exit 1;;
			esac
			;;
		*)
			log_msg ERROR "No such target to config: $comp";
			exit 1
		;;
	esac
}

#------------------------------------------------------
# Menus for installation and configuration of DCE
#------------------------------------------------------

#------------------------------------------------------
# menu0()
#
# Display the DCE Main Menu, and allow the user
# to select "Installation", "Configuration",
# "start DCE", or "stop DCE".  Invoke the appropriate
# routine based on the selection.
#------------------------------------------------------
menu0()
{
	mkdir -p $DCEROOT >/dev/null 2>&1
	set_cell_name

    while :
    do
	clear

	LIST="1 2 3 4 5 6 99"
	export LIST

	log_msg VERBOSE "User query: DCE Main Menu"
	echo "\t DCE Main Menu ( on ${HOSTNAME} )"
	echo "\n"

	echo "\t 1. INSTALL	-install dce software"
        echo "\t 2. CONFIGURE   -configure and start DCE daemons"
        echo "\t 3. START       -re-start DCE daemons"
        echo "\t 4. STOP        -stop DCE daemons"
        echo "\t 5. UNCONFIGURE -remove a host from CDS and SEC databases"
        echo "\t 6. REMOVE      -stop DCE daemons and remove data files"
        echo "\t                 created by DCE daemons"
        echo "\n"
        echo "\t99. EXIT"
        echo "\n\n"
        echon "\tselection:  "

	get_option

	# Only allow one option from this menu
	one_option

       	# Note there's no need to check for an invalid option, because
       	# the get_option routine already did that.
	log_msg VERBOSE "User entry: $opt"
	case $opt in
		 1)	get_binary_loc; 
			menu1;;
                 2)     menu2;;
                 3)     menu5;;
                 4)     menu6;;
                 5)     menu_hp1;;
                 6)     menu_hp2;;
                99)     menu99;;
	esac
     done	# until they want out
}


#*****************************************************************
#* Implementation note:                                          *
#*                                                               *
#* All menu# routines must follow the following format:          *
#*   set the LIST environment variable to valid input options    *
#*   display the submenu for the task to be done                 *
#*   If multiple paths are possible out of this submenu,         *
#*         invoke get_options                                    *
#*         If only one item should be selected from the menu,    *
#*             invoke one_option                                 *
#*         invoke the appropriate routine based on the           *
#*             get_options input value(s).                       *
#*   All sub-menus must provide a path back to their parent menu.*
#*                                                               *
#*****************************************************************

#------------------------------------------------------
# menu1()
#
# Display the DCE Installation Menu. 
#------------------------------------------------------
menu1()
{
    while :
    do
	clear

	if [ "$UNAME" != "HP-UX" ]
	then
		LIST="1 2 3 4 5 6 7 8 9 10 11 12 98 99"
	else
		LIST="1 2 3 4 5 6 7 8 9 10 11 98 99"
	fi
	export LIST

	log_msg VERBOSE "User query: DCE Installation Menu ( on ${HOSTNAME} )"
	echo "\n"
	echo "\t DCE Installation Menu ( on ${HOSTNAME} )"
	echo "\n"
	echo "\t 1. Security Server"
	echo "\t 2. CDS Server"
	echo "\t 3. DTS Server"
	echo "\t 4. GDS Server"
	echo "\t 5. DFS Server"
	echo "\n"
	echo "\t 6. DCE Client"
	echo "\t 7. Application Development Environment"
	echo "\t 8. Optional Utilities"
	echo "\t 9. Replica Security Server"
	echo "\t10. DFS Client"
	echo "\t11. GDS Client"
	if [ "$UNAME" != "HP-UX" ]
	then
		echo "\t12. PKSS Server"
	fi

	echo "\n"
	echo "\t98. Return to previous menu"
	echo "\t99. Exit"
	echo "\n"
	echon "\tselection:  "

	get_option

	log_msg VERBOSE "User entry: $opt"

	# exit out now
	if [ "$opt" = "99" ]; then
		menu99
	fi

	# Go check if they want to remove a previous install
	# This will only ask once
	remove_install

	# Create the high-level filesystem structure on the local machine
	# This includes $DCELOCAL, $DCELOCAL/bin, $DCELOCAL/etc, 
	# $DCELOCAL/$NLSDIR and $DCELOCAL/lib
	create_dirstruct

	for optionitem in $opt 
	do
		# Note there's no need to check for an invalid option, because
		# the get_option routine already did that.
		case $optionitem in
			1) 	install_sec; client;; 
			2)	install_cds; client;; 
			3)	install_dts; client;;
			4)	client; install_gds;;
			5)	client; dfs_config_call install_dfs;;
			6)	client;;
			7)	install_appdev;;
			8)	install_opt_util;;
			9)	install_secreplica; client;;
			10)	client; dfs_config_call install_dfsclient;;
			11)	client; install_gds_client;;
			12)	install_pkssd; client;;
			98)	return ;;
			99)	menu99;;
		esac
	done
    done	# Repeat until they want out
	#***********************************
	# Implementation Note:
	# For a server to be able to act as a client,
	# Both the appropriate server package and the
	# DCE Client package must be installed on the
	# machine.  Thus, client() is invoked after
        # each server installation routine, which
	# installs common executables on machines that
	# don't already have them installed.  
	# Configuration Note:
	#
	# For servers to be configured as clients, the
	# administrator must first specifically configure
	# the machine as a server.  After all servers have
	# been configured, the administrator may explicitly 
	# configure the server machines as DCE clients. 
	#***********************************
}

#------------------------------------------------------
# menu_hp1()
#
# Display DCE Unconfigure Menu .  This menu unconfigures
# a node from the cell name space.
#------------------------------------------------------
menu_hp1()
{
    log_msg DEBUG "Executing: menu_hp1()"
    log_msg SUMMARY "Attempting to unconfigure a node from the cell name space..."
    #
    # Support configuration input via environment variables
    #
    TEMP_UNCONFIG_HOST=${UNCONFIG_HOST_PRESET:="NULL"}
    if [ "${TEMP_UNCONFIG_HOST}" = "NULL" ]
    then
	log_msg VERBOSE "User query: Enter hostname of node to be unconfigured: ($HOSTNAME) "
	echo "\n\n"
	echon "\tEnter hostname of node to be unconfigured: ($HOSTNAME) "
	read UNCONFIG_HOST
	log_msg VERBOSE "User entry: $UNCONFIG_HOST"
    else
	UNCONFIG_HOST=$TEMP_UNCONFIG_HOST
    fi
    UNCONFIG_HOST=${UNCONFIG_HOST:-$HOSTNAME}

    # Don't allow STOP before UNCONFIG: check that endpoint map is
    # running, and if not, report error and return to menu.
    ps ${PSARGS} | grep -q $EPMAP
    if [ $? -ne 0 ]; then
        err_exit "DCE daemons must be running to unconfigure from the cell. \
Run CONFIGURE or START.  Continuing will return to the Main Menu."
	return
    fi

    if [ "$do_checks" = "y" ]; then
	log_msg VERBOSE "User query: Unconfiguring a node will remove the node's ability
to operate in the cell.  A reconfiguration of the
node will be required.
Do you wish to continue (y/n)? (n) "
	echo "\n"
	echo "\tUnconfiguring a node will remove the node's ability"
	echo "\tto operate in the cell.  A reconfiguration of the"
	echo "\tnode will be required."
	echon "\tDo you wish to continue (y/n)? (n) "
	read unconfig_response 
	unconfig_response=${unconfig_response:-"n"}
	log_msg VERBOSE "User entry: $unconfig_response"
    else
	unconfig_response="y"
    fi
    if [ "$unconfig_response" = "y" ]
    then
        if [ ! -x ${DCE_BIN}/dce.unconfig ]
        then
            err_exit "DCE must be installed and configured prior to unconfiguring DCE.  \
Continuing will return to the Main Menu."
            return
        else
	    log_msg DEBUG "Executing: dcelogin (from menu_hp1 unconfig)"
	    dcelogin
	    if [ $? -ne 0 ]; then
		return
	    fi

            log_msg VERBOSE "Removing host node $UNCONFIG_HOST from the cell."
            log_msg DEBUG "Executing: ${DCE_BIN}/dce.unconfig $UNCONFIG_HOST"
            ${DCE_BIN}/dce.unconfig $UNCONFIG_HOST
	    if [ $? -eq 0 ]
	    then
		log_msg SUMMARY "Successfully unconfigured host node $UNCONFIG_HOST from cell."
		if [ "$UNCONFIG_HOST" = "$HOSTNAME" ]; then
                        log_msg SUMMARY "Doing a dce_shutdown -f(orce)."
                        log_msg DETAIL "Executing: ${DCE_BIN}/dce_shutdown -f"
                        ${DCE_BIN}/dce_shutdown -f
			echo " "	# newline for fun
		fi
	    else
                err_exit "Failed to unconfigure host node $UNCONFIG_HOST from cell.  \
Continuing will return to the Main Menu."
                return
            fi
        fi

	if [ "$do_checks" = "y" ]; then
		log_msg WARNING "A dce_config REMOVE will need to be performed from node \
$UNCONFIG_HOST before reconfiguring it."
		x_exit
	fi
    fi

}

#
#
#------------------------------------------------------
# menu_hp2()
#
# Display DCE Remove Menu .  This menu stops all
# running DCE daemons (dce_shutdown), and removes all
# remnants of previous DCE configurations (dce.rm).
#------------------------------------------------------
menu_hp2()
{
    log_msg DEBUG "Executing: menu_hp2()"
    if [ "$do_checks" = "y" ]; then
	log_msg VERBOSE "User query: REMOVE will remove the node's ability to operate in the cell.
A reconfiguration of the node will be required.  This node should be unconfigured before a
REMOVE is done.  You may REMOVE without unconfiguring if you are destroying the cell.
Do you wish to continue (y/n)? (n) "
	echo "\tREMOVE will remove the node's ability to operate in the cell."
	echo "\tA reconfiguration of the node will be required.  This node"
	echo "\tshould be unconfigured before a REMOVE is done.  You may REMOVE"
	echo "\twithout unconfiguring if you are destroying the cell."
	echon "\tDo you wish to continue (y/n)? (n) "
	read remove_response
	remove_response=${remove_response:-"n"}
	log_msg VERBOSE "User entry: $remove_response"
    else
	remove_response="y"
    fi
    if [ "$remove_response" = "y" ]
    then
	# Perform the REMOVE operation, no prompt
	clean_and_remove noprompt
    fi
}

#------------------------------------------------------
# settimezone()
#
# usage: settimezone
#
# Settimezone establishes a dce timezone setting by creating
# an ... /zoneinfo/localtime link if it does not
# yet exist.  When the hpux TZ environment variable contains 
# a recognizable value, the localtime link is set to point to 
# the corresponding dce timezone information file.  If TZ is
# not recognizable, the localtime link is set to point to GMT. 
#------------------------------------------------------

settimezone()
{
   log_msg DEBUG "Executing: settimezone()"
   if [ ! -h ${DCELOCAL}/etc/zoneinfo/localtime ]; then
      case "$TZ" in
         "MEZ-1MESZ")           tzfile="MET" ;;
         "MET-1METDST")         tzfile="MET" ;;
         "GMT0BST")             tzfile="GB-Eire" ;;
         "PST8PDT")             tzfile="US/Pacific" ;;
         "EST5EDT")             tzfile="US/Eastern" ;;
         "CST6CDT")             tzfile="US/Central" ;;
         "MST7MDT")             tzfile="US/Mountain" ;;
         "AST4ADT")             tzfile="Canada/Atlantic" ;;
         "NST3:30NDT")          tzfile="Canada/Newfoundland" ;;
         "EST5CDT")             tzfile="US/East-Indiana" ;;
         "AST10ADT")            tzfile="US/Aleutian" ;;
         "YST9YDT")             tzfile="Canada/Yukon" ;;
         "WET0WETDST")          tzfile="GB-Eire" ;;
         "PWT0PST")             tzfile="WET" ;;
         "SAST-2SADT")          tzfile="GMT+2" ;;
         "CST-9:30CDT")         tzfile="Australia/Yancowinna" ;;
         "EST-10EDT")           tzfile="Australia/NSW" ;;
         "NZST-12NZDT")         tzfile="NZ" ;;
         "EST-10EDT#Tasmania")  tzfile="Australia/NSW" ;;
         "PST8PDT#Canada")      tzfile="Canada/Pacific" ;;
         "MST7MDT#Canada")      tzfile="Canada/Mountain" ;;
         "CST6CDT#Canada")      tzfile="Canada/Central" ;;
         "EST5EDT#Canada")      tzfile="Canada/Eastern" ;;
         "EST6CDT")             tzfile="US/East-Indiana" ;;
         *)                     tzfile="GMT" ;;
      esac
      ln -s ${PRE_TZ_FILE}/$tzfile ${DCELOCAL}/etc/zoneinfo/localtime
      log_msg VERBOSE "DCE timezone set to $tzfile.  To change it, consult the Release Notes."
   else
      log_msg VERBOSE "DCE timezone already set.  To change it, consult the Release Notes."
   fi
}
# end of settimezone()


#------------------------------------------------------
# auth_login()
#
# Create all files necessary for dce_login to work on a client
#     create <DCELOCAL>/dce_cf.db
#     start the endpoint mapper
#     Create <DCELOCAL>/etc/security/pe_site file.  Note:
#         The pe_site file on the security server machine
# 	  is created with a canonicalized cellname.  Thus,
#	  the getcellname utility is provided to ensure
#	  this generated file's cellname is canonicalized.
# Once the above steps are done, a user can authenticate
#     from the client machine to the security server.
#------------------------------------------------------
auth_login()
{
     log_msg DEBUG "Executing: auth_login()"
     clear

     if [ ! -f $DCELOCAL/dce_cf.db ]
     then
	sec_server=${SEC_SERVER:="NULL"}
	until [ "${sec_server:="NULL"}" != "NULL" ]
	do
	    log_msg VERBOSE "User query: What is the name of a Security Server running in the cell you wish to join?  "
	    echon "\tWhat is the name of a Security Server running in the cell you wish to join?  "
	    read sec_server
	    log_msg VERBOSE "User entry: $sec_server"
	done

	ip=`getip ${sec_server}`
	if [ $? -ne 0 ]
	then
	    ip=${SEC_SERVER_IP:="NULL"}
	    until [ "${ip:="NULL"}" != "NULL" ]
	    do
		log_msg VERBOSE "User query: Enter the IP address for $sec_server:  "
		echon "\tEnter the IP address for $sec_server:  "
		read ip
		log_msg VERBOSE "User entry: $ip"
	    done
	fi

	create_dcecfdb
     fi

     config_epmap

     # Create $DCELOCAL/etc/security/pe_site file that matches
     # security server version

     if [ ! -f $DCELOCAL/etc/security/pe_site ]
     then

	checktime $sec_server

	# Create the pe_site file by matching the pe_site file of the remote
        # Security server using dced.  If the remote Security server is not
        # running dced, then the dcecp command will fail and the code will
        # use the rpccp mapping command.

	log_msg VERBOSE "Creating $DCELOCAL/etc/security/pe_site file."
	dcecp -c attrlist getvalues [hostdata show ${CONFIG_PROTSEQ}:${ip} \
	 -ifname pe_site] -type hostdata/data > /tmp/pe_site 2>/dev/null

	if [ $? -ne 0 ]
	then
	    rpccp show mapping ${CONFIG_PROTSEQ}:${ip} | awk 'BEGIN{found = 0;}
	    {
		if ($1 == "<object>") {
			object=$2;
			interface="";
			binding="";
			annotation="";
		} else if ($1 == "<interface" && $2 == "id>") {
			interface=$3;
		} else if ($1 == "<string" && $2 == "binding>") {
			binding=$3;
		} else if ($1 == "<annotation>") {
			annotation=$2;
			if (interface == "4c878280-5000-0000-0d00-028714000000,1.0") {
				split(binding, t, "[");
				printf("%s@%s[]\n", object, t[1]);
				found = 1;
			}
		}
	}
	END {
		if (!found) {
			print "dce_config failed to find sec server uuid";
		}
	    }' | sed "s:^:$cellname :" > ${DCELOCAL}/etc/security/pe_site

            grep failed ${DCELOCAL}/etc/security/pe_site >/dev/null 2>&1
            if [ $? -eq 0 ]
            then
                rm -f ${DCELOCAL}/etc/security/pe_site
		err_exit "Unable to get object uuid of security server.  \
Check that $EPMAP and secd are running on \"$sec_server\" ($ip) and retry the configuration.  \
Continuing will return to the Main Menu."
                menu0
            fi
        else
            cat /tmp/pe_site | cut -d{ -f2 | cut -d} -f1 \
                 > ${DCELOCAL}/etc/security/pe_site 2>/dev/null
        fi
        rm -f /tmp/pe_site

        chmod 644 ${DCELOCAL}/etc/security/pe_site

        log_msg VERBOSE "The entry created in the ${DCELOCAL}/etc/security/pe_site file \
must match one of the entries in the pe_site file of the master security server." 

     fi
}

#------------------------------------------------------
#
# is_sec_consistent()
#
# This function runs the dcecp registry verify 
# command to check for consistency.
#
#------------------------------------------------------
is_sec_consistent()
{
        log_msg DETAIL "Executing: dcecp -c registry verify"
        not_uptodate=`dcecp -c registry verify`
        if [ ! -z "$not_uptodate" ]; then
                return 1
        fi
        return 0
}

#------------------------------------------------------
#
# verify_consistency()
#
# This function is used to ensure that the security
# master server and its slaves are consistent.
#
#------------------------------------------------------
verify_consistency()
{
        log_msg SUMMARY "Waiting for registry propagation..."
        count=20
        i=5
        while [ "$i" -le "$count" ]
        do
                is_sec_consistent
                if [ "$?" -eq 0 ]; then
                        break
                fi
                i=`expr $i + 5`
                sleep 5
        done
        if [ "$i" -gt 20 ]; then
                return 1
        fi
        return 0
}

#------------------------------------------------------
# checktime()
#
# Usage: checktime <server node>
#
#  Checktime synchronizes current node's system time with the server node's.
#  It will update the current node's system time if the time difference is
#  greater than $tol_sec (initialized from $TOLERANCE_SEC).
#

checktime()
{
	if [ "$check_time" = "n" ]; then
		return
	fi
	sserver=$1
	log_msg DEBUG "Executing: checktime($sserver)"

	time_server=${TIME_SERVER}
	if [ -z "$time_server" ]; then
		echo " "
		echo "\tDCE requires close synchronization of clocks.  During normal"
		echo "\tcell operation, DTS takes care of this.  However during"
		echo "\tconfiguration, there needs to be at least 1 DTS server"
		echo "\tto sync with.  Usually this is the DTS server on the"
		echo "\tsecurity master machine."
		echo " "
		log_msg VERBOSE "User query: Do you wish to check the local clock against a dtsd server?"
		echon "\tDo you wish to check the local clock against a dtsd server? (y) "
		read answer
		if [ -z "$answer" ]; then
			answer="y"
		fi
		case $answer in
			y*) ;;
			*)  return ;;
		esac
		
		log_msg VERBOSE "User query: Enter a machine which has a DTS server running on it ($sserver):"
		echon "\tEnter a machine which has a DTS server running on it: ($sserver) "
		read time_server
		log_msg VERBOSE "User entry: $time_server"
		if [ -z "$time_server" ]; then
			time_server=$sserver
		fi
	fi
	
	log_msg DETAIL "Executing: dtsdate -s -q $time_server $tol_sec"
	dtsdate -s -q $time_server $tol_sec >/dev/null 2>&1
	st=$?
	if [ $st -eq 0 ]; then
		log_msg SUMMARY "Time on $HOSTNAME is within specified tolerance ($tol_sec sec) of time on $time_server."

	elif [ $st -eq 1 ]; then
		log_msg WARNING "Could not contact dtsd on $time_server. Be sure clocks are synchronized before continuing."
		x_exit;

	else  # clocks out of sync
		log_msg SUMMARY "Time on $HOSTNAME is not within specified tolerance ($tol_sec sec) of time on $time_server."
		mydate=`dtsdate`
		itsdate=`dtsdate $time_server`
		log_msg SUMMARY "Time on $HOSTNAME:	$mydate"
		log_msg SUMMARY "Time on $time_server: 	$itsdate"
		if [ -z "$SYNC_CLOCKS" ]; then
		    log_msg VERBOSE "User query: Do you wish to sync the clock of this machine?"
		    echon "\tDo you wish to sync the clock of this machine? (y) "
		    read answer
		    log_msg VERBOSE "User entry: $answer"
		    if [ -z "$answer" ]; then
			answer="y"
		    fi
		else
		    answer=${SYNC_CLOCKS}
		fi
		case $answer in
			y*) ;;
			*)  return ;;
		esac
		log_msg DETAIL "Executing: dtsdate -s $time_server $tol_sec"
		dtsdate -s $time_server $tol_sec
		if [ $? != 0 ]; then
			log_msg WARNING "Could not set clock on $HOSTNAME. Be sure clocks are synchronized before continuing."
			x_exit;
		else
			log_msg SUMMARY "Clock set on $HOSTNAME to match $time_server"
		fi
	fi

}


#------------------------------------------------------
# menu2()
#
# Display DCE Configuration Menu, allow selection of
# the option, and invoke the appropriate configuration
# routine.
# For additional server or client configurations, the
#     necessary files are created to allow the user to
#     authenticate to the security server and the user
#     authenticates prior to invoking these configurations.
#------------------------------------------------------
menu2()
{
    # this menu can be returned to by its called functions
    while :
    do
	clear
	LIST="1 2 3 4 98 99"
	export LIST 

	log_msg VERBOSE "User query: DCE Configuration Menu (on $HOSTNAME)"
	echo "\n\n\n"
	echo "\t DCE Configuration Menu ( on ${HOSTNAME} )"
	echo "\n"
	echo "\t 1. Initial Cell Configuration"
	echo "\t 2. Additional Server Configuration"
	echo "\t 3. DCE Client"
	echo "\t 4. DFS Client"
	echo "\n"
	echo "\t98. Return to previous menu"
	echo "\t99. Exit"
	echo "\n\n"
	echon "\tselection:  "

	get_option

	# Only allow one option to be selected
	one_option

        # Note there's no need to check for an invalid option, because
        # the get_option routine already did that.
	log_msg VERBOSE "User entry: $opt"
	case $opt in
		 1)	log_msg SUMMARY "Configuring initial cell...";
			settimezone; menu3;;
		 2)	log_msg SUMMARY "Configuring additional server...";
			log_msg SUMMARY "Please wait for user authentication and authorization...";
			settimezone; auth_login; verify_auth; menu4;;
		 3)	log_msg SUMMARY "Configuring client...";
			clean_and_remove prompt;
			settimezone; auth_login; verify_auth; config_client;;
		 4)	log_msg SUMMARY "Configuring DFS client...";
			check_app_prereqs;
			dfs_config_call config_dfs_client;;
		98)	return ;;
               	99)	menu99;;
	esac
    done
}

#------------------------------------------------------
# menu3()
#
# Display DCE Initial Cell Configuration Menu, allow 
# selection of the option, and invoke the appropriate 
# configuration routine.
# For a CDS Server, the necessary files are created
# that allow a user to authenticate to the Security
# Server prior to beginning CDS configuration.
#------------------------------------------------------
menu3()
{
    while :
    do
	clear

	LIST="1 2 3 98 99"
	export LIST

	log_msg VERBOSE "User query: Initial Cell Configuration menu (on $HOSTNAME)"
	echo "\n\n\n"
	echo "\t Initial Cell Configuration ( on ${HOSTNAME} )"
	echo "\n"
	echo "\t 1. Initial Security Server"
	echo "\t 2. Initial CDS Server"
	echo "\t 3. Initial DTS Server"
	echo "\n"
	echo "\t98. Return to previous menu"
	echo "\t99. Exit"
	echo "\n\n"
	echon "\tselection:  "

	get_option

	log_msg VERBOSE "User entry: $opt"
	for optionitem in $opt 
	do
		# Note there's no need to check for an invalid option, because
		# the get_option routine already did that.
		case $optionitem in
			1)	log_msg SUMMARY "Configuring initial Security Server...";
				clean_and_remove prompt; config_sec;;
			2)	log_msg SUMMARY "Configuring initial CDS Server...";
				log_msg SUMMARY "Please wait for user authentication and authorization...";
				auth_login; verify_auth; config_cds;;
			3)	log_msg SUMMARY "Configuring initial DTS services";
				log_msg SUMMARY "Please wait for user authentication and authorization...";
				auth_login; verify_auth; dtsconfig;;
				
				
			98)	return;;
			99)	menu99;;
		esac
	done
    done	# repeat until they want out
}

#------------------------------------------------------
# verify_auth()
#
# Ensure the user is authenticated as a member of the
# sec-admin group.  
#
# Note the use of the dce_login_noexec feature.  This
# binary is simply a link to dce_login, but has a different
# name.  The name of the executable is checked within the
# dce_login code, and if the name is "dce_login_noexec" then
# no sub-shell is exec'ed.  This feature is intended only
# for use by this configuration script, so is PURPOSELY
# not documented.  Note that dce_login_noexec is always
# removed upon exit from this script.
#------------------------------------------------------
verify_auth()
{
	log_msg DEBUG "Executing: verify_auth()"
	# Force the user to get a ticket as $celladmin
	# Ensure the user is in the sec-admin group
	klist 2>/dev/null | grep sec-admin >/dev/null 2>&1
        if [ $? -ne 0 -o "$cellpw" = "NULL" ]
	then
		log_msg DEBUG "Executing: dcelogin (from verify_auth)"
		dcelogin
		if [ $? -ne 0 ]; then
			menu0
		fi
        fi
}

#------------------------------------------------------
# menu4()
#
# Display DCE Additional Server Configuration Menu, allow selection 
# of the option, and invoke the appropriate configuration
# routine.
#------------------------------------------------------
menu4()
{

    while :
    do

	clear

	if [ "$UNAME" != "HP-UX" ]
	then
		LIST="1 2 3 4 5 6 7 8 9 10 11 12 98 99"
	else
		LIST="1 2 3 4 5 6 7 8 9 10 11 98 99"
	fi
	export LIST

	log_msg VERBOSE "User query: Additional Server Configuration menu (on $HOSTNAME)"
	echo "\n\n\n"
	echo "\t Additional Server Configuration ( on ${HOSTNAME} )"
	echo "\n"
	echo "\t 1. Additional CDS Server(s)"
	echo "\t 2. DTS"
	echo "\t 3. DFS System Control Machine"
	echo "\t 4. DFS Private File Server"
	echo "\t 5. DFS File Server"
	echo "\t 6. DFS Fileset Location Database Server"
	echo "\t 7. GDA Server"
	echo "\t 8. Replica Security Server"
	echo "\t 9. Auditing"
	echo "\t 10. Password Management Server"
	echo "\t 11. Unconfigure Password Management Server"
	if [ "$UNAME" != "HP-UX" ]
	then
		echo "\t 12. PKSS Server"
	fi
	echo "\n"
	echo "\t98. Return to previous menu"
	echo "\t99. Exit"
	echo "\n\n"
	echon "\tselection:  "

	get_option

	log_msg VERBOSE "User entry: $opt"
	for optionitem in $opt 
	do
		# Note there's no need to check for an invalid option, because
		# the get_option routine already did that.
		case $optionitem in

			1)	log_msg SUMMARY "Configuring additional CDS Server...";
				config_morecds;
				menu2;;
			2)	log_msg SUMMARY "Configuring DTS...";
				dtsconfig;;
			3)	log_msg SUMMARY "Configuring DFS System Control Machine...";
				check_app_prereqs;
				dfs_config_call config_dfsscm;;
			4)	log_msg SUMMARY "Configuring DFS Private File Server...";
				check_app_prereqs;
				dfs_config_call config_dfsprivatefs;;
			5)	log_msg SUMMARY "Configuring DFS File Server...";
				check_app_prereqs;
				dfs_config_call config_dfsfs;;
			6)	log_msg SUMMARY "Configuring DFS Fileset Location Database Server...";
				check_app_prereqs;
				dfs_config_call config_dfsfldb;;
			7)	log_msg SUMMARY "Configuring GDA Server...";
				config_gda;;
			8)      log_msg SUMMARY "Configuring Security Replication";
				config_secreplica;;
			9)	log_msg SUMMARY "Configuring Audit...";
				config_audit;;
			10)	#no log msg here because pwd_config generates its own;
			        config_pwd_mgmt;;
			11)	#no log msg here because pwd_config generates its own;
				config_pwd_mgmt -unconfig;;

			12)	log_msg SUMMARY "Configuring PKSS Server...";
				config_pkss_svr;;

			98)	return;;
			99)	menu99;;
		esac
	done
    done
}

#------------------------------------------------------
# menu5()
#
# Display DCE Start-Up Menu.  This menu simply invokes
# the /etc/rc.dce script.
#------------------------------------------------------
menu5()
{
	log_msg DEBUG "Executing: menu5()"
	log_msg SUMMARY "Attempting to start all configured DCE daemons..."
	if [ ! -f $RC_DCE ]
	then
		err_exit "DCE must be installed and configured prior to starting DCE.  Continuing will return to the Main Menu."
		return
	else
		log_msg DEBUG "Executing: BIND_PE_SITE=0"
		BIND_PE_SITE=0
                
                log_msg DEBUG "Executing: $RC_DCE"
                $RC_DCE
                if [ $? -eq 0 ]
                then
                        log_msg SUMMARY "Successfully started all configured DCE daemons."
                else
                        log_msg VERBOSE "Executing: BIND_PE_SITE=1"
                        BIND_PE_SITE=1
                        err_exit "Failed to start all configured DCE daemons.  Continuing will return to the Main Menu."
                        return
                fi

                log_msg VERBOSE "Executing: BIND_PE_SITE=1"
                BIND_PE_SITE=1

                #
                # Make sure that the /opt/dcelocal/var/adm/time/dtsd.acl file
                # is created with 644 permissions.  It currently isn't because
                # dce_config sets the umask to 000.
                #
                chmod 644 ${DCELOCAL}/var/adm/time/dtsd.acl > /dev/null 2>&1

        fi
}

#------------------------------------------------------
# menu6()
#
# Display DCE Clean-Up Menu .  This menu slays all running 
# DCE daemons.
#------------------------------------------------------
menu6()
{
    log_msg DEBUG "Executing: menu6()"
    log_msg SUMMARY "Attempting to stop all running DCE daemons..."
    if [ ! -x ${DCE_BIN}/dce_shutdown ]
    then
       err_exit "DCE must be installed and configured prior to stopping DCE daemons. \
Continuing will return to the Main menu."
       return
    else
        log_msg DEBUG "Executing: ${DCE_BIN}/dce_shutdown"
        ${DCE_BIN}/dce_shutdown
	if [ $? -eq 0 ]
	then
	    log_msg SUMMARY "Successfully stopped all running DCE daemons."
	else
            if [ "$do_checks" = "y" ]; then
                x_exit
            fi
        fi
    fi
}

#------------------------------------------------------
# menu99()
#
# Exit Menu.  Quit the program.
#------------------------------------------------------
menu99()
{
  log_msg DEBUG "Executing: menu99()"
  log_msg SUMMARY "Exiting from dce_config."
  if [ "$CHANGE_PW" = "y" ]; then
	log_msg WARNING "The password for the \"$celladmin none none\" user is a well-known default value.  Since this is a security hole, it is recommended that the password be changed immediately after exiting this script by using \"dce_login\", then the \"rgy_edit change\" command."
  fi

  # Remove the undocumented dce_login_noexec binary, so it's not available
  # to anyone other than this script.
  log_msg VERBOSE "Executing: rm -f /usr/bin/dce_login_noexec"
  rm -f /usr/bin/dce_login_noexec

  exit
}

#---------------------------------------------------
# These are the install functions for DCE
#---------------------------------------------------

#---------------------------------------------------
#
# SET_CP_OR_SYMLINK()
#
# If CP_OR_SYMLINK is set to "link", the "install_list()" 
# install_appdev(), and copy_libs() functions will
# refrain from copying binaries into $DCELOCAL/bin 
# (by symlinking them instead).
#
#---------------------------------------------------
SET_CP_OR_SYMLINK()
{
	log_msg DEBUG "Executing: SET_CP_OR_SYMLINK()"
	if [ -z "$CP_OR_SYMLINK" ]
	then
		clear
		echo "\n\n\n"
		echo "\tBy default, the DCE binaries will be COPIED from the"
		echo "\tinstall tree into $DCELOCAL/bin.  In order to save"
		echo "\tsave space, you can choose to simply symlink them instead."
		echo "\n"
		echo "\t 1. Copy"
		echo "\t 2. Symlink"
		echo "\n"
		echon "\tChoose either 1 or 2: "
		LIST="1 2"
		get_option
		one_option
		case $opt in
		     1)    CPCMD="cp";;
		     2)    CPCMD="ln -s ";;
		esac
	else
		case $CP_OR_SYMLINK in
			link)	CPCMD="ln -s ";;
			copy) 	CPCMD="cp";;
			*)	CPCMD="cp";;
		esac
	fi
	export CPCMD
	return
}

#---------------------------------------------------
# get_binary_loc()
#
# This script finds the location of the DCE object code.
# It accepts input from the user as to the location of
# the binaries, and sets the appropriate environment
# variable ($DCESHARED) to this value.  
#---------------------------------------------------
get_binary_loc()
{
        clear

	if [ -z "$FILESYSTEM" -a -z "$MEDIA" ]
	then
		echo "\n\n\n"
		echo "\tLocation of DCE Binaries ( on ${HOSTNAME} )"
		echo "\n"
		echo "\t 1. Filesystem"
		echo "\t 2. Media"
		echo "\n"
		echon "\tselection:  "
	fi

	verify
	SET_CP_OR_SYMLINK
}

#---------------------------------------------------
# verify()
#
# This routine prompts the user for information about
# the binary locations they specified in the
# get_binary_loc routine.
#
# For a filesystem, the symbolic link structure for
# $DCESHARED and $DCELOCAL is created.
# For a media device, the install images are
# restored into $DCELOCAL.
#---------------------------------------------------
verify()
{
	if [ -z "$FILESYSTEM" -a -z "$MEDIA" ]
	then
		LIST="1 2"
		export LIST
		get_option
		one_option
		string=""
	fi
	if [ ! -z "$FILESYSTEM" ]; then
		opt=1
		string=$FILESYSTEM
	fi
	if [ ! -z "$MEDIA" ]; then
		opt=2
	fi

	case $opt in
		1)  REPEAT=0
			while [ $REPEAT -eq 0 ]
			do
				if [ -z "$string" ]; then
					echo "\n"
					echo "\tEnter the full path to the DCE binary install tree."
					echo "\tThis will be a path that ends with the"
					echon "\t...${DCEINSTDIR} directory: "
					get_string
					DCEINST=${string:-$DCEINSTDIR}
				else
					DCEINST=$string
					string="" # so if its not valid, ask
				fi
				export DCEINST
				# Does $DCEINST exist?  It must, or binaries won't be located.
				ls $DCEINST >/dev/null 2>&1
				if [ $? -ne "0" ]
				then
					err_exit "$DCEINST is not a valid directory."
					REPEAT=0
				else
					# Ensure this directory has bin, etc, and 
					# nls subdirectories.  This helps verify 
					# the directory entered was really what was
					# intended.
					if [ -d $DCEINST/bin -a -d $DCEINST/etc -a -d $DCEINST/nls ]
					then
						# directory is probably valid, so use it.
						REPEAT=1
					else
						err_exit "$DCEINST must contain bin, etc, and nls subdirectories."
						REPEAT=0
					fi
				fi
			done

			# At this point, the filesystem directory $DCEINST 
			# exists and has a valid subdirectory structure.  Link 
			# /opt/dce${DCEVERSION} to this $DCEINST.
			ls $DCEINSTDIR >/dev/null 2>&1
			if [ $? -eq 0 ]
			then
				# $DCEINSTDIR (/opt/dce${DCEVERSION}) should be a symbolic 
				# link to $DCEINST, or should be the physical location 
				# of the installed code.  If $DCEINST != $DCEINSTDIR, 
				# then we need /opt/dce to be a sym link to the physical 
				# location of the code.

				# If they are equal, then nothing needs to be 
				# done as /opt/dce${DCEVERSION} CONTAINS the code to 
				# be installed.
				issymlink ${DCEINSTDIR}
				if [ $? -eq 0 ]
				then
					# /opt/dce${DCEVERSION} is a symbolic link to something.  
					# Ensure it's the link to $DCEINST, and correct 
					# it if not.  Otherwise, leave it alone.
					LINK=`ls -l $DCEINSTDIR | cut -f2 -d">" | cut -c2-`
					if [ "$DCEINST" != "$LINK" ]
					then
						echon "\n\t$DCEINSTDIR already exists, but is "
						echo "not linked to\n\t$DCEINST\n"
						echon "\t$DCEINSTDIR will be updated to point "
						echo "to this new binary"
						echo "\tinstall tree." 
						rm -f $DCEINSTDIR 2>/dev/null
						ln -s $DCEINST $DCEINSTDIR 2>/dev/null
					fi
				fi
			else
				# $DCEINST does NOT exist, so simply link it.
				ln -s $DCEINST $DCEINSTDIR 2>/dev/null
			fi
			# We now have /opt/dce${DCEVERSION} -> <install directory>, or have verified
			# that /opt/dce${DCEVERSION} contains the bin, etc, ... directory structure.

			# Check out $DCESHARED.  We want it to be a symlink to $DCEINSTDIR
			# i.e.  /opt/dce -> /opt/dce${DCEVERSION}
			issymlink ${DCESHARED}
			if [ $? -eq 1 ]		# not a symlink
			then
				# If $DCEINST is NOT the directory /opt/dce, but the directory 
				# /opt/dce exists, then remove the directory /opt/dce.
				if [ $DCEINST != $DCESHARED -a -d $DCESHARED ]
				then
					echo "\tInstall directory specified is not $DCESHARED,"
					echo "\tbut $DCESHARED exists.  Thus, it will be removed"
					x_exit "\tunless this script is exited."
					rm -rf $DCESHARED
				fi
					# Make /opt/dce a symbolic link to /opt/dce${DCEVERSION}
					ln -s $DCEINSTDIR $DCESHARED  2>/dev/null
			else # its a symlink or doesn't exists
				rm -f $DCESHARED
				ln -s $DCEINSTDIR $DCESHARED 2>/dev/null
			fi;;
		2)	
			if [ -z "$MEDIA" ]; then
				echon "\tEnter name of media device (/dev/rmt0):  ";
				get_string;
				DEV=${string:-/dev/rmt0};
			else
				DEV=$MEDIA
			fi
			export DEV;
			echo "\n\n"
			echo "\tMedia must be prepared by using the following:"
			echo "\n"
			echo "\tOn machine containing the complete install tree,"
			echo "\t\tcd <.../install/<machine>/opt>"
			x_exit "\t\ttar -cvf$DEV dce${DCEVERSION}"
			TAPE=1;
			export TAPE;

			if [ ! -d $DCEROOT ]
			then
			    mkdir $DCEROOT
			fi
			if [ ! -d $DCEINSTDIR ]
			then
			    mkdir $DCEINSTDIR
			fi
			issymlink ${DCESHARED}
			if [ $? -eq 2 ]
			then
			    # Make /opt/dce a symbolic link to /opt/dce${DCEVERSION}
			    # The media will be untarred into /opt/dce${DCEVERSION}
			    ln -s $DCEINSTDIR $DCESHARED  2>/dev/null
			else	
			  if [ $? -eq 0 ]
                          then
                            if [ "$DCEINST" != "$DCEINSTDIR" ]
                            then
                                   rm -f $DCEINSTDIR
                                   ln -s $DCEINST $DCEINSTDIR 2>/dev/null
				   if [ -d $DCELOCAL ]
				   then
                                      echo "\t$DCELOCAL may contain out of date binaries."
                                      echon "\tShould $DCELOCAL be removed? (y)  "
                                      get_string
                                      answer=${string:-"y"}
                                      case $answer in
                                           y) rm -rf $DCELOCAL;;
                                           yes) rm -rf $DCELOCAL;;
                                           *) ;;
                                      esac
                                      x_exit
				   fi
                            fi
                          fi
                        fi;;
	esac
}

#---------------------------------------------------
# issymlink()
#
# This routine checks to see if the directory needed is
# a symbolic link to a writable directory.  This is 
# necessary because Bourne shell has no built in test
# for a symbolic link.  (Bourne shell is used for this
# configuration script for portability purposes).
#
# This routine returns:
#		0 - if object exists and is a symlink
#		1 - if object exists and is NOT a symlink
#		2 - if object doesn't exist
#		
#---------------------------------------------------
issymlink()
{
	# Check to see if the object exists.  If not,
	# return a 2, which indicates the directory
	# needs to be created
	ls $1 >/dev/null 2>&1 || return 2

	if [ $? -eq 0 ]
	then
		# this is necessary because $DCELOCAL might be a symbolic
		# link to another filesystem.
		ls -ld $1 | grep "^[	 ]*l" >/dev/null
		if [ $? -eq 0 ]; then
		  	return 0
		else
		  	return 1
		fi
	else
		return 2
	fi
}

#---------------------------------------------------
# createdirstruct()
#
# Create the following directory structure if it isn't already there.
#            $DCEROOT
#             |
#         /dcelocal---\-----------\------\------\
#       /    |      \   \          \      \      \
#    /bin   /etc    /lib   /nls   /var   /ext  /$SHLIB_RDN
#                           |
#                          /msg
#                           |
#                          /<nlsdir>
#
#---------------------------------------------------
create_dirstruct()
{
	if [ ! -z "$DIRLIST" ]; then
		return
	fi

	DIRLIST="$DCELOCAL     
                 $DCELOCAL/bin
                 $DCELOCAL/var
                 $DCELOCAL/lib
                 $DCELOCAL/shlib
                 $DCELOCAL/etc
                 $DCELOCAL/ext
                 $DCELOCAL/usr
		 $DCELOCAL/usr/man
		 $DCELOCAL/usr/lib
                 $DCELOCAL/nls
                 $DCELOCAL/nls/msg
                 $DCELOCAL/$NLSDIR"

	export DIRLIST

	for i in $DIRLIST
	do
		# If the object is NOT a directory, then
		# ensure it is also not a symbolic link.
		# Create it if non-existent, ensuring permissions
		# are correct.
		if [ ! -d $i ]; then
			setdirperms ${i} || \
			   { issymlink ${i}
			   if [ $? -ne 0 ]; then
				err_exit "can not create $i"
			   fi
			  }
		# The directory already exists, so ensure it has
		# write permission.
		elif [ ! -w $i ]; then
			echo "$i doesn't have write permission"
			if [ $i -eq "$DCEROOT" ]
			then
				err_exit "Ensure this script is run by root, and installation directory is readable"
			fi
		fi
	done
}

#---------------------------------------------------
# copy_libdce()
#
# Copy libdce.a if it doesn't exist, or if the 
# $DCELOCAL/lib version is out of date.
#---------------------------------------------------
copy_libdce()
{
   # if there is a shared library use it instead of libdce.a
   if [ -f $DCESHARED/usr/$SHLIB_RDN/libdce${SHLIB_SUF} ]
   then
	DIRLIBDCE=$SHLIB_RDN/libdce${SHLIB_SUF}
	DIRLIBDCECP=$SHLIB_RDN/libdcecp${SHLIB_SUF}
	DIRLIBDCED=$SHLIB_RDN/libdcedpvt${SHLIB_SUF}
	JUSTLIB=libdce${SHLIB_SUF}
	JUSTLIBDCECP=libdcecp${SHLIB_SUF}
	JUSTLIBDCED=libdcedpvt${SHLIB_SUF}
	JUSTDIR=$SHLIB_RDN
   else
	DIRLIBDCE=lib/libdce.a
	DIRLIBDCECP=lib/libdcecp.a
	DIRLIBDCED=lib/libdcedpvt.a
	JUSTLIB=libdce.a
	JUSTLIBDCECP=libdcecp.a
	JUSTLIBDCED=libdcedpvt.a
	JUSTDIR=lib
   fi
   NO_UPDATE=0
   if [ -f $DCELOCAL/$DIRLIBDCE ]
   then 
	# Compare the files.  If different, rm the old one.
	# If the same, set the NO_UPDATE flag.
	cmp -s $DCESHARED/usr/$DIRLIBDCE $DCELOCAL/$DIRLIBDCE 
   	if [ $? -ne 0 ]
   	then
		# The files differ, so overwrite the old version.
		rm $DCELOCAL/$DIRLIBDCE
	else
		# The files are the same, so no update is necessary
	       	NO_UPDATE=1
	fi
   fi
   if [ $NO_UPDATE != 1 -a -w $DCELOCAL/$JUSTDIR ]
   then
	# If NO_UPDATE is NOT set, and the $DCELOCAL/$JUSTDIR directory
	# is writable, then install the new libdce.a and link it
	# to /usr/$DIRLIBDCE
	echo "\t\tcopying $JUSTLIB to /usr/$JUSTDIR..."
	if [ -z "$CPCMD" -o "$CPCMD" = "cp" ]; then
 	  cp $CPOPT $DCESHARED/usr/$DIRLIBDCE $DCELOCAL/$DIRLIBDCE || \
 		{ err_exit "Can't create $DCELOCAL/$DIRLIBDCE";  }
          cp $CPOPT $DCESHARED/usr/$DIRLIBDCECP $DCELOCAL/$DIRLIBDCECP || \
 		{ err_exit "Can't create $DCELOCAL/$DIRLIBDCECP";  }
          cp $CPOPT $DCESHARED/usr/$DIRLIBDCED $DCELOCAL/$DIRLIBDCED || \
 		{ err_exit "Can't create $DCELOCAL/$DIRLIBDCED";  }
	else
	  $CPCMD $DCESHARED/usr/$DIRLIBDCE $DCELOCAL/$DIRLIBDCE || \
		{ err_exit "Can't create link for $DCELOCAL/$DIRLIBDCE"; }
	  $CPCMD $DCESHARED/usr/$DIRLIBDCECP $DCELOCAL/$DIRLIBDCECP || \
		{ err_exit "Can't create link for $DCELOCAL/$DIRLIBDCECP"; }
	  $CPCMD $DCESHARED/usr/$DIRLIBDCED $DCELOCAL/$DIRLIBDCED || \
		{ err_exit "Can't create link for $DCELOCAL/$DIRLIBDCED"; }
	fi
 	rm -f /usr/$DIRLIBDCE /usr/$DIRLIBDCECP /usr/$DIRLIBDCED
 	ln -s $DCELOCAL/$DIRLIBDCE /usr/$DIRLIBDCE 2>/dev/null
 	ln -s $DCELOCAL/$DIRLIBDCECP /usr/$DIRLIBDCECP 2>/dev/null
 	ln -s $DCELOCAL/$DIRLIBDCED /usr/$DIRLIBDCED 2>/dev/null

	# On SVR4 systems, install reentrant libs and libdce${SHLIB_SUF} (no lib_admin needed)
	if [ "$UNAME" = "SVR4" ]; then
		echo "\t\tinstalling libdce${SHLIB_SUF} and reentrant shared libraries..."
		SHLIBS="libc_r${SHLIB_SUF}.1 \
			libcwrap${SHLIB_SUF} \
			libnsl_r_d${SHLIB_SUF} \
			libnsl_r_i${SHLIB_SUF} \
			libresolv_r${SHLIB_SUF} \
			libsocket_r${SHLIB_SUF} \
			tcpip_r${SHLIB_SUF} \
			libdce${SHLIB_SUF} \
			libdpeacl${SHLIB_SUF} \
			libprs_threaded${SHLIB_SUF}"
		for i in $SHLIBS
		do
		  if [ -z "$CPCMD" -o "$CPCMD" = "cp" ]; then
	    	    cp $DCESHARED/usr/lib/$i $DCELOCAL/lib || \
		    { err_exit "Can't create $DCELOCAL/lib/$i";  }
		  else
	            $CPCMD $DCEINST/usr/lib/$i $DCELOCAL/lib/$i || \
		    { err_exit "Can't create link for $DCELOCAL/lib/$i"; }
		  fi
		    
		done
		return 0
	fi

	if [ "$UNAME" = "OSF1" ]
	then
#	 If using a shared library, install it
	if [ "$JUSTLIB" = "libdce${SHLIB_SUF}" ]; then
		echo "\t\tinstalling libdce${SHLIB_SUF}..."
		grep -q "^/usr/$SHLIB_RDN/libdce${SHLIB_SUF}" /etc/lib_admin.conf
		if [ $? -ne 0 ]; then
		   if [ -w /etc/lib_admin.conf ]; then	
		      echo "\n/usr/$SHLIB_RDN/libdce${SHLIB_SUF}:" >> /etc/lib_admin.conf
		      echo "\tinstall=true"        >> /etc/lib_admin.conf
		      echo "\tpreload=true"        >> /etc/lib_admin.conf
		      echo ""                      >> /etc/lib_admin.conf
		   else
		      err_exit "Can not write to /etc/lib_admin.conf"
		   fi
		fi

#		  Check to see if libNDS.so has been previously installed.  If so,
#		  refresh the copy.
		grep -q "^/usr/$SHLIB_RDN/libNDS${SHLIB_SUF}" /etc/lib_admin.conf
		if [ $? -eq 0 ]; then
		  copy_libNDS
		fi		   

#		  Check to see if libdsal.so has been previously installed.  If so,
#		  refresh the copy.
		grep -q "^/usr/$SHLIB_RDN/libdsal${SHLIB_SUF}" /etc/lib_admin.conf
		if [ $? -eq 0 ]; then
		  copy_libdsal
		fi		   

		if [ -z "${DO_LIB_ADMIN}" ]; then
			echon "\t\tRun /sbin/lib_admin? (y)  "
			get_string
			answer=${string:-"y"}
			case $answer in
				y)   doit=1;;
				yes) doit=1;;
				*)   doit=0;;
			esac
		elif [ "${DO_LIB_ADMIN}" = "y" ]; then
			doit=1
		else
			doit=0
		fi

		if [ $doit -eq 1 ]; then
		        /sbin/lib_admin /etc/lib_admin.conf
			if [ $? -ne 0 ]; then
				err_exit "/sbin/lib_admin /etc/lib_admin.conf failed"
			fi
		fi
	fi
   else
	# If the $DCELOCAL/$JUSTDIR directory isn't writable, produce
	# an error message
	if [ ! -w $DCELOCAL/$JUSTDIR ]
	then
 		err_exit "$DCELOCAL/$JUSTDIR doesn't have write permission"
	fi
   fi
    fi
}

#---------------------------------------------------
# copy_libNDS()
#
# Copy libNDS.a if it doesn't exist, or if the 
# $DCELOCAL/lib version is out of date.
#---------------------------------------------------
copy_libNDS()
{
   # if there is a shared library use it instead of libNDS.a
   if [ -f $DCESHARED/usr/$SHLIB_RDN/libNDS${SHLIB_SUF} ]
   then
	DIRLIBNDS=$SHLIB_RDN/libNDS${SHLIB_SUF}
	JUSTDIR=$SHLIB_RDN
	JUSTLIB=libNDS${SHLIB_SUF}
   else
	DIRLIBNDS=lib/libNDS.a
	JUSTDIR=lib
	JUSTLIB=libNDS.a
   fi
   NO_UPDATE=0
   if [ -f $DCELOCAL/$DIRLIBNDS ]
   then 
	# Compare the files.  If different, rm the old one.
	# If the same, set the NO_UPDATE flag.
	cmp -s $DCESHARED/usr/$DIRLIBNDS $DCELOCAL/$DIRLIBNDS
   	if [ $? -ne 0 ]
   	then
		# The files differ, so overwrite the old version.
		rm $DCELOCAL/$DIRLIBNDS
	else
		# The files are the same, so no update is necessary
	       	NO_UPDATE=1
	fi
   fi
   if [ $NO_UPDATE != 1 -a -w $DCELOCAL/$JUSTDIR ]
   then
	# If NO_UPDATE is NOT set, and the $DCELOCAL/$JUSTDIR directory
	# is writable, then install the new libNDS.a and link it
	# to /usr/$DIRLIBNDS
	echo "\t\tcopying $JUSTLIB to /usr/$JUSTDIR..."
	if [ -z "$CPCMD" -o "$CPCMD" = "cp" ]; then
 	  cp $CPOPT $DCESHARED/usr/$DIRLIBNDS $DCELOCAL/$DIRLIBNDS || \
 		{ err_exit "Can't create $DCELOCAL/$DIRLIBNDS";  }
	else
	  $CPCMD $DCESHARED/usr/$DIRLIBNDS $DCELOCAL/$DIRLIBNDS || \
		{ err_exit "Can't create link for $DCELOCAL/$DIRLIBNDS"; }
	fi
 	rm -f /usr/$DIRLIBNDS
 	ln -s $DCELOCAL/$DIRLIBNDS /usr/$DIRLIBNDS 2>/dev/null
   else
	# If the $DCELOCAL/$JUSTDIR directory isn't writable, produce
	# an error message
	if [ ! -w $DCELOCAL/$JUSTDIR ]
	then
 		err_exit "$DCELOCAL/$JUSTDIR doesn't have write permission"
	fi
   fi

}

#---------------------------------------------------
# copy_libdsal()
#
# Copy libdsal.a if it doesn't exist, or if the 
# $DCELOCAL/lib version is out of date.
#---------------------------------------------------
copy_libdsal()
{
   # if there is a shared library use it instead of libdsal.a
   if [ -f $DCESHARED/usr/$SHLIB_RDN/libdsal${SHLIB_SUF} ]
   then
	DIRLIBdsal=$SHLIB_RDN/libdsal${SHLIB_SUF}
	JUSTDIR=$SHLIB_RDN
	JUSTLIB=libdsal${SHLIB_SUF}
   else
	DIRLIBdsal=lib/libdsal.a
	JUSTDIR=lib
	JUSTLIB=libdsal.a
   fi
   NO_UPDATE=0
   if [ -f $DCELOCAL/$DIRLIBdsal ]
   then 
	# Compare the files.  If different, rm the old one.
	# If the same, set the NO_UPDATE flag.
	cmp -s $DCESHARED/usr/$DIRLIBdsal $DCELOCAL/$DIRLIBdsal
   	if [ $? -ne 0 ]
   	then
		# The files differ, so overwrite the old version.
		rm $DCELOCAL/$DIRLIBdsal
	else
		# The files are the same, so no update is necessary
	       	NO_UPDATE=1
	fi
   fi
   if [ $NO_UPDATE != 1 -a -w $DCELOCAL/$JUSTDIR ]
   then
	# If NO_UPDATE is NOT set, and the $DCELOCAL/$JUSTDIR directory
	# is writable, then install the new libdsal.a and link it
	# to /usr/$DIRLIBdsal
	echo "\t\tcopying $JUSTLIB to /usr/$JUSTDIR..."
	if [ -z "$CPCMD" -o "$CPCMD" = "cp" ]; then
 	  cp $CPOPT $DCESHARED/usr/$DIRLIBdsal $DCELOCAL/$DIRLIBdsal || \
 		{ err_exit "Can't create $DCELOCAL/$DIRLIBdsal";  }
	else
	  $CPCMD $DCESHARED/usr/$DIRLIBdsal $DCELOCAL/$DIRLIBdsal || \
		{ err_exit "Can't create link for $DCELOCAL/$DIRLIBdsal"; }
	fi
 	rm -f /usr/$DIRLIBdsal
 	ln -s $DCELOCAL/$DIRLIBdsal /usr/$DIRLIBdsal 2>/dev/null
   else
	# If the $DCELOCAL/$JUSTDIR directory isn't writable, produce
	# an error message
	if [ ! -w $DCELOCAL/$JUSTDIR ]
	then
 		err_exit "$DCELOCAL/$JUSTDIR doesn't have write permission"
	fi
   fi

}

#---------------------------------------------------
# install_sec()
#
# Install script for Security
# 	Ensure the location of the binaries is known
#	Create any directories needed for the Security binaries
# 	Install the necessary Security binaries.
#---------------------------------------------------
install_sec()
{
	# Create Security specific directory structure if it
	# doesn't already exist.  Otherwise, ensure the
	# structure has write permission.
	SEC_DIRLIST="$DCELOCAL/etc/security
		     $DCELOCAL/var/security
                     /krb5"
	for i in $SEC_DIRLIST
	do
		if [ ! -d $i ]; then
			setdirperms ${i} || { err_exit "can not create $i"; }
		elif [ ! -w $i ]; then
			err_exit "$i doesn't have write permission"
		fi
	done

	LIST="sec_create_db secd pwd_strengthd sec_salvage_db"
	echo "\t\tinstalling $LIST ..."
	install_list 
}

#---------------------------------------------------
# install_cds()
#
# Install script for CDS
# 	Ensure the location of the binaries is known
#	Create any directories needed for the CDS binaries
# 	Install the necessary CDS binaries.
#	Install the GDA binaries.
#---------------------------------------------------
install_cds()
{
	# Create CDS specific directory structure if it
	# doesn't already exist.  Otherwise, ensure the
	# structure has write permission.
	CDS_DIRLIST="$DCELOCAL/var/directory
		     $DCELOCAL/var/directory/cds
		     $DCELOCAL/var/directory/cds/adm
		     $DCELOCAL/var/adm
		     $DCELOCAL/var/adm/directory
		     $DCELOCAL/var/adm/directory/cds"
	for i in $CDS_DIRLIST
	do
		if [ ! -d $i ]; then
			setdirperms ${i} || { err_exit "can not create $i"; }
		elif [ ! -w $i ]; then
			err_exit "$i doesn't have write permission"
		fi
	done

	# Install the cdsd binaries
	LIST="cdsd"
	echo "\t\tinstalling $LIST ..."
	install_list

	install_gda
}

#---------------------------------------------------
# install_gda()
#
# Install script for GDA
# 	Ensure the location of the binaries is known
#	Create any directories needed for the CDS binaries
# 	Install the necessary CDS binaries.
# This routine is invoked by the install_cds routine.
#---------------------------------------------------
install_gda()
{
	# Install the gda binaries

	LIST="gdad"
	echo "\t\tinstalling $LIST ..."
	install_list
}

#---------------------------------------------------
# install_dts()
#
# Install script for Time Service
# 	Ensure the location of the binaries is known
#	Create any directories needed for the DTS binaries
# 	Install the necessary DTS binaries.
#---------------------------------------------------
install_dts()
{
	# This routine is not required on SVR4 systems
	if [ "$UNAME" = "SVR4" ]; then
	    return 0
	fi

	if [ "$INSTALL_DTS_DONE" = "1" ]; then
		log_msg SUMMARY "DTS installation already done.."
		sleep 3
		return 0
	fi

	if [ -d $DCELOCAL/etc/zoneinfo ]; then
		rm -rf $DCELOCAL/etc/zoneinfo
	fi 

	DTS_LISTzoneinfo="CET Cuba EET Egypt Factory GB-Eire GMT
		GMT+0 GMT+1 GMT+2 GMT+3 GMT+4 GMT+5 GMT+6 GMT+7 GMT+8 GMT+9
		GMT+10 GMT+11 GMT+12 GMT+13
		GMT-0 GMT-1 GMT-2 GMT-3 GMT-4 GMT-5 GMT-6 GMT-7 GMT-8 GMT-9
		GMT-10 GMT-11 GMT-12
		GMT0 GMT1 GMT2 GMT3 GMT4 GMT5 GMT6 GMT7 GMT8 GMT9 GMT10 
		GMT11 GMT12 GMT13
		Greenwich Hongkong Iceland Iran Israel Jamaica Japan Libya
		MET NZ Navajo PRC Poland ROC ROK Singapore Turkey UCT UTC
		Universal W-SU WET Zulu posixrules
		Australia/LHI Australia/NSW Australia/North Australia/Queensland
		Australia/Tasmania Australia/Victoria
		Australia/West Australia/Yancowinna
		Brazil/Acre Brazil/DeNoronha Brazil/East Brazil/West
		Canada/Atlantic Canada/East-Saskatchewan Canada/Mountain
		Canada/Pacific Canada/Central Canada/Eastern Canada/Yukon
		Canada/Newfoundland
		Chile/Continental Chile/EasterIsland
		Mexico/BajaNorte Mexico/BajaSur Mexico/General
		SystemV/AST4 SystemV/AST4ADT SystemV/CST6 SystemV/CST6CDT
		SystemV/EST5 SystemV/EST5EDT SystemV/MST7 SystemV/MST7MDT
		SystemV/PST8 SystemV/PST8PDT SystemV/YST9 SystemV/YST9YDT
		SystemV/HST10
		US/Alaska US/Aleutian US/Arizona US/Central US/East-Indiana
		US/Eastern US/Hawaii US/Michigan US/Mountain US/Pacific US/Samoa"
		
	echo "\n\t\tinstalling zoneinfo files into $DCELOCAL/etc/zoneinfo..."

	LIST=$DTS_LISTzoneinfo
	read_media etc/zoneinfo

	log_msg DETAIL "Executing: cp $CPOPT -r $DCESHARED/etc/zoneinfo $DCELOCAL/etc/zoneinfo"
	cp $CPOPT -r $DCESHARED/etc/zoneinfo $DCELOCAL/etc/zoneinfo || \
            { err_exit "Can't copy $DCESHARED/etc/zoneinfo"; }

	# Create the appropriate /etc/zoneinfo link
	issymlink /etc/zoneinfo
	if [ $? = 1 ]; then
		echo "\tThe DCE version of the zoneinfo data files has been"
		echo "\tinstalled in $DCELOCAL/etc/zoneinfo.  You may need"
		echo "\tto replace /etc/zoneinfo with a link to this directory"
		x_exit "\tfor the DCE time component to work correctly."
	else
		log_msg DETAIL "Executing: rm -f /etc/zoneinfo"
		rm -f /etc/zoneinfo
		log_msg DETAIL "Executing: ln -s $DCELOCAL/etc/zoneinfo /etc/zoneinfo"
		ln -s $DCELOCAL/etc/zoneinfo /etc/zoneinfo 2>/dev/null || err_exit "Can't create /etc/zoneinfo link"
	fi

	INSTALL_DTS_DONE=1
}

#---------------------------------------------------
# install_gds()
#
# Install script for GDS
# 	Ensure the location of the binaries is known
#	Create any directories needed for the GDS binaries
# 	Install the necessary GDS binaries.
#---------------------------------------------------
install_gds()
{
	# Create GDS specific directory structure if it
	# doesn't already exist.  Otherwise, ensure the
	# structure has write permission.
	GDS_DIRLIST="$DCELOCAL/var/adm
                     $DCELOCAL/var/adm/directory
                     $DCELOCAL/var/adm/directory/gds
                     $DCELOCAL/var/adm/directory/gds/adm
                     $DCELOCAL/var/adm/directory/gds/conf
                     $DCELOCAL/var/adm/directory/gds/dua
                     $DCELOCAL/var/adm/directory/gds/cstub
                     $DCELOCAL/var/adm/directory/gds/cache
                     $DCELOCAL/var/adm/directory/gds/ipc
                     $DCELOCAL/var/adm/directory/gds/tmp
                     $DCELOCAL/var/directory
                     $DCELOCAL/var/directory/gds
                     $DCELOCAL/var/directory/gds/dsa
                     $DCELOCAL/var/directory/gds/adm
                     $DCELOCAL/var/directory/gds/adm/sstub
                     $DCELOCAL/var/directory/gds/adm/dsa
                     $DCELOCAL/gdscp"
			
	for i in $GDS_DIRLIST
	do
		if [ ! -d $i ]; then
			setdirperms ${i} || { err_exit "can not create $i";  }
		elif [ ! -w $i ]; then
			err_exit "$i doesn't have write permission";
		fi
	done

        chmod 777 $DCELOCAL/var/adm/directory/gds/ipc

	LISTa="gdscache gdscacheupd gdschdb gdscmxl gdsconf" 
	LISTb="gdscrontab gdscstub gdsdaemon gdsdbread"
	LISTc="gdsdbwrite gdsdeact gdsditadm gdsdsa gdsexec"
	LISTd="gdsgendb gdshdlcache gdshdlupd gdsinfo gdsipcchk"
	LISTe="gdsipcinit gdsipcstat gdslog gdsmkiss gdsmkupd"
	LISTf="gdssstub gdsstart gdsrosstep gdssysadm gdstransfer"
	LISTg="gdsdirinfo gdsutil gdslanguage gdsdistcmd "
	LISTh="gdscacheadm gdsgennsap ndscomp gdscp gdsstep gdssetup"
	echo "\t\tinstalling ${LISTa} ..."
	echo "\t\tinstalling ${LISTb} ..."
	echo "\t\tinstalling ${LISTc} ..."
	echo "\t\tinstalling ${LISTd} ..."
	echo "\t\tinstalling ${LISTe} ..."
	echo "\t\tinstalling ${LISTf} ..."
	echo "\t\tinstalling ${LISTg} ..."
	echo "\t\tinstalling ${LISTh} ..."
	LIST="$LISTa $LISTb $LISTc $LISTd $LISTe $LISTf $LISTg $LISTh"
	install_list 

        LIST=".profile"
        TARGETDIR="share/var/adm/directory/gds"
	read_media ${TARGETDIR}

	LIST="adm_term_cap admscheme common countries newscheme nsapform nsapmacros NDSCONF.dat xoischema client.init server.init"
        TARGETDIR="share/var/adm/directory/gds/adm"
	read_media ${TARGETDIR}

	LIST="asn1_attr dirparam ipcconf nsapform.cfg NDSCONF.DIB"
        TARGETDIR="share/var/adm/directory/gds/conf"
	read_media ${TARGETDIR}

	cp $CPOPT $DCESHARED/share/var/adm/directory/gds/.profile \
                          $DCELOCAL/var/adm/directory/gds ||
		{ err_exit "Can not create $DCELOCAL/var/adm/directory/gds/.profile"; }
	cp $CPOPT $DCESHARED/share/var/adm/directory/gds/adm/* \
                          $DCELOCAL/var/adm/directory/gds/adm ||
		{ err_exit "Can not create $DCELOCAL/var/adm/directory/gds/adm"; }
	cp $CPOPT $DCESHARED/share/var/adm/directory/gds/conf/* \
                          $DCELOCAL/var/adm/directory/gds/conf ||
		{ err_exit "Can not create $DCELOCAL/var/adm/directory/gds/conf"; }
	cp $CPOPT $DCESHARED/share/var/directory/gds/dsa/* \
                          $DCELOCAL/var/directory/gds/dsa||
		{ err_exit "Can not create $DCELOCAL/var/directory/gds/dsa"; }

	cp $CPOPT $DCESHARED/gdscp/init.gdscp \
			  $DCELOCAL/gdscp/init.gdscp ||
		{ err_exit "Can not create $DCELOCAL/gdscp/init.gdscp"; }

	copy_libNDS
	copy_libdsal

	if [ "$UNAME" = "OSF1" ]
	then
		echo "\t\tinstalling libNDS${SHLIB_SUF}..."
		grep -q "^/usr/$DIRLIBNDS" /etc/lib_admin.conf
		if [ $? -ne 0 ]; then
		   if [ -w /etc/lib_admin.conf ]; then	
		      echo "\n/usr/$DIRLIBNDS:" >> /etc/lib_admin.conf
		      echo "\tinstall=true"        >> /etc/lib_admin.conf
		      echo "\tpreload=true"        >> /etc/lib_admin.conf
		      echo ""                      >> /etc/lib_admin.conf
		   else
		      err_exit "Can not write to /etc/lib_admin.conf"
		   fi  
		fi 
		echo "\t\tinstalling libdsal${SHLIB_SUF}..."
		grep -q "^/usr/$DIRLIBdsal" /etc/lib_admin.conf
		if [ $? -ne 0 ]; then
		   if [ -w /etc/lib_admin.conf ]; then	
		      echo "\n/usr/$DIRLIBdsal:" >> /etc/lib_admin.conf
		      echo "\tinstall=true"        >> /etc/lib_admin.conf
		      echo "\tpreload=true"        >> /etc/lib_admin.conf
		      echo ""                      >> /etc/lib_admin.conf
		   else
		      err_exit "Can not write to /etc/lib_admin.conf"
		   fi  
		fi 
		if [ -z "${DO_LIB_ADMIN}" ]; then
			echon "\t\tRun /sbin/lib_admin? (y)  "
			get_string
			answer=${string:-"y"}
			case $answer in
				y)   doit=1;;
				yes) doit=1;;
				*)   doit=0;;
			esac
		elif [ "${DO_LIB_ADMIN}" = "y" ]; then
			doit=1
		else
			doit=0
		fi

		if [ $doit -eq 1 ]; then
		        /sbin/lib_admin /etc/lib_admin.conf
			if [ $? -ne 0 ]; then
				err_exit "/sbin/lib_admin /etc/lib_admin.conf failed"
			fi 
		fi 
	fi 

if [ -f $DCELOCAL/etc/gdsconfig ]
then
	log_msg WARNING "GDS is already configured."
	log_msg VERBOSE "Do you want to remove the old GDS configuration?"
	echon "\tDo you want to remove the old GDS configuration? (n)  "
	read gds_answer
	gds_answer=${gds_answer:-"n"}
	log_msg VERBOSE "Answer was: $gds_answer"
	case $gds_answer in
		y|ye|yes) remove_old_gds=1;;
		*) remove_old_gds=0;;
	esac
else
	remove_old_gds=1
fi

if [ $remove_old_gds -eq 1 ]
then
	log_msg VERBOSE "removing gdsconfig ..."; \
	echo "\t\tremoving gdsconfig ..."; \
	rm -f $DCELOCAL/etc/gdsconfig
	log_msg VERBOSE "removing old dsa database ..."; \
	echo "\t\tremoving old dsa database ..."; \
	rm -rf $DCELOCAL/var/directory/gds/dsa/dir*
	log_msg VERBOSE "removing old dsa logdirs ..."; \
	echo "\t\tremoving old dsa logdirs ..."; \
	rm -rf $DCELOCAL/var/directory/gds/adm/dsa/dir*
	log_msg VERBOSE "removing old cache data ..."; \
	echo "\t\tremoving old cache data ..."; \
	rm -rf $DCELOCAL/var/adm/directory/gds/cache/*

	# run gdsmkiss, gdsgennsap and ndscomp

	(cd $DCELOCAL/var/directory/gds/dsa; \
	rm -f $DCELOCAL/var/directory/gds/dsa/attr*; \
	rm -f $DCELOCAL/var/directory/gds/dsa/conf; \
	rm -f $DCELOCAL/var/directory/gds/dsa/dversion; \
	rm -f $DCELOCAL/var/directory/gds/dsa/objects*; \
	log_msg DETAIL "running gdsmkiss ..."; \
	echo "\t\trunning gdsmkiss ..."; \
	gdsmkiss schema_ib -wNOTICE:DISCARD:- )

	(cd $DCELOCAL/var/adm/directory/gds/conf; \
      	log_msg DETAIL "running gdsgennsap ..."; \
      	echo "\t\trunning gdsgennsap ..."; \
      	gdsgennsap ../adm/nsapform nsapform.cfg; \
      	log_msg DETAIL "running ndscomp ..."; \
      	echo "\t\trunning ndscomp ..."; \
      	ndscomp ../adm/NDSCONF.dat)

	# preconfigure directory id. 1

	log_msg VERBOSE "configuring dir. id 1 ..."
	echo "\t\tconfiguring dir. id 1 ..."
	gdssysadm -fc -d1 -m1 -c2 -C16 -s2 -A2

	# copy asn1_attr from DSA database of directory id. 1 to client side

	log_msg VERBOSE "copying asn1_attr to client side ..."
	echo "\t\tcopying asn1_attr to client side ..."
	cp $CPOPT $DCELOCAL/var/directory/gds/dsa/dir1/asn1_attr \
        	$DCELOCAL/var/adm/directory/gds/conf
	sleep 1
else
	log_msg VERBOSE "\tusing old GDS configuration ..."
	echo "\tusing old GDS configuration ..."
	sleep 1
fi

}

#---------------------------------------------------
# install_gds_client()
#
# Install script for GDS Client
# 	Ensure the location of the binaries is known
#	Create any directories needed for the GDS binaries
# 	Install the necessary GDS binaries.
#---------------------------------------------------
install_gds_client()
{
	# Create GDS specific directory structure if it
	# doesn't already exist.  Otherwise, ensure the
	# structure has write permission.
	GDS_DIRLIST="$DCELOCAL/var/adm
                     $DCELOCAL/var/adm/directory
                     $DCELOCAL/var/adm/directory/gds
                     $DCELOCAL/var/adm/directory/gds/adm
                     $DCELOCAL/var/adm/directory/gds/conf
                     $DCELOCAL/var/adm/directory/gds/dua
                     $DCELOCAL/var/adm/directory/gds/cstub
                     $DCELOCAL/var/adm/directory/gds/cache
                     $DCELOCAL/var/adm/directory/gds/ipc
                     $DCELOCAL/var/adm/directory/gds/tmp
                     $DCELOCAL/gdscp"
			
	for i in $GDS_DIRLIST
	do
		if [ ! -d $i ]; then
			setdirperms ${i} || { err_exit "can not create $i";  }
		elif [ ! -w $i ]; then
			err_exit "$i doesn't have write permission";
		fi
	done

        chmod 777 $DCELOCAL/var/adm/directory/gds/ipc

	LISTa="gdscache gdscacheupd gdscmxl gdsconf" 
	LISTb="gdscrontab gdscstub gdsdbread"
	LISTc="gdsdbwrite gdsdeact gdsditadm gdsexec"
	LISTd="gdshdlcache gdsinfo gdsipcchk"
	LISTe="gdsipcinit gdsipcstat gdslog gdsmkiss gdsgendb"
	LISTf="gdsstart gdsrosstep gdssysadm"
	LISTg="gdsdirinfo gdsutil gdslanguage gdsdistcmd "
	LISTh="gdscacheadm gdsgennsap ndscomp gdscp gdsstep gdssetup"
	echo "\t\tinstalling ${LISTa} ..."
	echo "\t\tinstalling ${LISTb} ..."
	echo "\t\tinstalling ${LISTc} ..."
	echo "\t\tinstalling ${LISTd} ..."
	echo "\t\tinstalling ${LISTe} ..."
	echo "\t\tinstalling ${LISTf} ..."
	echo "\t\tinstalling ${LISTg} ..."
	echo "\t\tinstalling ${LISTh} ..."
	LIST="$LISTa $LISTb $LISTc $LISTd $LISTe $LISTf $LISTg $LISTh"
	install_list 

        LIST=".profile"
        TARGETDIR="share/var/adm/directory/gds"
	read_media ${TARGETDIR}

	LIST="adm_term_cap admscheme common countries newscheme nsapform nsapmacros NDSCONF.dat xoischema client.init server.init"
        TARGETDIR="share/var/adm/directory/gds/adm"
	read_media ${TARGETDIR}

	LIST="asn1_attr dirparam ipcconf nsapform.cfg NDSCONF.DIB"
        TARGETDIR="share/var/adm/directory/gds/conf"
	read_media ${TARGETDIR}

	cp $CPOPT $DCESHARED/share/var/adm/directory/gds/.profile \
                          $DCELOCAL/var/adm/directory/gds ||
		{ err_exit "Can not create $DCELOCAL/var/adm/directory/gds/.profile"; }
	cp $CPOPT $DCESHARED/share/var/adm/directory/gds/adm/* \
                          $DCELOCAL/var/adm/directory/gds/adm ||
		{ err_exit "Can not create $DCELOCAL/var/adm/directory/gds/adm"; }
	cp $CPOPT $DCESHARED/share/var/adm/directory/gds/conf/* \
                          $DCELOCAL/var/adm/directory/gds/conf ||
		{ err_exit "Can not create $DCELOCAL/var/adm/directory/gds/conf"; }
	cp $CPOPT $DCESHARED/share/var/directory/gds/dsa/schema_ib \
                          $DCELOCAL/var/adm/directory/gds/tmp ||
		{ err_exit "Can not create $DCELOCAL/var/adm/directory/gds/tmp/schema_ib"; }
	cp $CPOPT $DCESHARED/gdscp/init.gdscp \
			  $DCELOCAL/gdscp/init.gdscp ||
		{ err_exit "Can not create $DCELOCAL/gdscp/init.gdscp"; }

	copy_libNDS

	if [ "$UNAME" = "OSF1" ]
	then
		echo "\t\tinstalling libNDS${SHLIB_SUF}..."
		grep -q "^/usr/$DIRLIBNDS" /etc/lib_admin.conf
		if [ $? -ne 0 ]; then
		   if [ -w /etc/lib_admin.conf ]; then	
		      echo "\n/usr/$DIRLIBNDS:" >> /etc/lib_admin.conf
		      echo "\tinstall=true"        >> /etc/lib_admin.conf
		      echo "\tpreload=true"        >> /etc/lib_admin.conf
		      echo ""                      >> /etc/lib_admin.conf
		   else
		      err_exit "Can not write to /etc/lib_admin.conf"
		   fi  
		fi 
		if [ -z "${DO_LIB_ADMIN}" ]; then
			echon "\t\tRun /sbin/lib_admin? (y)  "
			get_string
			answer=${string:-"y"}
			case $answer in
				y)   doit=1;;
				yes) doit=1;;
				*)   doit=0;;
			esac
		elif [ "${DO_LIB_ADMIN}" = "y" ]; then
			doit=1
		else
			doit=0
		fi

		if [ $doit -eq 1 ]; then
		        /sbin/lib_admin /etc/lib_admin.conf
			if [ $? -ne 0 ]; then
				err_exit "/sbin/lib_admin /etc/lib_admin.conf failed"
			fi 
		fi 
	fi 

if [ -f $DCELOCAL/etc/gdsconfig ]
then
	log_msg WARNING "GDS is already configured."
	log_msg VERBOSE "Do you want to remove the old GDS configuration?"
	echon "\tDo you want to remove the old GDS configuration? (n)  "
	read gds_answer
	gds_answer=${gds_answer:-"n"}
	log_msg VERBOSE "Answer was: $gds_answer"
	case $gds_answer in
		y|ye|yes) remove_old_gds=1;;
		*) remove_old_gds=0;;
	esac
else
	remove_old_gds=1
fi

if [ $remove_old_gds -eq 1 ]
then
	log_msg VERBOSE "removing gdsconfig ..."; \
	echo "\t\tremoving gdsconfig ..."; \
	rm -f $DCELOCAL/etc/gdsconfig
	log_msg VERBOSE "removing old cache data ..."; \
	echo "\t\tremoving old cache data ..."; \
	rm -rf $DCELOCAL/var/adm/directory/gds/cache/*

	# run gdsgennsap and ndscomp

	(cd $DCELOCAL/var/adm/directory/gds/conf; \
	log_msg DETAIL "running gdsgennsap ..."; \
      	echo "\t\trunning gdsgennsap ..."; \
      	gdsgennsap ../adm/nsapform nsapform.cfg; \
	log_msg DETAIL "running ndscomp ..."; \
      	echo "\t\trunning ndscomp ..."; \
      	ndscomp ../adm/NDSCONF.dat)

	# preconfigure directory id. 1

	log_msg VERBOSE "configuring dir. id 1 as client system ..."
	echo "\t\tconfiguring dir. id 1 as client system ..."
	gdssysadm -fc -d1 -m1 -c1 -C16

	# generate asn1_attr and copy it to the appropriate place

	log_msg DETAIL "\t\tgenerate asn1_attr and copy it to the appropriate place"
	echo "\t\tgenerate asn1_attr and copy it to the appropriate place"
	(cd $DCELOCAL/var/adm/directory/gds/tmp; \
	 log_msg DETAIL "running gdsmkiss to generate input for gdsgendb ..."; \
	 echo "\t\trunning gdsmkiss to generate input for gdsgendb ..."; \
	 gdsmkiss schema_ib -wNOTICE:DISCARD:- ; \
	 log_msg DETAIL "running gdsgendb to generate asn1_attr ..."; \
	 echo "\t\trunning gdsgendb to generate asn1_attr ..."; \
	 gdsgendb . . -wNOTICE:DISCARD:- ; \
	 mv asn1_attr $DCELOCAL/var/adm/directory/gds/conf ; \
	 log_msg DETAIL "removing gdsgendb, gdsmkiss and generated files ..."; \
	 echo "\t\tremoving gdsgendb, gdsmkiss and generated files ..."; \
	 rm -f $DCELOCAL/var/adm/directory/gds/tmp/* ; \
	 rm -f $DCELOCAL/bin/gdsmkiss $DCELOCAL/bin/gdsgendb )
	sleep 1
else
	echo "\tusing old GDS configuration ..."
	sleep 1
fi

}

#---------------------------------------------------
# client()
#
# Install the common binaries if this machine
# doesn't already have libdce.a installed
#---------------------------------------------------
client()
{
	# Initialize CLIENT_INSTALLED to 0 only on first entry
	#
	if [ -z "${CLIENT_INSTALLED}" ]; then
		CLIENT_INSTALLED=0
	fi

	# if there is a shared library use it instead of libdce.a
	if [ -f $DCESHARED/usr/$SHLIB_RDN/libdce${SHLIB_SUF} ]
	then
	     DIRLIBDCE=$SHLIB_RDN/libdce${SHLIB_SUF}
	else
	     DIRLIBDCE=lib/libdce.a
	fi

	# if libdce.a is already in the DCELOCAL tree,
	# this routine has already been done for this machine.
	# There's no need to repeat it.
	if [ ! -f $DCELOCAL/$DIRLIBDCE ]
	then
		install_common
		CLIENT_INSTALLED=1
		if [ ! -d $DCELOCAL/etc/zoneinfo ]
		then
			install_dts
		fi
	else
                if [ ${CLIENT_INSTALLED} -eq 1 ]; then
                        echo "\t\tdefault client binaries already installed ..."
                        sleep 3
			return
                fi

		cmp -s $DCELOCAL/$DIRLIBDCE $DCESHARED/usr/$DIRLIBDCE
		if [ $? -ne 0 ]
		then
			install_common
			if [ ! -d $DCELOCAL/etc/zoneinfo ]
			then
				install_dts
			fi
		else
			echo "\t\tdefault client binaries already installed ..."
			sleep 3
			CLIENT_INSTALLED=1
		fi
	fi

	return
}

#---------------------------------------------------
#
# install_pkssd()
#
#---------------------------------------------------
install_pkssd()
{
	LIST="pkssd"

	echo "\t\tinstalling $LIST..."
	install_list

}

#---------------------------------------------------
# install_secreplica()
#
# Install secd and sec_create_db which are required for 
# the Security Replica.
#---------------------------------------------------
install_secreplica()
{
	LIST="secd sec_create_db pwd_strengthd sec_salvage_db"

	echo "\t\tinstalling $LIST..."
	install_list
}

#---------------------------------------------------
# install_common()
#
# Install binaries that are common to servers and clients
# on all servers and any machine designated as a client.
# This allows all servers to also act as DCE clients for
# their non-server components when configured as DCE clients
# after the DCE Server configuration has occurred.
#
# Ensure DFS client binaries are only installed if requested.
#---------------------------------------------------
install_common()
{
	# Create common directory structure if it
	# doesn't already exist.  Otherwise, ensure the
	# structure has write permission.
	DIRLIST="$DCELOCAL/var/directory
		 $DCELOCAL/var/adm
		 $DCELOCAL/var/adm/time
		 $DCELOCAL/var/dced
		 $DCELOCAL/var/svc
		 $DCELOCAL/var/directory/cds
		 $DCELOCAL/var/adm/directory
		 $DCELOCAL/var/directory/cds/adm
		 $DCELOCAL/var/adm/directory/cds
		 $DCELOCAL/etc/security
		 $DCELOCAL/var/security
		 $DCELOCAL/var/security/creds
                 $DCELOCAL/var/security/pk_file
                 $DCELOCAL/var/audit
                 $DCELOCAL/var/audit/adm
                 $DCELOCAL/var/audit/client
                 $DCELOCAL/etc/audit
                 $DCELOCAL/etc/audit/ec
                 $DCELOCAL/var/security/preauth
		 /krb5"
	if [ "$EPMAP" = "rpcd" ] ; then
	     DIRLIST="$DIRLIST $DCELOCAL/var/rpc"
	fi
	for i in $DIRLIST
	do
		if [ ! -d $i ]; then
			setdirperms ${i} || { err_exit "can't create $i"; }
		elif [ ! -w $i ]; then
			err_exit "$i doesn't have write permission"
		fi
	done

	# Set the perms on $DCELOCAL/var/security/creds, pk_file specially
	# Since the number of the sticky bit varies, first set to 777
	# then add the sticky bit.
	chmod 0777 $DCELOCAL/var/security/creds
	chmod +t $DCELOCAL/var/security/creds
        chmod 0777 $DCELOCAL/var/security/pk_file
        chmod +t $DCELOCAL/var/security/pk_file 

	# dced wants this directory to be this way
	# It will fail if not 0:0 and perm 711
	chown 0 $DCELOCAL/var/security/preauth
	chgrp 0 $DCELOCAL/var/security/preauth
	chmod 0711 $DCELOCAL/var/security/preauth

	LIST_daemons="dced cdsadv cdsclerk dtsd auditd"
	if [ -f $DCESHARED/bin/pkss_helper -o -f $DCESHARED/bin/pkssd ]; then
		INSTALL_PKSS_CLNT=1
		LIST_daemons="$LIST_daemons pkss_helper"
	else
		INSTALL_PKSS_CLNT=0
		if [ "$UNAME" != "HP-UX" ]
		then
			log_msg WARNING "pkss_helper is missing, this may be an error if"
			log_msg WARNING "domestic (U.S./Canada only) software is expected."
		fi
	fi

	if [ -f $DCESHARED/bin/pkss_helper2 -o -f $DCESHARED/bin/pkssd ]; then
		INSTALL_PKSS_CLNT=1
		LIST_daemons="$LIST_daemons pkss_helper2"
	else
		INSTALL_PKSS_CLNT=0
		if [ "$UNAME" != "HP-UX" ]
		then
			log_msg WARNING "pkss_helper2 is missing, this may be an error if"
			log_msg WARNING "domestic (U.S./Canada only) software is expected."
		fi
	fi

	LIST_timeproviders="dts_null_provider dts_ntp_provider"
	if [ "$UNAME" = "HP-UX" ]
	then
		LIST_daemons="$LIST_daemons dtstimed"
	fi

	LIST_utils="rpccp uuidgen cdscp getcellname getip"
	LIST_utils2="acl_edit dce_login rgy_edit dtscp dcecp"
	LIST_utils3="svcdumplog dcecf_postproc"
	LIST_admin="sec_admin passwd_import passwd_export"
	LIST_kutils="kinit klist kdestroy k5dcelogin"
	LIST="$LIST_daemons $LIST_timeproviders $LIST_utils $LIST_utils2 $LIST_utils3 $LIST_admin $LIST_kutils"

	echo "\t\tinstalling $LIST_daemons..."
	echo "\t\tinstalling $LIST_timeproviders..."
	echo "\t\tinstalling $LIST_utils..."
	echo "\t\tinstalling $LIST_utils2..."
	echo "\t\tinstalling $LIST_utils3..."
	echo "\t\tinstalling $LIST_admin..."
	echo "\t\tinstalling $LIST_kutils..."
	install_list
	if [ $INSTALL_PKSS_CLNT -eq 1 ]
	then
		chmod u+s $DCELOCAL/bin/pkss_helper
		chmod g-rw $DCELOCAL/bin/pkss_helper
		chmod o-rw $DCELOCAL/bin/pkss_helper
		chmod g-rw $DCELOCAL/bin/pkss_helper2
		chmod o-rw $DCELOCAL/bin/pkss_helper2
		chown root $DCELOCAL/bin/pkss_helper
	fi

        # install the rpcd link
	echo "\t\tinstalling rpcd link ..."
        rm -f $DCELOCAL/bin/rpcd /usr/bin/rpcd
        ln -s $DCELOCAL/bin/dced $DCELOCAL/bin/rpcd
        ln -s $DCELOCAL/bin/dced /usr/bin/rpcd

	# Install rlogin and rsh in $DCELOCAL/bin but don't create
	# links from /usr/bin
	RUTIL_LIST="rlogin rsh"
	read_media bin 
   	for i in $RUTIL_LIST
   	do
		if [ -f $DCESHARED/bin/$i ]
		then
			cp $CPOPT $DCESHARED/bin/$i $DCELOCAL/bin/$i || \
                        { err_exit "Can't create file $DCELOCAL/bin/$i"; }
		fi
	done


	# Note: this is an UNDOCUMENTED Feature, intended for use by
	# this configuration script only.  The dce_login_noexec
	# binary is removed at the end of this script.  It performs
	# the same function as dce_login, but suppresses the exec
	# of a shell, allowing authentication to occur from within
	# a shell script.
	if [ ! -f /usr/bin/dce_login_noexec ]
	then
	    log_msg DETAIL "Executing: ln -s /usr/bin/dce_login /usr/bin/dce_login_noexec >/dev/null"
	    ln -s /usr/bin/dce_login /usr/bin/dce_login_noexec >/dev/null 2>&1
	fi

	LISTetc1="cds_attributes $CDS_GLOBALNAMES cdscp.bpt cdscp.mbf dtscp.bpt "
        LISTetc2="dce_com_utils dce_com_env dce_config_env dce_config dce_config_utils dce_shutdown dce.rm dce.unconfig dfs_config pwd_config dced_acl_patcher"
	LISTetc3="rc.dce rlogind rshd"
	LIST="$LISTetc1 $LISTetc2 $LISTetc3"
	read_media etc 
   	for i in $LIST
   	do
		if [ -f $DCESHARED/etc/$i ]
		then
			cp $CPOPT $DCESHARED/etc/$i $DCELOCAL/etc/$i || \
                        { err_exit "Can't create file $DCELOCAL/etc/$i"; }
		fi
	done

	# Install audit event class files
	LISTaud_ec="dce_audit_filter_modify dce_audit_filter_query dce_audit_admin_modify dce_audit_admin_query"
	LISTdts_ec="dce_dts_mgt_modify dce_dts_mgt_query dce_dts_synch dce_dts_time_provider"
	LISTsec_ec=" dce_sec_authent dce_sec_control dce_sec_modify dce_sec_query dce_sec_server"
	LIST="$LISTaud_ec $LISTdts_ec $LISTsec_ec"
	read_media "etc/audit/ec"
	# copy the whole directory
	cp $CPOPT $DCESHARED/etc/audit/ec/* $DCELOCAL/etc/audit/ec/. || \
		{ err_exit "Can't create file $DCELOCAL/etc/audit/ec/$i"; }

	# install serviceability routing file
	LIST="routing"
	read_media "var/svc"
	if [ -f $DCESHARED/share/var/svc/routing ]
	then
		cp $CPOPT $DCESHARED/share/var/svc/routing $DCELOCAL/var/svc/routing || \
		{ err_exit "Can't create file $DCELOCAL/var/svc/routing"; }
	fi

	if [ "$UNAME" = "AIX" ]; then
		# This part is AIX specific.
		# It installs the AIX DTS kernel extensions
		# and support routines.  Remove for non-AIX platforms.

		LISTdtsext1="config_kern_ext load_kern_ext query_kern_ext unload_kern_ext"
		LISTdtsext2="dtskernext dtsloadobj"
		LIST="$LISTdtsext1 $LISTdtsext2"
		read_media ext
		for i in $LIST
		do
			cp $CPOPT $DCESHARED/ext/$i $DCELOCAL/ext/$i || \
				{ err_exit "Can't create file $DCELOCAL/ext/$i"; }
		done
	fi

	# On re-config, the start up files are first restored to the
	# unconfigg'ed state using the template files.
	# These are the only files that live in /etc
	if [ -f $RC_DCE ]; then
		# If there is a modifed RC_DCE, leave it.
		# This allows binaries to be upgraded with blowing
		# the configuration.
		grep "^daemonrunning " $RC_DCE > /dev/null
		if [ $? -eq 0 ]; then
			log_msg VERBOSE \
				"Modified $RC_DCE exists, not replacing"
		else
			log_msg DETAIL \
			"Executing: cp $CPOPT $DCELOCAL/etc/rc.dce $RC_DCE"
			 cp $CPOPT $DCELOCAL/etc/rc.dce $RC_DCE >/dev/null
		fi
	else
		log_msg DETAIL \
			"Executing: cp $CPOPT $DCELOCAL/etc/rc.dce $RC_DCE"
		cp $CPOPT $DCELOCAL/etc/rc.dce $RC_DCE >/dev/null
	fi
	log_msg DETAIL \
	    "Executing:  mv $DCELOCAL/etc/rc.dce $DCELOCAL/etc/rc.dce.template"
	mv $DCELOCAL/etc/rc.dce $DCELOCAL/etc/rc.dce.template >/dev/null

	for i in $LISTetc2
	do
		rm -f /etc/$i
		log_msg DETAIL "Executing: ln -s $DCELOCAL/etc/$i /etc/$i "
		ln -s $DCELOCAL/etc/$i /etc/$i 2>/dev/null
		if [ $? != 0 ]
		then
			err_exit "Cannot install link from $DCELOCAL/etc/$i to /etc/$i"
		fi
	done

	# special compat link for dce.clean
	rm -f /etc/dce.clean
	log_msg DETAIL "Executing: ln -s $DCELOCAL/etc/dce_shutdown /etc/dce.clean"
	ln -s $DCELOCAL/etc/dce_shutdown /etc/dce.clean

	# special link for dtsdate command 

	log_msg DETAIL "Executing: ln -s $DCELOCAL/bin/dtsd /usr/bin/dtsdate"

        rm -f /usr/bin/dtsdate

	ln -s $DCELOCAL/bin/dtsd /usr/bin/dtsdate
	
	copy_libdce
        # Install dcecp and tcl files. 
	LISTdcecp="dcecp tcl"
	for i in $LISTdcecp
	do
		echo "\t\tinstalling $i files..."
	        if [ -z "$CPCMD" -o "$CPCMD" = "cp" ]; then
			DIRENTRY=$DCELOCAL/$i
			if [ ! -d $DCELOCAL/$i ]; then
				setdirperms ${DIRENTRY} || \
					 { err_exit "can't create $DIRENTRY"; }
			elif [ ! -w $DIRENTRY ]; then
        	   		err_exit "$DIRENTRY doesn't have write permission"
			fi
			log_msg DETAIL "Executing: cp $CPOPT $DCESHARED/$i/* $DCELOCAL/$i/."
			cp $CPOPT $DCESHARED/$i/* $DCELOCAL/$i/. || \
				{ err_exit "Can't write $i files into $DCELOCAL/$i"; }
		else
        	  $CPCMD $DCESHARED/$i $DCELOCAL/$i || \
                	{ err_exit "Can't create link for $DCELOCAL/$i"; }
	        fi
	done
	#
	# Create "tclIndex" file for dcecp internal procedures
	# Autoloading allows dcecp to start up without loading any
	# script files.  The files will be loaded when their procedures
	# are invoked.
	#
	dcecp -c auto_mkindex $DCELOCAL/dcecp \*.dcp

	# Install message catalogs
	read_media ${NLSDIR}

	echo "\t\tinstalling message catalogs..."
	log_msg DETAIL "Executing: cp $CPOPT $DCESHARED/$NLSDIR/* $DCELOCAL/$NLSDIR/."
	cp $CPOPT $DCESHARED/$NLSDIR/* $DCELOCAL/$NLSDIR/. || \
		{ err_exit "Can't write message catalogs into $DCELOCAL/$NLSDIR"; }
	# get rid of DFS catalogs
	rm -f $DCELOCAL/$NLSDIR/dfs*.cat
	parse_nls


	if [ "$UNAME" = "OSF1" ]
	then
		string=n
	        if [ -f "$ETHER_ADDR_FILE" ]
	        then
		    if [ "${USE_ETHER_FILE:-n}" != "y" ]; then
	                echo "\tThe following IEEE 802 address has already"
			# Quirky use of echon for proper formatting
			echon "\tbeen entered for this machine:\n\t"
			cat $ETHER_ADDR_FILE
	                echon "\n\tIs this correct? (y) "
	                get_string
	                string=${string:-"y"}
		    else
			string=y	# Its ok to use the file
		    fi
	        fi
	        if [ "$string" != "y" -a "$string" != "yes" ]
	        then
	                echo "\n\tEnter your machine's IEEE 802 address as a"
	                echon "\t12 digit hex number (e.g. 08002B0F59BB): "
	                get_string
	                echo $string > $ETHER_ADDR_FILE
	        fi
	fi
}


#---------------------------------------------------
# install_appdev()
#  
# Install the application development environment,
# which includes header files, the audit library,
# and the idl compiler.
#---------------------------------------------------
install_appdev()
{
	# Create application development specific files
	DIRLIST="$DCELOCAL/share
	         $DCELOCAL/share/include"
	for i in $DIRLIST
	do
		if [ ! -d $i ]; then
			setdirperms ${i} || { err_exit "can't create $i"; }
		elif [ ! -w $i ]; then
			err_exit "$i doesn't have write permission"
		fi
	done

	log_msg DETAIL "Executing: rm -rf $DCELOCAL/share/include/dce"
	rm -rf $DCELOCAL/share/include/dce 2>/dev/null

	log_msg SUMMARY "installing DCE include files..."

	read_media "share/include/dce"

	if [ -z "$CPCMD" -o "$CPCMD" = "cp" ]; then
	  log_msg DETAIL "Executing: cp -r $CPOPT $DCESHARED/share/include/* $DCELOCAL/share/include/."
	  cp -r $CPOPT $DCESHARED/share/include/* $DCELOCAL/share/include/.
	else
	  log_msg DETAIL "Executing: $CPCMD $DCEINST/share/include/* $DCELOCAL/share/include/."
	  $CPCMD $DCEINST/share/include/* $DCELOCAL/share/include/. 
	fi

	INCL1="xds.h            xom.h            xomi.h           xmhp.h"
	INCL2="xmsga.h          xdsbdcp.h        xdsmdup.h        xdscds.h"
	INCL3="xdsgds.h         xdsdme.h         pthread_exc.h    pthread.h"
	LISTxds="$INCL1 $INCL2 $INCL3"
	log_msg SUMMARY "installing as symbolic links in /usr/include:"
	log_msg SUMMARY "$INCL1"
	log_msg SUMMARY "$INCL2"
	log_msg SUMMARY "$INCL3"

	LIST="$LISTxds"
	read_media "share/include"

	# Create links from /usr/include/<*>  to $DCELOCAL/share/include
	for i in $LISTxds
	do
		issymlink /usr/include/$i
		temp=$?
		if [ $temp -eq 2 ]		# does not exist
		then
		     log_msg DEBUG "Executing: ln -s $DCELOCAL/share/include/$i /usr/include/$i"
		     ln -s $DCELOCAL/share/include/$i /usr/include/$i
		elif [ $temp -eq 1 ] 	# exists and is not symlink
		then
		    echo "\t/usr/include/$i on your Operating System already exists"
		    echo "\tIf desired, replace it with a link to $DCELOCAL/share/include/$i"
		fi
		# say nothing if its a symlink
	done

	# pthread.h and pthread_exc.h are a special case.  Link from
	# /usr/include/pthread.h to $DCELOCAL/share/include/
	# /usr/include/pthread_exc.h to $DCELOCAL/share/include/
	# It should be accessible from both /usr/include and /usr/include/dce

	ln -s $DCELOCAL/share/include/pthread_exc.h $DCELOCAL/share/include/dce/pthread_exc.h
	ln -s $DCELOCAL/share/include/pthread.h $DCELOCAL/share/include/dce/pthread.h
	# Now create the link for /usr/include/dce/
	# Be nice and make sure they don't already have a directory
	issymlink /usr/include/dce
	temp=$?
	if [ $temp -eq 2 ]		# does not exists
	then
		ln -s $DCELOCAL/share/include/dce /usr/include/dce
	elif [ $temp -eq 1 ] 	# exists and not a symlink
	then
	    echo "\t/usr/include/dce on your Operating System already exists"
	    echo "\tIf desired, replace it with a symbolic link to $DCELOCAL/share/include/dce"
	fi
	# else do nothing if its a symlink

	# Install libaudit.a in /usr/lib
	log_msg SUMMARY "installing libaudit.a"
	log_msg DETAIL "Executing: cp $DCEINST/usr/lib/libaudit.a $DCELOCAL/usr/lib/."
	cp $DCEINST/usr/lib/libaudit.a $DCELOCAL/usr/lib/.

	# On SVR4 systems, install development reentrant libs
	if [ "$UNAME" = "SVR4" ]; then
		echo "\t\tinstalling reentrant libraries..."
		SHLIBS="libc_r.a \
			libc_r${SHLIB_SUF} \
			libcma.a \
			libcma${SHLIB_SUF} \
			libucb_r.a \
			libgen_r.a \
			libm_r.a \
			libmalloc_r.a \
			libsocket_r.a"
		for i in $SHLIBS
		do
	    		cp $DCESHARED/usr/lib/$i $DCELOCAL/lib || \
			    { err_exit "Can't create $DCELOCAL/lib/$i";  }
		done
		return 0
	fi


	LIST="idl"
	log_msg SUMMARY "installing idl..."
	install_list

}

#---------------------------------------------------
# install_opt_util()
#  
# Install the optional utility programs
#	nidl_to_idl	cdsbrowser	
#---------------------------------------------------
install_opt_util()
{
    while :
    do
	clear

	LIST="1 2 3 98 99"
	export LIST

	log_msg VERBOSE "User query: Optional Utilities Installation Menu (on $HOSTNAME)"
	echo "\n"
	echo "\t Optional Utilities Installation Menu"
	echo "\n"
	echo "\t 1. cdsbrowser"
	echo "\t 2. nidl_to_idl"
	echo "\n"
	echo "\t98. Return to previous menu"
	echo "\t99. Exit"
	echo "\n"
	echon "\tselection:  "

	get_option

	LIST=""
	export LIST
	log_msg VERBOSE "User entry: $opt"
	for optionitem in $opt 
	do
		# Note there's no need to check for an invalid option, because
		# the get_option routine already did that.
		case $optionitem in
			 1) 	LIST="cdsbrowser $LIST";; 
			 2) 	LIST="nidl_to_idl $LIST";; 
			98)	return;;
			99)	menu99;;
		esac
	done

	echo "\t\tinstalling $LIST..."
   	install_list
    done
}

#------------------------------------------------------
#  Configuration Scripts for DCE
#------------------------------------------------------

#------------------------------------------------------
# create_dcecfdb()
# 
# Prompt for the name of the cell
# Change HOST_NAME based on service guard.
# Create the $DCELOCAL/dce_cf.db configuration file.
# Format of the dce_cf.db file is:
#           cellname /.../<cellname>
#           hostname hosts/<hostname>
#------------------------------------------------------
create_dcecfdb()
{
		log_msg DEBUG "Executing: create_dcecfdb()"
		log_msg VERBOSE "Creating the DCE configuration file ($DCELOCAL/dce_cf.db)"

                dcecp -c attrlist getvalues [hostdata show ${CONFIG_PROTSEQ}:${ip} \
                -ifname cell_name] -type hostdata/data > /tmp/cellname
                if [ $? -eq 0 -a ! -z "${ip}" ]; then
                    tmpcellname=`cat /tmp/cellname`

		    # Put the cellname into the config file.
		    log_msg DETAIL "Executing: echo \"cellname \"$tmpcellname  > ${DCELOCAL}/dce_cf.db"
		    echo "cellname "$tmpcellname > ${DCELOCAL}/dce_cf.db || \
			{ err_exit "Write to ${DCELOCAL}/dce_cf.db failed.  Continuing will return to the Main Menu."; menu0; }
		else
                    tmpcellname=${CELL_NAME:="NULL"}
                    until [ "${tmpcellname:="NULL"}" != "NULL" ]
                    do
                        log_msg VERBOSE "User query: Enter the name of your cell (without /.../): "
                        echo "\n"
                        echon "\tEnter the name of your cell (without /.../): "
                        read tmpcellname
                        log_msg VERBOSE "User entry: $tmpcellname"
                    done

		    # Put the cellname into the config file.
		    log_msg DETAIL "Executing: echo \"cellname /.../\"$tmpcellname > ${DCELOCAL}/dce_cf.db"
		    echo "cellname /.../"$tmpcellname > ${DCELOCAL}/dce_cf.db \
                        || { err_exit "Write to ${DCELOCAL}/dce_cf.db failed.  Continuing will return to the Main Menu."; menu0; }
                fi

		log_msg DETAIL "Executing: echo \"hostname  hosts/\"$HOSTNAME  >> ${DCELOCAL}/dce_cf.db"
		echo "hostname  hosts/"$HOSTNAME  >> ${DCELOCAL}/dce_cf.db || \
			{ err_exit "Write to ${DCELOCAL}/dce_cf.db failed.  Continuing will return to the Main Menu."; menu0; }
		log_msg DETAIL "Executing: echo \"krb5_ccache_vno 1\" >> ${DCELOCAL}/dce_cf.db"
		echo "krb5_ccache_vno 1" >> ${DCELOCAL}/dce_cf.db || \
			{ err_exit "Write to ${DCELOCAL}/dce_cf.db failed.  Continuing will return to the Main Menu."; menu0; }
		log_msg DETAIL "Executing: echo \"gen_v1_pac true\" >> ${DCELOCAL}/dce_cf.db"
		echo "gen_v1_pac true" >> ${DCELOCAL}/dce_cf.db || \
			{ err_exit "Write to ${DCELOCAL}/dce_cf.db failed.  Continuing will return to the Main Menu."; menu0; }
		log_msg DETAIL "Executing: echo \"krb5_kt_vno 1\" >> ${DCELOCAL}/dce_cf.db"
		echo "krb5_kt_vno 1" >> ${DCELOCAL}/dce_cf.db || \
			{ err_exit "Write to ${DCELOCAL}/dce_cf.db failed.  Continuing will return to the Main Menu."; menu0; }

                # If there are aliases defined for this cell, then
                # add them to the dce_cf.db file.
                dcecp -c hostdata show ${CONFIG_PROTSEQ}:${ip} \
                -ifname dce_cf.db | grep cellaliases > /tmp/aliases

                if [ $? -eq 0 -a ! -z "${ip}" ]; then
                    list_aliases=`cat /tmp/aliases | cut -d{ -f2 | cut -d} -f1`
		    log_msg DETAIL "Executing: echo \"$list_aliases\" >> ${DCELOCAL}/dce_cf.db"
		    echo $list_aliases >> ${DCELOCAL}/dce_cf.db \
                         || { err_exit "Write to ${DCELOCAL}/dce_cf.db failed.  Continuing will return to the Main Menu."; menu0; }
                fi

                rm -f /tmp/cellname
                rm -f /tmp/aliases

		chmod 644 ${DCELOCAL}/dce_cf.db

		# Reset cellname and shortcellname. 
		# These will be used by many of 
		# the config routines and their descendants.
		set_cell_name
}

#
#------------------------------------------------------
# check_for_sec_client_service
#
# Check for active sec_client service. dced-secval
#   Return: 0 - Not started
#	    1 - Already started
#	    2 - Other failure
#------------------------------------------------------
#------------------------------------------------------
check_for_sec_client_service ()
{

  log_msg SUMMARY "Checking for active sec_client service..."

  if [ "$sec_client_service" = "sec_clientd" ]
  then
    ps ${PSARGS} | grep -q sec_clientd
    if [ $? -eq 0 ]
    then
      return 1
    else
      return 0      
    fi
  fi

  binding_file="$DCELOCAL/var/security/sec_clientd.binding"	
  if [ ! -s $binding_file ] 
  then
    return 0
  fi

  dced_binding=`head -1 $binding_file`
  cmd="dcecp -c secval status {$dced_binding}"
  log_msg DETAIL "Executing: $cmd"
  secval_status=`$cmd`
  if [ $? -ne 0 ] 
  then
    log_msg DETAIL "$cmd FAILS: $secval_status"
    rtn_status=2
  else  
    if [ "$secval_status" = "0" ]
    then
      rtn_status=0
    else
      rtn_status=1
    fi
  fi
  return $rtn_status
}

#------------------------------------------------------
# start_sec_client_service
#
# Start sec_client service. dced-secval
#   Input: $1 indicates whether to update rc_file or not
#   Return: 0 - Success
#	    1 - Failure
#------------------------------------------------------
start_sec_client_service ()
{
  arg1=$1
  log_msg SUMMARY "Starting sec_client service..."

  if [ "$sec_client_service" = "sec_clientd" ]
  then
    log_msg DETAIL "Executing: sec_clientd"
    sec_clientd
    wait_for_id
    rtn_status=$?
    if [ $rtn_status -ne 0 ] 
    then
      echo "sec_clientd start fails"
      log_msg DETAIL "sec_clientd start fails"
    else
      if [ $arg1 = "modify_rcfile" ]
      then
	modify_rcfile sec_clientd
	modify_rcfile_wait_for_machine_id
      fi
    fi	
    return $rtn_status	
  fi

  # Need string binding, must wait for dced to create it.
  binding_file="$DCELOCAL/var/security/sec_clientd.binding"	
  # Wait up to 75 seconds for dced to create binding.
  loop_count=75; creds_found=1
  while [ $loop_count -gt 0 -a $creds_found -eq 1 ]
  do
	if [ -s $binding_file ]
	then
		# OK to continue
		creds_found=0
	else
		# Credentials file not there yet
		sleep 5
		loop_count=`expr $loop_count - 5`
	fi
  done

  if [ "$creds_found" -eq 1 ]
  then
	rtn_status=1
  fi

  # Activate won't return until creds exist.
  dced_binding=`head -1 $binding_file`
  cmd="dcecp -c secval activate {$dced_binding}"
  saved_krb5ccname=$KRB5CCNAME
  unset KRB5CCNAME
  log_msg DETAIL "Executing: $cmd"
  secval_status=`$cmd`
  rtn_status=$?
  if [ "$saved_krb5ccname"xx != "xx" ]
  then
    KRB5CCNAME=$saved_krb5ccname
    export KRB5CCNAME
  fi
  unset saved_krb5ccname
  if [ $rtn_status -ne 0 ] 
  then
    log_msg DETAIL "$cmd FAILS: $secval_status"
    rtn_status=1	
  else
    if [ $arg1 = "modify_rcfile" ]
    then
      modify_rcfile_activate_secval
    fi
  fi	

  return $rtn_status  

}

#------------------------------------------------------
# stop_sec_client_service
#
# Stop sec_client service. (sec_cilentd or dced-secval
#------------------------------------------------------
stop_sec_client_service ()
{
  log_msg SUMMARY "Stopping sec_client service..."

  if [ "$sec_client_service"XX = "sec_clientdXX" ]
  then
    log_msg DETAIL "Executing: get_pid \"sec_clie\" | xargs kill >/dev/null 2>&1"
    get_pid "sec_clie" | xargs kill >/dev/null 2>&1
    return $?
  fi
  
  binding_file="$DCELOCAL/var/security/sec_clientd.binding"	
  dced_binding=`head -1 $binding_file`
  cmd="dcecp -c secval deactivate {$dced_binding}"
  saved_krb5ccname=$KRB5CCNAME
  unset KRB5CCNAME
  log_msg DETAIL "Executing: $cmd"
  secval_status=`$cmd`
  rtn_status=$?
  if [ "$saved_krb5ccname"XX != "XX" ]
  then
    KRB5CCNAME=$saved_krb5ccname
    export KRB5CCNAME
  fi
  unset saved_krb5ccname
  if [ $rtn_status -ne 0 ] 
  then
    log_msg DETAIL "$cmd FAILS: $secval_status"
    rtn_status=2
  fi

  return $rtn_status  
}

#------------------------------------------------------
# modify_rcfile_activate_secval
#
# Modify rc file to invoke dcecp command which activates secval. 
#------------------------------------------------------
modify_rcfile_activate_secval()
{
	# This routine is not appropriate on SVR4 systems
	if [ "$UNAME" = "SVR4" ]; then
	    return 0
	fi

	cmd="activate_secval"
	log_msg DEBUG "Executing: modify_rcfile_activate_secval"

	# Uncomment command if commented
	grep "#$cmd" $RC_DCE >/dev/null 2>&1
	if [ $? -eq 0 ]
	then
		sed "s:#$cmd:$cmd:g" \
		$RC_DCE > /tmp/rc.dce.new  && \
		{ cp /tmp/rc.dce.new $RC_DCE ;
		rm -f /tmp/rc.dce.new; }
	else
		grep "$cmd" $RC_DCE >/dev/null 2>&1
		if [ $? -eq 1 ]
	 	then
	 		err_exit "$RC_DCE is not installed or is corrupted.  Continuing will return to the Main Menu."
			menu0
		fi
	fi

	log_msg VERBOSE "Successfully modified startup file to activate secval with dcecp"

}

#------------------------------------------------------
# modify_rcfile()
#
# modifies the $RC_DCE file so the correct daemons
# will be started at boot time.
# Note: $RC_DCE is NOT put into an /etc/rc.local or
#    /etc/rc file.  Each vendor must handle that as
#    deemed appropriate.
#------------------------------------------------------
modify_rcfile()
{
	# This routine is not appropriate on SVR4 systems
	if [ "$UNAME" = "SVR4" ]; then
	    return 0
	fi

	mdaemon=$1
        args=$2
	log_msg DEBUG "Executing: modify_rcfile($mdaemon)"
	grep "#daemonrunning \$DCELOCAL/bin/$mdaemon" $RC_DCE >/dev/null 2>&1
	if [ $? -ne 0 ]
	then
	      grep "daemonrunning \$DCELOCAL/bin/$mdaemon" $RC_DCE >/dev/null 2>&1
	      if [ $? -ne 0 ]
		then
			err_exit "$RC_DCE is not installed or is corrupted."
		else
			sed "s:daemonrunning \$DCELOCAL/bin/$mdaemon.*$:daemonrunning \$DCELOCAL/bin/$mdaemon $args:g" \
			$RC_DCE > /tmp/rc.dce.new && \
			{ cp /tmp/rc.dce.new $RC_DCE ;
			rm -f /tmp/rc.dce.new;
			log_msg VERBOSE "Successfully modified rcfile /etc/rc.dce for \"$mdaemon\""; }
	      fi
	else
	      sed "s:#daemonrunning \$DCELOCAL/bin/$mdaemon:daemonrunning \$DCELOCAL/bin/${mdaemon}${args}:g" \
                  $RC_DCE > /tmp/rc.dce.new  && \
   		{ cp /tmp/rc.dce.new $RC_DCE ;
		rm -f /tmp/rc.dce.new;
		log_msg VERBOSE "Successfully modified rcfile /etc/rc.dce for \"$mdaemon\""; }
	fi
}


#------------------------------------------------------
# modify_rcfile_wait_for_machine_id()
#
# Add the wait for the machine's identity - this needs
# to be done for any machine that will run sec_clientd
#------------------------------------------------------
modify_rcfile_wait_for_machine_id()
{
	log_msg DEBUG "Executing: modify_rcfile_wait_for_machine_id()"
	grep '^wait_for_id' $RC_DCE > /dev/null 2>&1
	if [ $? -ne 0 ]
	then 
		grep "^until test -s $DCELOCAL/var/security/creds/$SECCRED_FILE" $RC_DCE > /dev/null 2>&1
		if [ $? -ne 0 ]
		then 
			cat > /tmp/dceconfig.tmp << EOF

			# wait until machine self identity is established
			until [ -s "$DCELOCAL/var/security/creds/$SECCRED_FILE" -a -s "$DCELOCAL/var/security/creds/$SECCRED_DATAFILE" ]
			do
    				sleep 1
			done

EOF
		fi
		sed '/daemonrunning .*\/sec_clientd$/r /tmp/dceconfig.tmp' $RC_DCE > /tmp/rc.dce.new
		rm -f /tmp/dceconfig.tmp
		cp /tmp/rc.dce.new $RC_DCE
		rm /tmp/rc.dce.new
		log_msg VERBOSE "Successfully modified rcfile $RC_DCE with wait for node identity after sec_clientd"
	fi
}


#------------------------------------------------------
# config_epmap()
#
# Start the endpoint mapper if it isn't already running.
#
# Make /dev/lan* world readable for 9.0 systems, and
# to get IEEE 802 address.
#
# NCS1.5.1 compatibility:
# First, if glbd, rpcd, or llbd (NCS) are running, kill them.
# After bringing up the endpoint map, restart glbd if it was
# running before.  Do not restart rpcd or llbd, since this
# replaces it.
#------------------------------------------------------
config_epmap()
{
	log_msg DEBUG "Executing: config_epmap()"

        # Ensure Endpoint map binaries have been installed
        if [ ! -x ${DCE_DAEMONS}/${EPMAP} ]
        then
                err_exit "${DCE_DAEMONS}/${EPMAP} is not installed.  \
Continuing will return to the Main Menu."
                menu0
        fi

        ps -ef > /tmp/config_epmap$$
        grep -q $EPMAP /tmp/config_epmap$$
	if [ $? -ne 0 ]; then

		# detect whether glbd is running.  Stop it if it is.
		glbd_running=0
                grep -q glbd /tmp/config_epmap$$
		if [ $? -eq 0 ]; then
			glbd_running=1
			log_msg SUMMARY "Stopping glbd..."
			log_msg DETAIL "Executing: get_pid \"glbd\" | xargs kill >/dev/null 2>&1"
			get_pid "glbd" | xargs kill >/dev/null 2>&1
		fi

		# detect whether llbd is running and stop it if it is
		llbd_running=0
		grep -q llbd /tmp/config_epmap$$
		if [ $? -eq 0 ]; then
			llbd_running=1
			log_msg SUMMARY "Stopping llbd..."
			log_msg DETAIL "Executing: get_pid \"llbd\" | xargs kill >/dev/null 2>&1"
			get_pid "llbd" | xargs kill >/dev/null 2>&1
		fi

                # detect whether rpcd is running and stop it if it is.  rpcd
                # is a link to dced and may be found on either 9.x or 10.x
                # systems.
                rpcd_running=0
                grep -q rpcd /tmp/config_epmap$$
                if [ $? -eq 0 ]; then
                        rpcd_running=1
                        log_msg SUMMARY "Stopping rpcd..."
                        log_msg DETAIL "Executing: get_pid \"rpcd\" | xargs kill >/dev/null 2>&1"
                        ps -ef | grep rpcd | grep -v grep | cut -c9-14 | xargs kill >/dev/null 2>&1
                fi

		# ensure that /dev/lan* is readable/writable by any process (uuid_gen needs it)
		if [ "$UNAME" = "HP-UX" ]
		then
			log_msg DETAIL "Executing: chmod a+r /dev/lan*"
			chmod a+r /dev/lan*
		fi

		log_msg SUMMARY "Starting $EPMAP..."

		# Always initialize dced.
		if [ ! -f ${DCELOCAL}/var/dced/Acl.db ] ; then
			log_msg SUMMARY "Initializing dced..."
			log_msg DETAIL "Executing: dced -i || { err_exit \"dced -i failed to start.\"; }"
			(
			cd ${DCELOCAL}/var/dced;
                        dced -i || { err_exit "dced -i failed to start.  Continuing will return to the Main Menu."; menu0; }
			)
		fi

		dced_cmd="dced -b"
		log_msg DETAIL "Executing: $dced_cmd || { err_exit \"$dced_cmd failed to start.\"; }"
		(
                cd ${DCELOCAL}/var/dced;
                $dced_cmd || { err_exit "$dced_cmd failed to start.  Continuing will return to the Main Menu."; menu0;}
		)

		modify_rcfile dced

 		if [ "$glbd_running" = "1" ]; then
			log_msg SUMMARY "Restarting glbd..."
			log_msg DETAIL "Executing: /usr/etc/ncs/glbd || \
{ err_exit \"glbd failed to start.\"; }"
			/usr/etc/ncs/glbd || { err_exit "glbd failed to start."; }
		fi

		if [ "$glbd_running" = "1" -o "$llbd_running" = "1" -o "$rpcd_running" = "1" ]
		then
			log_msg SUMMARY "Since the glbd daemon was restarted and/or llbd and rpcd \
were replaced by the end point mapper, NCS applications may need to be restarted."
		fi
	fi

        rm -f /tmp/config_epmap$$
}

#------------------------------------------------------
# parse_cds()
#
# This routine takes an input value that is a directory
# and zero or more subdirectories, and uses cdscp to
# create that directory structure in the name space.
# For example, if the directory to be created in the
# name space is /x/y/z, this routine will invoke
#    "cdscp create directory /x"
#    "cdscp create directory /x/y"
#    "cdscp create directory /x/y/z"
#------------------------------------------------------
parse_cds()
{
	pcds_param=$1
	log_msg DEBUG "Executing: parse_cds($*)"
	count=`echo $pcds_param | grep "/" | wc -w`
	count=`expr $count + 2`
	i=1
	while [ $i -le $count ]
	do
        		if [ $i -lt $count ]
        	then
               		 dir=`echo $pcds_param | cut -f$i -d"/"`
        	else
               		 dir=`basename $pcds_param`
        	fi
        	if [ $i -eq 1 ]
        	then
               		 k=$dir
        	else
               		 k="$k/$dir"
        	fi
        	export k dir
		cdscp create dir /.:/$k 2>/dev/null
		# Don't check for an error, because in some cases it should
		# already exist.
		i=`expr $i + 1`
	done
}

#------------------------------------------------------
# reconfig()
#
# Warn the user that the dce_cf.db configuration file
# already exists, and will be removed.  Allow them
# a chance to recover.
#------------------------------------------------------
reconfig()
{
	log_msg WARNING "This node has previously been configured as a DCE cell member."
	log_msg VERBOSE "User query: You must remove previous configuration files in order to reconfigure.  Do you wish to remove previous configuration files
and reconfigure? (n)  "
	echo "\tYou must remove previous configuration files in order to reconfigure."
	echo "\tDo you wish to remove previous configuration files"
	echon "\t and reconfigure? (n)  "
	read answer
	answer=${answer:-"n"}
	log_msg VERBOSE "User entry: $answer"
	case $answer in
		n|no)   return 1;;
		*) ;;
	esac
	rm -f $DCELOCAL/dce_cf.db
	create_dcecfdb
	return 0
}


#------------------------------------------------------
# config_sec()
#
# Security Server Configuration
#    Ensure secd daemon has been installed
#    Create $DCELOCAL/dce_cf.db
#    Remove any old previous security configuration files
#    Create /krb5/krb.conf.  The format is:
#            <cellname>
#            <cellname> <hostname>  
#    Add "kerberos5   88/udp  kdc" entry to /etc/services
#    Create necessary configuration for krb5 interoperability
#    Ensure the endpoint mapper is running
#    Use sec_create_db to initialize the security service
#          registry database
#    Start secd
#    Start sec_client service
#    Ask the user to authenticate so that the rgy_init()
#          routine to initialize the registry database
#          can be executed.  
#------------------------------------------------------
config_sec()
{
	log_msg DEBUG "Executing: config_sec()"
	ps ${PSARGS} | grep -q secd
	if [ $? -eq 0 ]
	then
	    err_exit "Security Server is already running on this node.  \
Continuing will return to the Previous Menu."
	    return
	fi

	# Ensure security server binaries have been installed
	if [ ! -x ${DCE_DAEMONS}/secd ]
	then
		err_exit "${DCE_DAEMONS}/secd is not installed. \
Continuing will return to the Previous Menu."
		return
	fi

	# Ensure dce_cf.db exists
	if [ -f $DCELOCAL/dce_cf.db ]
	then
		reconfig
		if [ $? -ne 0 ]; then
			return
		fi
	else
		create_dcecfdb
	fi

	# Cleanup previous security database files
	log_msg VERBOSE "Cleaning up previous security database files."
	log_msg DETAIL "Executing: rm -f ~/.rgy_editrc"
	rm -f ~/.rgy_editrc
	log_msg DETAIL "Executing: rm -f $DCELOCAL/etc/security/pe_site"
	rm -f $DCELOCAL/etc/security/pe_site 
	log_msg DETAIL "Executing: rm -rf $DCELOCAL/var/security/rgy_data*"
	rm -rf $DCELOCAL/var/security/rgy_data*
	log_msg DETAIL "Executing: rm -f $DCELOCAL/var/security/sec_clientd*"
	rm -f $DCELOCAL/var/security/sec_clientd*
	log_msg DETAIL "Executing: rm -f $DCELOCAL/var/security/.mkey"
	rm -f $DCELOCAL/var/security/.mkey
	log_msg DETAIL "Executing: rm -f /krb5/v5srvtab"
	rm -f /krb5/v5srvtab
	log_msg DETAIL "Executing: rm -f $DCELOCAL/var/security/creds/*"
	rm -f $DCELOCAL/var/security/creds/*
	log_msg DETAIL "Executing: rm -f $DCELOCAL/var/security/rcache/krb5kdc_rcache"
	rm -f $DCELOCAL/var/security/rcache/krb5kdc_rcache

	# Create krb.conf file
	log_msg VERBOSE "Creating /krb5/krb.conf file."
	while [ -f /krb5/krb.conf -a ! -w /krb5/krb.conf ]
	do
		err_exit "Existing /krb5/krb.conf can not be overwritten.  Continuing will re-try."
        done
	if [ ! -d /krb5 ]
	then
		mkdir -p /krb5
	fi
	log_msg DETAIL "Executing: echo $shortcellname  > /krb5/krb.conf"
	echo $shortcellname  > /krb5/krb.conf || \
		{ err_exit "Write to /krb5/krb.conf failed.  Continuing will return to the Previous Menu."; return; }
	log_msg DETAIL "Executing: echo $shortcellname $HOSTNAME >> /krb5/krb.conf"
	echo $shortcellname $HOSTNAME  >> /krb5/krb.conf || \
		{ err_exit "Write to /krb5/krb.conf failed.  Continuing will return to the Previous Menu."; return; }
	chmod 644 /krb5/krb.conf

	# Add entry to /etc/services
	add_service kerberos5 $KERB_PORT udp kdc

	# Ensure the endpoint mapper is running.  Start it if it isn't.
	log_msg VERBOSE "Ensuring $EPMAP is running."
	config_epmap

	keyseed=${KEYSEED:-"NULL"}
	until [ ${keyseed:="NULL"} != "NULL" ]
	do
	    log_msg VERBOSE "User query: Enter keyseed for initial database master key: "
	    echon "\tEnter keyseed for initial database master key: "
	    stty -echo 2>/dev/null
	    read keyseed
	    stty echo 2>/dev/null
	    echo "\n"
	    log_msg VERBOSE "User entry: <not shown>"
	done

	# Get Cell Administrator's principal name and password if not entered via environment variables
	while [ "${celladmin:="NULL"}" = "NULL" ]
	do
		log_msg VERBOSE "User query: Enter desired principal name for the Cell Administrator: (cell_admin) "
		echon "\n\tEnter desired principal name for the Cell Administrator: (cell_admin) "
		read string
		celladmin=${string:='cell_admin'}
		log_msg VERBOSE "User entry: ${celladmin}"
	done

	while [ "${cellpw:="NULL"}" = "NULL" ]
	do
		log_msg VERBOSE "User query: Enter desired password for the Cell Administrator: "
		echon "\tEnter desired password for the Cell Administrator: "
		stty -echo 2>/dev/null
		read cellpw
		stty echo 2>/dev/null
		echon "\n\tRe-enter desired password: "
		stty -echo 2>/dev/null
		read cellpw1
		stty echo 2>/dev/null
		echo "\n"

		if [ "$cellpw" != "$cellpw1" ]; then
			echo "\tPassword entries do not match."
			cellpw="NULL"
		else
			log_msg VERBOSE "User entry: <not shown>"
		fi
	done

	# find highest current uid from "/etc/passwd" and "ypcat passwd"
	if [ -f /etc/passwd ]
	then
		grep -q "^+:" /etc/passwd
		if [ $? = 1 ]
		then
			passwd_file="cat /etc/passwd"
		else
			ypcat passwd >/dev/null 2>&1
			if [ $? = 0 ]
			then
				passwd_file="ypcat passwd"
			else
				passwd_file="cat /etc/passwd"
			fi
		fi
	else
	    if [ "$do_checks" = "y" ]; then
		log_msg WARNING "Unable to find NIS services or /etc/passwd.  Continuing will use 100 as the current highest UID."
		x_exit
	    fi
	    passwd_file="echo '0:0:100:This is a dummy entry'"
	fi

	uid_values=`$passwd_file | \
		awk -F ":" -v GAP="$uid_gap" 'BEGIN {HIGHEST=0}
			{if ( $3 > HIGHEST && $1 != "nobody") HIGHEST = $3}
			END {print HIGHEST " " HIGHEST+GAP}'`
	curr_high_uid=`echo $uid_values | cut -d " " -f 1`
	low_auto_uid=`echo $uid_values | cut -d " " -f 2`

	log_msg SUMMARY "The current highest UNIX ID for persons on this node is ${curr_high_uid}."

	if [ "${LOW_UID:=NULL}" = "NULL" ]; then
		if [ "$low_auto_uid" -gt "$default_max_id" ]; then
			if [ "$do_checks" = "y" ]; then
				log_msg WARNING "The current highest UNIX ID for persons on this node is \
close to or above \
the maximum value supported for this cell (${default_max_id}).  The suggested starting point \
for UNIX ID's that are automatically generated by the Security Service is being set to $uid_gap. \
You should be aware that this will probably conflict with UID's currently in use on your \
node.  If you continue, you will have the option of setting the starting point to a value other \
than that suggested.  You may also use any value less than $default_max_id now, and use the \
\"rgy_edit> properties\" command to raise the maximum id and reset the starting point \
after the initial Security Server is configured."
				x_exit
			fi
			low_auto_uid=$uid_gap
		fi

		if [ "$do_checks" = "y" ]; then
			log_msg VERBOSE "User query: Enter the starting point to be used for \
UNIX ID's that
are automatically generated by the Security Service
when a principal is added using \"rgy_edit\": (${low_auto_uid}) "
			echo  "\tEnter the starting point to be used for UNIX ID's that"
			echo  "\tare automatically generated by the Security Service"
			echon "\twhen a principal is added using \"rgy_edit\": (${low_auto_uid}) "
			read string
			if [ -n "${string:=""}" ]; then
				low_auto_uid=$string
			fi
			log_msg VERBOSE "User entry: $low_auto_uid"
		fi
	elif [ "${LOW_UID}" -le "${curr_high_uid}" ]; then
		log_msg WARNING "The specified starting point for UID's to be automatically \
assigned by the Registry (${LOW_UID}) is less than or equal to the highest UNIX UID currently \
in use (${curr_high_uid})."
		log_msg VERBOSE "User query: Please confirm or enter the starting point for \
automatically
generated UID's: (${low_auto_uid}) "
		echo  "\n\tPlease confirm or enter the starting point for automatically"
		echon "\tgenerated UID's: (${low_auto_uid}) "
		read string
		if [ -n "${string:=""}" ]; then
			low_auto_uid=$string
		fi
		log_msg VERBOSE "User entry: $low_auto_uid"
	else
		low_auto_uid=$LOW_UID
	fi


	if [ "$low_auto_uid" -gt "$default_max_id" ]; then
                if [ "$do_checks" = "y" ]; then
                        log_msg WARNING "The default maximum UNIX ID for this cell is $default_max_id.  \
The value you \
have selected as the UNIX ID starting point is greater than this default maximum.  After \
configuring the DCE Security Server, you can use the \"rgy_edit> properties\" command \
to change the maximum.  If you continue, the starting point will be set to $uid_gap."
			x_exit
		fi
		low_auto_uid=$uid_gap
	fi

	# find highest current gid from "/etc/group" and "ypcat group"

	# find highest current uid from "/etc/group" and "ypcat group"
	if [ -f /etc/group ]
	then
		grep -q "^+" /etc/group
		if [ $? = 1 ]
		then
			group_file="cat /etc/group"
		else
			ypcat group >/dev/null 2>&1
			if [ $? = 0 ]
			then
				group_file="ypcat group"
			else
				group_file="cat /etc/group"
			fi
		fi
	else
		if [ "$do_checks" = "y" ]; then
			log_msg WARNING "Unable to find NIS services or /etc/group.  Continuing will use 100 as the current highest GID."
			x_exit
		fi
		group_file="echo '0:0:100:This is a dummy entry'"
	fi

	gid_values=`$group_file | sed 's/,.*$//' | \
		awk -F ":" -v GAP="$gid_gap" 'BEGIN {HIGHEST=0}
			{if ( $3 > HIGHEST && $1 != "nogroup" && $1 != "nobody") HIGHEST = $3}
			END {print HIGHEST " " HIGHEST+GAP}'`
	curr_high_gid=`echo $gid_values | cut -d " " -f 1`
	low_auto_gid=`echo $gid_values | cut -d " " -f 2`
	log_msg SUMMARY "The current highest UNIX ID for groups is ${curr_high_gid}."

	if [ "${LOW_GID:=NULL}" = "NULL" ]; then
		if [ "$low_auto_gid" -gt "$default_max_id" ]; then
			if [ "$do_checks" = "y" ]; then
				log_msg WARNING "The current highest UNIX ID for groups on this node is \
close to or above \
the maximum value supported for this cell (${default_max_id}).  The suggested starting point for \
UNIX ID's that are automatically generated by the Security Service is being set to $gid_gap. \
You should be aware that this will probably conflict with GID's currently in use on your \
node.  If you continue, you will have the option of setting the starting point to a value other \
than that suggested.  You may also use any value less than $default_max_id now, and use the \
\"rgy_edit> properties\" command to raise the maximum id and reset the starting point \
after the initial Security Server is configured."
				x_exit
			fi
			low_auto_gid=$gid_gap
		fi

		if [ "$do_checks" = "y" ]; then
			log_msg VERBOSE "User query: Enter the starting point to be used \
for UNIX ID's that
are automatically generated by the Security Service
when a group is added using \"rgy_edit\": (${low_auto_gid}) "
			echo  "\tEnter the starting point to be used for UNIX ID's that"
			echo  "\tare automatically generated by the Security Service"
			echon "\twhen a group is added using \"rgy_edit\": (${low_auto_gid}) "
			read string
			if [ -n "${string:=""}" ]; then
				low_auto_gid=$string
			fi
			log_msg VERBOSE "User entry: $low_auto_gid"
		fi
	elif [ "${LOW_GID}" -le "${curr_high_gid}" ]; then
		log_msg WARNING "The specified starting point for GID's to be automatically \
assigned by the Registry (${LOW_GID}) is less than or equal to the highest UNIX GID currently \
in use (${curr_high_gid})."
		log_msg VERBOSE "User query: Please confirm or enter the starting point for \
automatically
generated group ID's: (${low_auto_gid}) "
		echo  "\n\tPlease confirm or enter the starting point for automatically"
		echon "\tgenerated group ID's: (${low_auto_gid}) "
		read string
		if [ -n "${string:=""}" ]; then
			low_auto_gid=$string
		fi
		log_msg VERBOSE "User entry: $low_auto_gid"
	else
		low_auto_gid=$LOW_GID
	fi

	if [ "$low_auto_gid" -gt "$default_max_id" ]; then
                if [ "$do_checks" = "y" ]; then
                        log_msg WARNING "The default maximum UNIX ID for this cell is $default_max_id.  \
The value you \
have selected as the UNIX GID starting point is greater than this default maximum.  After \
configuring the DCE Security Server, you can use the \"rgy_edit> properties\" command \
to change the maximum.  If you continue, the starting point will be set to $gid_gap."
			x_exit
		fi
		low_auto_gid=$gid_gap
	fi

	# by creating the database with a default password rather than with the user's
	# specified cell_admin password, we avoid "Password must be changed!" warnings
	# If the specified cell_admin password is NOT the default
	rm -f /tmp/sec_create_out$$
	log_msg DETAIL "Executing: sec_create_db -my $SUBSYSDIR/$SECURITYDIR/$HOSTNAME \
-keyseed <not shown> -creator $celladmin -password \$default_pw -pe $low_auto_uid -g $low_auto_gid \
-ma $default_max_id"
        if [ ! -z "$RIP_HOSTNAME" ]
        then
                RPC_SUPPORTED_NETADDRS=ip:`getip $RIP_HOSTNAME`
                if [ $? -ne 0 ]
                then
                        unset RPC_SUPPORTED_NETADDRS
                        err_exit "getip of $RIP_HOSTNAME failed.  \
                        Continuing will return to the Previous Menu."
                        return
                fi
                export RPC_SUPPORTED_NETADDRS
        fi
	sec_create_db -my $SUBSYSDIR/$SECURITYDIR/$HOSTNAME -keyseed $keyseed -creator $celladmin \
		-password $default_pw -pe $low_auto_uid -g $low_auto_gid -ma $default_max_id \
		>/tmp/sec_create_out$$ 2>&1 || \
		  { err_exit "Error during creation of the security registry database.
  Message from sec_create_db:
    `cat /tmp/sec_create_out$$`
  Continuing will return to the Main Menu."; return; }

	rm -f /tmp/sec_create_out$$

	log_msg SUMMARY "Starting secd..."
	# The -bootstrap flag indicates secd should continue to attempt an
	# export into the name space each minute.
	#
	log_msg DETAIL "Executing: secd -bootstrap"
	secd -bootstrap || { err_exit "secd failed to start.  Continuing will return to the Previous Menu."; return; }
	modify_rcfile secd

	# sleep a bit so secd will respond when client looks
	log_msg DETAIL "Executing: sleep 15"
	sleep 15

	# verify secd is actually running
	ps ${PSARGS} | grep -q secd
	if [ $? -ne 0 ]; then
	    err_exit "Security server failed to start.  Continuing will return to the 
Previous Menu."
	    return
	fi

	# Start sec_client service
	check_for_sec_client_service
	rtn_status=$?
	if [ $rtn_status -eq 1 ]
	then
		err_exit "sec_client service is already running.  Continuing will return \
to the Previous Menu."
		return
	fi
	if [ $rtn_status -eq 2 ]
	then
		err_exit "Continuing will return to the Previous Menu."
		return
	fi

	log_msg DETAIL "Executing: sec_client service startup"
	start_sec_client_service modify_rcfile
	if [ $? -ne 0 ]; then
		menu0
	fi

	# have to login with default password this first time!
	log_msg DEBUG "Executing: savepw=\"$\"cellpw"
	savepw=$cellpw
	log_msg DEBUG "Executing: cellpw=\$default_pw"
	cellpw=$default_pw

	log_msg DEBUG "Executing: dcelogin (from config_sec)"
	dcelogin
	if [ $? != 0 ]; then
		menu0
	fi

	# now restore intended password
	log_msg DEBUG "Executing: cellpw=\"$\"savepw"
	cellpw=$savepw;

	# If designated cell_admin password is not the default
	# then reset CHANGE_PW: since previous login used default
	# value, it was set in dcelogin.
	if [ $cellpw != $default_pw ]; then
		CHANGE_PW="n"
	fi

	rgy_init

	# Configure as krb5 client (config_sec may not call config_secclient)
	config_krb5client $HOSTNAME
        log_msg DETAIL "Executing: krb5_client config"
	if [ $? != 0 ]; then
                err_exit "Continuing will return to the Previous Menu."
                return
	fi
}

#------------------------------------------------------
# rgy_init()
#
# Initialize the Registry Database.  This is done during
# the Security Server configuration.
#
# rgy_edit is used to create the known principals,
#     groups, organizations, and keytab entries for 
#     accounts.
#------------------------------------------------------
rgy_init()
{
	log_msg DEBUG "Executing: rgy_init()"
	log_msg SUMMARY "Initializing the registry database..."
	# Configure entries in the security space

	# Get name of cell administrator.  
	CELLADMIN=`klist | grep "Principal" | \
              grep -v "Global Principal" | awk '{print $3}'`

	# Change default password for cell_admin account to user-specified value
	rm -f /tmp/rgy_edit_out$$
	if [ "$cellpw" != "$default_pw" ]; then
		log_msg DETAIL "Executing: rgy_edit> domain account"
		log_msg DETAIL "Executing: rgy_edit> change -p $celladmin -g none -o none -pw \"$\"cellpw -mp \"$\"default_pw -pv"
		rgy_edit -update >/tmp/rgy_edit_out$$ 2>&1 <<EOF
domain account
change -p $celladmin -g none -o none -pw $cellpw -mp $default_pw -pv
exit
EOF
	fi
	# Add the necessary principals to the registry database
	log_msg DETAIL "Executing: rgy_edit> domain group"
	log_msg DETAIL "Executing: rgy_edit> add acct-admin"
	log_msg DETAIL "Executing: rgy_edit> add $SUBSYSDIR/sec-admin"
	log_msg DETAIL "Executing: rgy_edit> add $SUBSYSDIR/cds-admin"
	log_msg DETAIL "Executing: rgy_edit> add $SUBSYSDIR/dts-admin"
	log_msg DETAIL "Executing: rgy_edit> add $SUBSYSDIR/cds-server"
	log_msg DETAIL "Executing: rgy_edit> add $SUBSYSDIR/dts-servers"
	log_msg DETAIL "Executing: rgy_edit> add $SUBSYSDIR/audit-admin"
	log_msg DETAIL "Executing: rgy_edit> add $SUBSYSDIR/dced-admin"
	log_msg DETAIL "Executing: rgy_edit> member acct-admin -a $CELLADMIN"
	log_msg DETAIL "Executing: rgy_edit> member $SUBSYSDIR/sec-admin -a $CELLADMIN"
	log_msg DETAIL "Executing: rgy_edit> member $SUBSYSDIR/cds-admin -a $CELLADMIN"
	log_msg DETAIL "Executing: rgy_edit> member $SUBSYSDIR/dts-admin -a $CELLADMIN"
	log_msg DETAIL "Executing: rgy_edit> member $SUBSYSDIR/audit-admin -a $CELLADMIN"
	log_msg DETAIL "Executing: rgy_edit> member $SUBSYSDIR/dced-admin -a $CELLADMIN"
	log_msg DETAIL "Executing: rgy_edit> quit"
	rgy_edit -update >>/tmp/rgy_edit_out$$ 2>&1 <<EOF
domain group
add acct-admin
add $SUBSYSDIR/sec-admin
add $SUBSYSDIR/cds-admin
add $SUBSYSDIR/dts-admin
add $SUBSYSDIR/cds-server
add $SUBSYSDIR/dts-servers
add $SUBSYSDIR/audit-admin
add $SUBSYSDIR/dced-admin
member acct-admin -a $CELLADMIN
member $SUBSYSDIR/sec-admin -a $CELLADMIN
member $SUBSYSDIR/cds-admin -a $CELLADMIN
member $SUBSYSDIR/dts-admin -a $CELLADMIN
member $SUBSYSDIR/audit-admin -a $CELLADMIN
member $SUBSYSDIR/dced-admin -a $CELLADMIN
quit
EOF
	rgy_edit_status=$?
	chk_rgy_edit "rgy_edit - adding principals to the registry database"
}
#
#------------------------------------------------------
# config_basecds()
#
# CDS Server Configuration
#    This is common code for the 1st to nth CDS servers
# 	Ensure the cdsd daemon has been installed
#	Create the cds.conf file
#	Start the cdsadv daemon
#------------------------------------------------------
config_basecds()
{
    log_msg DEBUG "Executing: config_basecds()"

    # go ask the user about mutiple lans
    ask_multiple_lans

    # Ensure cdsadv is NOT already running...
    # If cdsadv is already running, it implies that this node may
    # have been configured as a DCE client node.  In this case,
    # we don't need to add CDS registry entries again.
    ps $PSARGS | grep -q cdsadv
    if [ $? -ne 0 ]
    then
	log_msg VERBOSE "Adding entries for CDS to the registry database."
	log_msg DETAIL "Executing: rgy_edit> domain principal"
	log_msg DETAIL "Executing: rgy_edit> add hosts/$HOSTNAME/cds-server"
	log_msg DETAIL "Executing: rgy_edit> domain account"
	log_msg DETAIL "Executing: rgy_edit> add hosts/$HOSTNAME/cds-server \
-g $SUBSYSDIR/cds-server -o none -pw <not shown> -mp <not shown>"
	log_msg DETAIL "Executing: rgy_edit> quit"

	rm -f /tmp/rgy_edit_out$$
	rgy_edit -update >/tmp/rgy_edit_out$$ 2>&1 <<EOF
domain principal
add hosts/${HOSTNAME}/cds-server
domain account
add hosts/${HOSTNAME}/cds-server -g $SUBSYSDIR/cds-server -o none -pw $cellpw -mp $cellpw
quit
EOF
	rgy_edit_status=$?
	chk_rgy_edit "rgy_edit - adding entries for CDS to the registry database."

	# If there are security replicas, we must wait till they are
	# up to date before doing keytab update.
	# (Even though we don't support cds-less cells, check for consistency anyway)
	log_msg DETAIL "Executing: verify_consistency()"
	verify_consistency
	if [ "$?" -ne 0 ]; then
	        log_msg VERBOSE "Security server replicas are not consistent \
with the master.  Some servers may be stopped or otherwise unavailable.  This \
is ok since the running servers are consistent, however, there \
exists the unlikely possibility that ktadd may bind to a server that has come \
back up between the time when the \"dcecp registry verify\" command was \
executed and before the ktadd command itself is executed.  The server that \
ktadd is bound to may not yet be consistent with the master server, and if \
this is the case then you must UNCONFIGURE and REMOVE this node from the \
cell before reconfiguring.  Check the output from the rgy_edit command \
immediately following the ktadd commands."

	fi
	log_msg VERBOSE "Adding ktab entries for CDS to the registry database."
	log_msg DETAIL "Executing: rgy_edit> ktadd -p hosts/$HOSTNAME/cds-server -pw <not shown>"
	log_msg DETAIL "Executing: rgy_edit> ktadd -p hosts/$HOSTNAME/cds-server -a -r"
	log_msg DETAIL "Executing: rgy_edit> quit"

	rm -f /tmp/rgy_edit_out$$
	rgy_edit -update >/tmp/rgy_edit_out$$ 2>&1 <<EOF
ktadd -p hosts/${HOSTNAME}/cds-server -pw $cellpw
ktadd -p hosts/${HOSTNAME}/cds-server -a -r
quit
EOF
	rgy_edit_status=$?
	chk_rgy_edit "rgy_edit - creating ktab entry in registry database."
    fi

        # Ensure cdsd has already been installed
        if [ ! -x ${DCE_DAEMONS}/cdsd ]
        then
                err_exit "${DCE_DAEMONS}/cdsd is not installed.  \
Continuing will return to the Previous Menu."
                return 1
	fi

	log_msg VERBOSE "Creating the cds.conf file."

	# Create the CDS configuration file cds.conf
	log_msg DETAIL "Executing: echo \"cds.cdsd.security.server_princ_name: \
hosts/${HOSTNAME}/cds-server\" > ${DCELOCAL}/etc/cds.conf"
	echo "cds.cdsd.security.server_princ_name: hosts/${HOSTNAME}/cds-server" > ${DCELOCAL}/etc/cds.conf
	log_msg DETAIL "Executing: echo \"cds.*.security.host_princ_name: \
hosts/${HOSTNAME}/self\" >> ${DCELOCAL}/etc/cds.conf"
	echo "cds.*.security.host_princ_name: hosts/${HOSTNAME}/self" >> ${DCELOCAL}/etc/cds.conf
	log_msg DETAIL "Executing: echo \"cds.*.security.server_group_name: \
${SUBSYSDIR}/cds-server\" >> ${DCELOCAL}/etc/cds.conf"
	echo "cds.*.security.server_group_name: ${SUBSYSDIR}/cds-server" >> ${DCELOCAL}/etc/cds.conf
	log_msg DETAIL "Executing: echo \"cds.*.security.admin_group_name: \
${SUBSYSDIR}/cds-admin\" >> ${DCELOCAL}/etc/cds.conf"
	echo "cds.*.security.admin_group_name: ${SUBSYSDIR}/cds-admin" >> ${DCELOCAL}/etc/cds.conf

	# Start the CDS advertiser
	log_msg SUMMARY "Starting cdsadv..."
	ps ${PSARGS} | grep -q cdsadv
	if [ $? -eq 0 ]
	then
        	log_msg WARNING "cdsadv is already running."
	else
		log_msg DETAIL "Executing: cdsadv"
        	cdsadv  || { err_exit "cdsadv failed to start.  Continuing will return to the Previous Menu."; return 1; }
        	modify_rcfile cdsadv
	fi
}

#------------------------------------------------------
# config_cds()
#
# CDS Server Configuration (for initial CDS server)
#	Create the dce_cf.db file if necessary.
#	Make this machine a security client if it isn't
#	    the security server.
#	Perform config_basecds() routine (which is the same 
#           whether this is the 1st or Nth CDS server)
#       Start cdsd -a
#	Ensure the user is in the cds-admin group,
#	re-authenticating if necessary.
#	Call ns_init() to initialize the name space and set ACLs.
#------------------------------------------------------
config_cds()
{
	log_msg DEBUG "Executing: config_cds()"

	# Ensure CDS server binaries have been installed
	if [ ! -x ${DCE_DAEMONS}/cdsd ]
	then
		err_exit "${DCE_DAEMONS}/cdsd is not installed. \
Continuing will return to the Previous Menu."
		return
	fi

	ps ${PSARGS} | grep -q cdsd
	if [ $? -eq 0 ]
	then
	    err_exit "CDS Server is already running on this node.  \
Continuing will return to the Previous Menu."
	    return
	fi

	# Ensure security client has been enabled
	if [ ! -f $DCELOCAL/dce_cf.db ]
	then
		create_dcecfdb
	fi

	# Does this machine need to be a security client?
	check_for_sec_client_service
	rtn_status=$?
	if [ $rtn_status -eq 2 ]
	then
		err_exit "Continuing will return to the Previous Menu."
		return
	fi
	if [ $rtn_status -eq 0 ]
	then
		config_secclient
	fi

	# Set BIND_PE_SITE to 0 so cross cell authentication works.
	# NOTICE: We've moved config_basecds to be AFTER clearing
	# BIND_PE_SITE.  This allows the advertiser to start
	# the clerks without using PE_SITE.  (the right way!!)

	log_msg VERBOSE "Executing: BIND_PE_SITE=0"
	BIND_PE_SITE=0

	config_basecds
	if [ $? -ne 0 ]
	then
		# Set BIND_PE_SITE back for further config
		log_msg VERBOSE "Executing: BIND_PE_SITE=1"
		BIND_PE_SITE=1
		return
	fi

	# Start the cdsd daemon (with -a option)
	log_msg SUMMARY "Starting cdsd..."
	ps ${PSARGS} | grep -q cdsd
	if [ $? -eq 0 ]
	then
		# Set BIND_PE_SITE back for further config
		log_msg VERBOSE "Executing: BIND_PE_SITE=1"
		BIND_PE_SITE=1
		err_exit "cdsd is already running.  Continuing will return to the Previous Menu."
		return
	fi

	log_msg DETAIL "Executing: cdsd -a"
        cdsd -a
	if [ $? -ne 0 ]
	then
		# Set BIND_PE_SITE back for further config
		log_msg VERBOSE "Executing: BIND_PE_SITE=1"
		BIND_PE_SITE=1
		err_exit "cdsd failed to start.  Continuing will return to the Previous Menu."
		return
	fi
	modify_rcfile cdsd
	verify_cds		# make sure cds is up and running

	# Set BIND_PE_SITE back for further config
	log_msg VERBOSE "Executing: BIND_PE_SITE=1"
	BIND_PE_SITE=1

	# It isn't possible to avoid a second
	# login as the same user if CDS and security servers
	# are on the same node. If groups get changed for
	# a principal, the only way to refresh is to use dce_login.
	# If the CDS server and security server are different nodes,
	# this login isn't necessary.
        klist 2>/dev/null | grep cds-admin >/dev/null 2>&1
        if [ $? -ne 0 ]
        then
		log_msg DEBUG "Executing: dcelogin (from config_cds)"
		dcelogin
		if [ $? != 0 ]; then
			menu0
		fi
	fi
        ns_init

}

#------------------------------------------------------
# verify_cds()
#
# Checks to make sure cds is up and running
#------------------------------------------------------
verify_cds()
{
    count=1
    max=10  # wait 10 * 6 seconds (60 seconds) before failing
    while :
    do
        cdscp show dir /.: > /dev/null
        cdscp_stat=$?
        if [ $cdscp_stat -eq 0 ]
        then
            break
        fi
        sleep 6
        count=`expr $count + 1`
        if [ $count -gt $max ]
        then
            err_exit "cdscp show dir /.: failing -- CDS not usable.  Continuing will return to the Main Menu."
	    menu0
        fi
    done
}

#------------------------------------------------------
# ns_init()
#
# Initialize the name service.  All DCE required
# directories and objects are created in the name space.
# ACLs are set on the objects, as appropriate.
#------------------------------------------------------
ns_init()
{
	log_msg DEBUG "Executing: ns_init()"

	CDSTMPFILE="/tmp/config_cdstmpfile$$"
	RPCTMPFILE="/tmp/config_rpctmpfile$$"
	SD="/.:$SUBSYSDIR"
        hostname=$HOSTNAME
	LAN=6f264242-b9f8-11c9-ad31-08002b0dc035,0001.0000

	rm -f /tmp/acl_edit_out$$
	acl_edit_status=0
	log_msg DETAIL "Executing: 	acl_edit /.: -ic -s unauthenticated:rt \
group:$SUBSYSDIR/cds-admin:rwcidta group:$SUBSYSDIR/cds-server:rwcidta any_other:rt"
	acl_edit /.: -ic -s \
	unauthenticated:rt \
	group:$SUBSYSDIR/cds-admin:rwcidta \
	group:$SUBSYSDIR/cds-server:rwcidta \
	any_other:rt >/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit /.: -io -s unauthenticated:rt \
group:$SUBSYSDIR/cds-admin:rwcdt group:$SUBSYSDIR/cds-server:rwcdt any_other:rt"
	acl_edit /.: -io -s \
	unauthenticated:rt \
	group:$SUBSYSDIR/cds-admin:rwcdt \
	group:$SUBSYSDIR/cds-server:rwcdt \
	any_other:rt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit /.: -s unauthenticated:rt \
group:$SUBSYSDIR/cds-admin:rwcidta group:$SUBSYSDIR/cds-server:rwcidta any_other:rt"
	acl_edit /.: -s \
	unauthenticated:rt \
	group:$SUBSYSDIR/cds-admin:rwcidta \
	group:$SUBSYSDIR/cds-server:rwcidta \
	any_other:rt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	chk_acl_edit "acl_edit - setting ACLs on /.:"

	# Generate file containing all the cdscp commands
	# Dup fd1 into fd3 (save it), set stdout to temp file
	exec 3>&1 > $CDSTMPFILE

	log_msg DETAIL "Executing: cdscp create obj /.:/cell-profile CDS_Class RPC_Profile CDS_ClassVersion 1.0"
#	echo "create obj /.:/cell-profile CDS_Class RPC_Profile CDS_ClassVersion 1.0"
        log_msg DETAIL "Executing: cdscp create obj /.:/lan-profile CDS_Class RPC_Profile CDS_ClassVersion 1.0"
        echo "create obj /.:/lan-profile CDS_Class RPC_Profile CDS_ClassVersion 1.0"
        log_msg DETAIL "Executing: cdscp add object /.:/lan-profile RPC_ClassVersion = 0100"
        echo "add object /.:/lan-profile RPC_ClassVersion = 0100"
	log_msg DETAIL "Executing: cdscp create dir /.:/subsys"
	echo "create dir /.:/subsys"
	log_msg DETAIL "Executing: cdscp create dir /.:/subsys/HP"
	echo "create dir /.:/subsys/HP"
	log_msg DETAIL "Executing: cdscp create dir /.:/subsys/HP/sample-apps"
	echo "create dir /.:/subsys/HP/sample-apps"
	log_msg DETAIL "Executing: cdscp create dir /.:/$SUBSYSDIR"
	echo "create dir /.:/$SUBSYSDIR"
	log_msg DETAIL "Executing: cdscp create dir /.:/$SUBSYSDIR/$SECURITYDIR"
	echo "create dir /.:/$SUBSYSDIR/$SECURITYDIR" 
	log_msg DETAIL "Executing: cdscp create dir /.:/$SUBSYSDIR/$DFSDIR"
	echo "create dir /.:/$SUBSYSDIR/$DFSDIR" 
	log_msg DETAIL "Executing: cdscp create dir /.:/hosts"
	echo "create dir /.:/hosts"
	log_msg DETAIL "Executing: cdscp create obj /.:/hosts/$HOSTNAME"
	echo "create dir /.:/hosts/$HOSTNAME"
	log_msg DETAIL "Executing: cdscp create obj /.:/hosts/$HOSTNAME/profile CDS_Class RPC_Profile CDS_ClassVersion 1.0"
	echo "create obj /.:/hosts/$HOSTNAME/profile CDS_Class RPC_Profile CDS_ClassVersion 1.0"
	log_msg DETAIL "Executing: cdscp create obj /.:/hosts/$HOSTNAME/self CDS_Class RPC_Entry CDS_ClassVersion 1.0"
	echo "create obj /.:/hosts/$HOSTNAME/self CDS_Class RPC_Entry CDS_ClassVersion 1.0"
	log_msg DETAIL "Executing: cdscp create obj /.:/sec CDS_Class RPC_Group CDS_ClassVersion 1.0"
	echo "create obj /.:/sec CDS_Class RPC_Group CDS_ClassVersion 1.0"
	log_msg DETAIL "Executing: cdscp create obj /.:/sec-v1 CDS_Class RPC_Group CDS_ClassVersion 1.0"
	echo "create obj /.:/sec-v1 CDS_Class RPC_Group CDS_ClassVersion 1.0"

	# Dup fd3 to fd1 (restore it), close fd3
	exec 1>&3 3>&-

	# Issue all the cdscp commands:
	#cat $CDSTMPFILE | cdscp
	rm -f /tmp/cdscp_out$$
	cat $CDSTMPFILE | cdscp >/tmp/cdscp_out$$
	cdscp_status=$?
	rm -f $CDSTMPFILE
	chk_cdscp "cdscp - initializing the name service."

	# If we are using multiple lans, go do it.
	if [ ! -z "$LAN_NAME" ]; then
		do_multiple_lans
	fi

	# Generate file containing all the rpccp commands
	# Dup fd1 into fd3 (save it), set stdout to temp file
	exec 3>&1 > $RPCTMPFILE

	log_msg DETAIL "Executing rpccp commands."
	log_msg DETAIL "Executing rpccp add element -i d46113d0-a848-11cb-b863-08001e046aa5,2.0 \
                 -a rs_bind -m /.:/sec /.:/cell-profile"
	echo "add element -i d46113d0-a848-11cb-b863-08001e046aa5,2.0 \
                 -a rs_bind -m /.:/sec /.:/cell-profile"

	log_msg DETAIL "Executing: rpccp add element -i 0d7c1e50-113a-11ca-b71f-08001e01dc6c,1.0 \
-a secidmap -m /.:/sec-v1 /.:/cell-profile"
	echo "add element -i 0d7c1e50-113a-11ca-b71f-08001e01dc6c,1.0 \
                 -a secidmap -m /.:/sec-v1 /.:/cell-profile"

	log_msg DETAIL "Executing: rpccp add element -i 8f73de50-768c-11ca-bffc-08001e039431,1.0 \
-a krb5rpc  -m /.:/sec /.:/cell-profile"
	echo "add element -i 8f73de50-768c-11ca-bffc-08001e039431,1.0 \
                 -a krb5rpc  -m /.:/sec /.:/cell-profile"

	log_msg DETAIL "Executing: rpccp add element -i b1e338f8-9533-11c9-a34a-08001e019c1e,1.0 \
-a rpriv -m /.:/sec /.:/cell-profile"
	echo "add element -i b1e338f8-9533-11c9-a34a-08001e019c1e,1.0 \
                  -a rpriv -m /.:/sec /.:/cell-profile"

	log_msg DETAIL "Executing: rpccp add element -i b1e338f8-9533-11c9-a34a-08001e019c1e,1.1 \
-a rpriv -m /.:/sec /.:/cell-profile"
	echo "add element -i b1e338f8-9533-11c9-a34a-08001e019c1e,1.1 \
                  -a rpriv -m /.:/sec /.:/cell-profile" 

	log_msg DETAIL "Executing: rpccp add_element /.:/cell-profile -i $LAN -m /.:/lan-profile -a LAN -p 0"
	echo "add_element /.:/cell-profile -i $LAN -m /.:/lan-profile -a LAN -p 0"

	log_msg DETAIL "Executing: rpccp add_element /.:/hosts/$HOSTNAME/profile -m /.:/cell-profile -d -p 0"
	echo "add_element /.:/hosts/$HOSTNAME/profile -m /.:/cell-profile -d -p 0"

# Create/Export the server DACL manager UUID
	log_msg DETAIL "Executing: rpccp export -i 000cf72e-0688-1acb-97ad-08002b12b8f8,0001.0000 \
-b $CONFIG_PROTSEQ: -o faf2e540-58b8-11ca-a04a-08002b12a70d -s dce /.:/hosts/$HOSTNAME/cds-server "
	echo "export  -i 000cf72e-0688-1acb-97ad-08002b12b8f8,0001.0000 \
		-b $CONFIG_PROTSEQ: \
		-o faf2e540-58b8-11ca-a04a-08002b12a70d -s dce \
		/.:/hosts/$HOSTNAME/cds-server "

# Export the clerk DACL manager UUID
	log_msg DETAIL "Executing: rpccp export  -i 000cf72e-0688-1acb-97ad-08002b12b8f8,0001.0000 \
-b $CONFIG_PROTSEQ: -o dc8c6fc0-6143-11ca-b4b9-08002b1bb4f5 -s dce /.:/hosts/$HOSTNAME/cds-clerk"
	echo "export  -i 000cf72e-0688-1acb-97ad-08002b12b8f8,0001.0000 \
		-b $CONFIG_PROTSEQ: \
		-o dc8c6fc0-6143-11ca-b4b9-08002b1bb4f5 -s dce \
		/.:/hosts/$HOSTNAME/cds-clerk"

# adding cellname/fs
	log_msg DETAIL "Executing: rpccp add entry $cellname/fs"
	echo "add entry $cellname/fs"
	log_msg DETAIL "Executing: rpccp export -o \`uuidgen\` $cellname/fs"
	echo "export -o `uuidgen` $cellname/fs"

#adding cellname/subsys/dce/dfs/bak
	log_msg DETAIL "Executing: rpccp add entry $cellname/$SUBSYSDIR/$DFSDIR/bak"
        echo "add entry $cellname/$SUBSYSDIR/$DFSDIR/bak"
	log_msg DETAIL "Executing: rpccp export -o \`uuidgen\` $cellname/$SUBSYSDIR/$DFSDIR/bak"
        echo "export -o `uuidgen` $cellname/$SUBSYSDIR/$DFSDIR/bak"

#  Change the "-a fs" to "-a none" to make the fs junction invisible
	log_msg DETAIL "Executing: rpccp add element -i 4d37f2dd-ed43-0000-02c0-37cf2e000001,4.0 \
	-a fs -m /.:/fs /.:/cell-profile"
	echo "add element -i 4d37f2dd-ed43-0000-02c0-37cf2e000001,4.0 \
	-a fs -m /.:/fs /.:/cell-profile"

	log_msg DETAIL "Executing rpccp add element -i eb814e2a-0099-11ca-8678-02608c2ea96e,4.0 \
	-a bak -m /.:/subsys/dce/dfs/bak /.:/cell-profile"
	echo "add element -i eb814e2a-0099-11ca-8678-02608c2ea96e,4.0 \
	-a bak -m /.:/subsys/dce/dfs/bak /.:/cell-profile"

# Dup fd3 to fd1 (restore it), close fd3
# Just close things here for simplicity
	exec 1>&3 3>&-

# Export the DFS endpoint mapper host binding
	ip=`getip ${HOSTNAME}`
	if [ $? -ne 0 ]
	then
		echon "\tEnter the IP address of $HOSTNAME:  "
		read ip
	fi


	log_msg DETAIL "Executing: rpccp export -i e1af8308-5d1f-11c9-91a4-08002b14a0fa,3.0 \
-b $CONFIG_PROTSEQ:$ip[135] /.:/hosts/$HOSTNAME/self"
	echo "export -i e1af8308-5d1f-11c9-91a4-08002b14a0fa,3.0 \
		-b $CONFIG_PROTSEQ:$ip[135] \
		/.:/hosts/$HOSTNAME/self" >> $RPCTMPFILE
	echo "quit" >> $RPCTMPFILE

# Issue all the rpccp commands:
	rm -f /tmp/rpccp_out$$
	cat $RPCTMPFILE | rpccp > /tmp/rpccp_out$$
	rpccp_status=$?
	rm -f $RPCTMPFILE
	chk_rpccp "rpccp - initializing the name service."

#	Finally, acl_edit all the new namespace entries
	log_msg SUMMARY "Setting ACLs for all new namespace entries..."
	rm -f /tmp/acl_edit_out$$
	acl_edit_status=0

# Set the acls for the security objects
	log_msg DETAIL "Executing: acl_edit /.:/$SUBSYSDIR/$SECURITYDIR -ic \
-m user:dce-rgy:rwcidt -m group:$SUBSYSDIR/sec-admin:rwcidta"
	acl_edit /.:/$SUBSYSDIR/$SECURITYDIR -ic \
	-m user:dce-rgy:rwcidt \
	-m group:$SUBSYSDIR/sec-admin:rwcidta >/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit /.:/$SUBSYSDIR/$SECURITYDIR -io \
-m user:dce-rgy:rwdt -m group:$SUBSYSDIR/sec-admin:rwcdt"
	acl_edit /.:/$SUBSYSDIR/$SECURITYDIR -io \
	-m user:dce-rgy:rwdt \
	-m group:$SUBSYSDIR/sec-admin:rwcdt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit /.:/$SUBSYSDIR/$SECURITYDIR \
-m user:dce-rgy:rwcidt -m group:$SUBSYSDIR/sec-admin:rwcidta"
	acl_edit /.:/$SUBSYSDIR/$SECURITYDIR \
	-m user:dce-rgy:rwcidt \
	-m group:$SUBSYSDIR/sec-admin:rwcidta >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi
 
# Set the acls for cell-profile
	log_msg DETAIL "Executing: acl_edit -e /.:/cell-profile \
-m group:$SUBSYSDIR/dts-admin:rwt -m group:$SUBSYSDIR/dts-servers:rwt"
	acl_edit -e /.:/cell-profile \
	-m group:$SUBSYSDIR/dts-admin:rwt \
	-m group:$SUBSYSDIR/dts-servers:rwt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

# Set the acls for lan-profile
	log_msg DETAIL "Executing: acl_edit -e /.:/lan-profile \
-m group:$SUBSYSDIR/dts-admin:rwcdt -m group:$SUBSYSDIR/dts-servers:rwcdt"
	acl_edit -e /.:/lan-profile \
	-m group:$SUBSYSDIR/dts-admin:rwcdt \
	-m group:$SUBSYSDIR/dts-servers:rwcdt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

# Set the acls for the CDS clearinghouse
#
# Edit this acl to allow directory creation and replication
	clearinghouse="${HOSTNAME}_ch"
	log_msg DETAIL "Executing: acl_edit -e /.:/$clearinghouse -s \
unauthenticated:rt group:$SUBSYSDIR/cds-admin:rwcdt group:$SUBSYSDIR/cds-server:rwcdt any_other:rt"
	acl_edit -e /.:/$clearinghouse -s \
	unauthenticated:rt \
	group:$SUBSYSDIR/cds-admin:rwcdt \
	group:$SUBSYSDIR/cds-server:rwcdt \
	any_other:rt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit /.:/$clearinghouse -s \
unauthenticated:rt group:$SUBSYSDIR/cds-admin:rwcdt group:$SUBSYSDIR/cds-server:rwcdt any_other:rt"
	acl_edit /.:/$clearinghouse -s \
	unauthenticated:rt \
	group:$SUBSYSDIR/cds-admin:rwcdt \
	group:$SUBSYSDIR/cds-server:rwcdt \
	any_other:rt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit /.:/hosts \
-m user:hosts/$HOSTNAME/self:rwdtcia"
	acl_edit /.:/hosts \
	-m user:hosts/$HOSTNAME/self:rwdtcia >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit /.:/hosts/$HOSTNAME \
-m user:hosts/$HOSTNAME/self:rwdtcia"
	acl_edit /.:/hosts/$HOSTNAME \
	-m user:hosts/$HOSTNAME/self:rwdtcia >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	log_msg DETAIL "Executing: acl_edit -e /.:/sec \
-m group:$SUBSYSDIR/sec-admin:rwcdt -m user:dce-rgy:rwcdt"
	acl_edit -e /.:/sec \
	-m group:$SUBSYSDIR/sec-admin:rwcdt \
        -m user:dce-rgy:rwcdt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

# sec-v1 insert
	log_msg DETAIL "Executing: acl_edit -e /.:/sec-v1\
-m group:$SUBSYSDIR/sec-admin:rwcdt -m user:dce-rgy:rwcdt"
	acl_edit -e /.:/sec-v1 \
	-m group:$SUBSYSDIR/sec-admin:rwcdt \
        -m user:dce-rgy:rwcdt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit -e /.:/hosts/$HOSTNAME/self \
-m user:hosts/$HOSTNAME/self:rwdtc"
	acl_edit -e /.:/hosts/$HOSTNAME/self \
	-m user:hosts/$HOSTNAME/self:rwdtc >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit -e /.:/hosts/$HOSTNAME/cds-clerk \
-m user:hosts/$HOSTNAME/self:rwt"
	acl_edit -e /.:/hosts/$HOSTNAME/cds-clerk \
	-m user:hosts/$HOSTNAME/self:rwt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit -e /.:/hosts/$HOSTNAME/cds-server \
-m user:hosts/$HOSTNAME/self:rwt"
	acl_edit -e /.:/hosts/$HOSTNAME/cds-server \
	-m user:hosts/$HOSTNAME/self:rwt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit -e /.:/hosts/$HOSTNAME/profile \
-m user:hosts/$HOSTNAME/self:rwt"
	acl_edit -e /.:/hosts/$HOSTNAME/profile \
	-m user:hosts/$HOSTNAME/self:rwt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

# Modifying acls on sample applications directory
# delete, control, and admin only if authenticated
	log_msg DETAIL "Executing: acl_edit /.:/subsys/HP/sample-apps \
-m any_other:rwtdica \
-m unauthenticated:rwti"
	acl_edit /.:/subsys/HP/sample-apps \
		-m any_other:rwtdica \
		-m unauthenticated:rwti >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	chk_acl_edit "acl_edit - setting ACLs on new namespace entries."

	# Set the ACLs on security space items
	log_msg DETAIL "Executing: set_security_acls"
	set_security_acls

}

#------------------------------------------------------
# set_security_acls()
#
# Set ACLS on security objects in the name space.
#
# The secd bindings are specified directly on the
# ACL edit command lines in this routine for a reason.  
# Do not change this, unless you fully understand the
# implications!  The reason is it is not safe to assume 
# that CDS is available to provide the bindings.  At least 
# two situations have been identified where it cannot: 
# (1) secd has not yet registered with CDS (it attempts to
# do so every 60 seconds), and (2) in the split
# server configuration, the CDS client is not yet 
# configured on the CDS server when the acl_edit's are 
# performed.
#------------------------------------------------------
set_security_acls()
{

	log_msg DEBUG "Executing: set_security_acls()"
        BINDING=`grep $cellname $DCELOCAL/etc/security/pe_site | \
                 sed -e '1q'  | awk '{print $2}'`

	log_msg VERBOSE "Modifying ACLs on security objects in the name space."
	rm -f /tmp/acl_edit_out$$
	acl_edit_status=0

	#acl_edit /.:/sec/principal -io
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal -io  \
-m unauthenticated:rg -m user_obj:rfug -m group:acct-admin:rcDnfmaug -m other_obj:rg"
	acl_edit -addr "$BINDING" principal -io  \
	-m unauthenticated:rg \
	-m user_obj:rfug \
	-m group:acct-admin:rcDnfmaug \
	-m other_obj:rg >/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal -ic
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal -ic -m group:acct-admin:rcidDn"
	acl_edit -addr "$BINDING" principal -ic -m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal -m group:acct-admin:rcidDn"
	acl_edit -addr "$BINDING" principal -m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/krbtgt -ic
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/krbtgt -ic \
-m group:acct-admin:rcidDn"
	acl_edit -addr "$BINDING" principal/krbtgt -ic -m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/krbtgt -io
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/krbtgt -io  \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr "$BINDING" principal/krbtgt -io  \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/krbtgt
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/krbtgt  \
-m group:acct-admin:rciDdn"
	acl_edit -addr "$BINDING" principal/krbtgt  \
	-m group:acct-admin:rciDdn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/krbtgt/$shortcellname
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/krbtgt/$shortcellname  \
-m unauthenticated:rg -m group:acct-admin:rcDnfmaug"
	acl_edit -addr "$BINDING" principal/krbtgt/$shortcellname  \
	-m unauthenticated:rg \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/hosts
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/hosts \
-m group:acct-admin:rcidDn"
	acl_edit -addr "$BINDING" principal/hosts \
	-m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/hosts -io
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/hosts -io \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr "$BINDING" principal/hosts -io \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/hosts -ic
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/hosts -ic \
-m group:acct-admin:rcidDn"
	acl_edit -addr "$BINDING" principal/hosts -ic \
	-m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/hosts/$HOSTNAME
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/hosts/$HOSTNAME \
-m group:acct-admin:rcidDn"
	acl_edit -addr "$BINDING" principal/hosts/$HOSTNAME \
	-m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/hosts/$HOSTNAME -io
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/hosts/$HOSTNAME -io \
-m unauthenticated:rg -m group:acct-admin:rcDnfmaug"
	acl_edit -addr "$BINDING" principal/hosts/$HOSTNAME -io \
	-m unauthenticated:rg \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/hosts/$HOSTNAME -ic
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/hosts/$HOSTNAME -ic \
-m group:acct-admin:rcidDn"
	acl_edit -addr "$BINDING" principal/hosts/$HOSTNAME -ic \
	-m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/hosts/$HOSTNAME/self
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/hosts/$HOSTNAME/self  \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/hosts/$HOSTNAME/self  \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/hosts/$HOSTNAME/cds-server
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/hosts/$HOSTNAME/cds-server  \
-m group:acct-admin:rcDnfmag -m group:$SUBSYSDIR/cds-admin:rcDnfmag"
	acl_edit -addr $BINDING principal/hosts/$HOSTNAME/cds-server  \
	-m group:acct-admin:rcDnfmag \
	-m group:$SUBSYSDIR/cds-admin:rcDnfmag >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/hosts/$HOSTNAME/gda
	#acl_edit /.:/sec/group -ic
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group -ic \
-m group:acct-admin:rcidDn -m any_other:r"
	acl_edit -addr $BINDING group -ic \
	-m group:acct-admin:rcidDn \
	-m any_other:r >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group -io
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group -io \
-m group:acct-admin:rctDnfmM -m any_other:r"
	acl_edit -addr $BINDING group -io \
	-m group:acct-admin:rctDnfmM \
	-m any_other:r >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group \
-m group:acct-admin:rcidDn -m any_other:r"
	acl_edit -addr $BINDING group \
	-m group:acct-admin:rcidDn \
	-m any_other:r >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/acct-admin
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/acct-admin \
-m group_obj:rctDnfmM"
	acl_edit -addr $BINDING group/acct-admin \
	-m group_obj:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/subsys
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/subsys \
-m group:acct-admin:rcidDn"
	acl_edit -addr $BINDING group/subsys \
	-m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/group/subsys -io
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/subsys -io \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/subsys -io \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/subsys -ic
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/subsys -ic  \
-m group:acct-admin:rcidDn"
	acl_edit -addr $BINDING group/subsys -ic  \
	-m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/$SUBSYSDIR
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/$SUBSYSDIR \
-m group:acct-admin:rcidDn"
	acl_edit -addr $BINDING group/$SUBSYSDIR \
	-m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/$SUBSYSDIR -io -s
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/$SUBSYSDIR -io \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/$SUBSYSDIR -io \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/$SUBSYSDIR -ic
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/$SUBSYSDIR -ic \
-m group:acct-admin:rcidDn"
	acl_edit -addr $BINDING group/$SUBSYSDIR -ic \
	-m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/$SUBSYSDIR/sec-admin
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/$SUBSYSDIR/sec-admin \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/$SUBSYSDIR/sec-admin \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/$SUBSYSDIR/dts-admin
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/$SUBSYSDIR/dts-admin \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/$SUBSYSDIR/dts-admin \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/$SUBSYSDIR/dts-servers
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/$SUBSYSDIR/dts-servers  \
-m group:acct-admin:rctDnfmM -m group:$SUBSYSDIR/dts-admin:rctDnfmM"
	acl_edit -addr $BINDING group/$SUBSYSDIR/dts-servers  \
	-m group:acct-admin:rctDnfmM \
	-m group:$SUBSYSDIR/dts-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/$SUBSYSDIR/dfs-admin
#	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/$SUBSYSDIR/dfs-admin \
#	-m group:acct-admin:rctDnfmM"
#	acl_edit -addr $BINDING group/$SUBSYSDIR/dfs-admin \
#	-m group:acct-admin:rctDnfmM
#	if [ $? -ne 0 ]; then
#		acl_edit_status=1
#	fi
#
#	#acl_edit /.:/sec/group/$SUBSYSDIR/dfs-fs-servers
#	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/$SUBSYSDIR/dfs-fs-servers \
#	-m group:acct-admin:rctDnfmM \
#	-m group:$SUBSYSDIR/dfs-admin:rctDnfmM"
#	acl_edit -addr $BINDING group/$SUBSYSDIR/dfs-fs-servers \
#	-m group:acct-admin:rctDnfmM \
#	-m group:$SUBSYSDIR/dfs-admin:rctDnfmM
#	if [ $? -ne 0 ]; then
#		acl_edit_status=1
#	fi
#
#	#acl_edit /.:/sec/group/$SUBSYSDIR/dfs-bak-servers
#	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/$SUBSYSDIR/dfs-bak-servers \
#	-m group:acct-admin:rcDnfmM \
#	-m group:$SUBSYSDIR/dfs-admin:rcDnfmM"
#	acl_edit -addr $BINDING group/$SUBSYSDIR/dfs-bak-servers \
#	-m group:acct-admin:rcDnfmM \
#	-m group:$SUBSYSDIR/dfs-admin:rcDnfmM
#	if [ $? -ne 0 ]; then
#		acl_edit_status=1
#	fi


	#acl_edit /.:/sec/group/$SUBSYSDIR/cds-admin
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/$SUBSYSDIR/cds-admin  \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/$SUBSYSDIR/cds-admin  \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/$SUBSYSDIR/cds-server
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/$SUBSYSDIR/cds-server \
-m group:acct-admin:rctDnfmM -m group:$SUBSYSDIR/cds-admin:rctDnfmM -m group:$SUBSYSDIR/cds-server:rctDnfmM"
	acl_edit -addr $BINDING group/$SUBSYSDIR/cds-server \
	-m group:acct-admin:rctDnfmM \
	-m group:$SUBSYSDIR/cds-admin:rctDnfmM \
	-m group:$SUBSYSDIR/cds-server:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/$SUBSYSDIR/dced-admin
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/$SUBSYSDIR/dced-admin \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/$SUBSYSDIR/dced-admin \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/org
	log_msg DETAIL "Executing: acl_edit -addr $BINDING org -m group:acct-admin:rcidDn"
	acl_edit -addr $BINDING org -m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/org -io \
	log_msg DETAIL "Executing: acl_edit -addr $BINDING org -io -m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING org -io -m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/org -ic
	log_msg DETAIL "Executing: acl_edit -addr $BINDING org -ic -m group:acct-admin:rcidDn"
	acl_edit -addr $BINDING org -ic -m group:acct-admin:rcidDn >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/policy
	# NOTE: in 1.0.2, because of security replication changes, the A bit is being
	# moved to "replist" object (as yet undefined)
	log_msg DETAIL "Executing: acl_edit -addr $BINDING policy -m group:acct-admin:rcmaA"
	acl_edit -addr $BINDING policy -m group:acct-admin:rcma >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#
	# The following are all created by sec_create_db
	#


	# principals
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/nobody \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/nobody \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/principal/root
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/root \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/root \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/principal/daemon
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/daemon \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/daemon \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/principal/sys
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/sys \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/sys \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/principal/bin
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/bin \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/bin \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/principal/uucp
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/uucp \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/uucp \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/principal/who
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/who \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/who \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/principal/mail
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/mail \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/mail \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/principal/tcb
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/tcb \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/tcb \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/principal/dce-ptgt
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/dce-ptgt \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/dce-ptgt \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	#acl_edit /.:/sec/principal/dce-rgy
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/dce-rgy \
-m group:acct-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/dce-rgy \
	-m group:acct-admin:rcDnfmaug >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	# groups
	#acl_edit /.:/sec/group/none
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/none \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/none \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/system
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/system \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/system \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/daemon
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/daemon \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/daemon \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/uucp
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/uucp \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/uucp \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/bin
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/bin \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/bin \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/kmem
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/kmem \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/kmem \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/mail
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/mail \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/mail \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/tty
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/tty \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/tty \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	#acl_edit /.:/sec/group/tcb
	log_msg DETAIL "Executing: acl_edit -addr $BINDING group/tcb \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING group/tcb \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi


	# Orgs
	#acl_edit /.:/sec/org/none
	log_msg DETAIL "Executing: acl_edit -addr $BINDING org/none \
-m group:acct-admin:rctDnfmM"
	acl_edit -addr $BINDING org/none \
	-m group:acct-admin:rctDnfmM >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	# enter acl entries for security server (master)
	# sec and cds servers can be configured on separate node,
	# get sec server host name
	if [ "${sec_server}" = "" ]
	then
		SEC_HOSTNAME=${HOSTNAME}
	else
		# there is a chance that users can enter a wrong
		# sec_server and IP is used instead.
		SEC_HOSTNAME=${sec_server}
	fi

	log_msg DETAIL "Executing: acl_edit -addr $BINDING replist \
-m user:hosts/$SEC_HOSTNAME/self:imI"
	acl_edit -addr $BINDING replist \
	-m user:hosts/$SEC_HOSTNAME/self:imI >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "\tModifying acls on /.:/$SUBSYSDIR/$SECURITYDIR ..."
	acl_edit /.:/$SUBSYSDIR/$SECURITYDIR \
	-m user:hosts/$SEC_HOSTNAME/self:rwdtcia >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	acl_edit /.:/$SUBSYSDIR/$SECURITYDIR \
	-io -m user:hosts/$SEC_HOSTNAME/self:rwdtc >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	acl_edit /.:/$SUBSYSDIR/$SECURITYDIR \
	-ic -m user:hosts/$SEC_HOSTNAME/self:rwdtci >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "\tModifying acls on /.:/$SECURITYDIR ..."
	acl_edit -e /.:/$SECURITYDIR \
	-m user:hosts/$SEC_HOSTNAME/self:rwdtc >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	chk_acl_edit "acl_edit - modifying ACLs on security objects in the name space."

}

#------------------------------------------------------
# config_morecds()
#
# nth CDS Server Configuration
#       Get the name of the Initial CDS Server. Ensure
#             it isn't this machine.
#	Configure this machine as a security client if needed.
#	If its not a CDS client, make it one.
#	Ensure the administrative user is in the cds-admin
#	      group, re-authenticating if necessary.
#	Check for installation of the cdsd daemon.
#	Update the configuration file cds.conf.
# 	Start the cdsd daemon 
#	Invoke the cds_replicate() routine to create additional
#	      CDS clearinghouses
#------------------------------------------------------
config_morecds()
{
	log_msg DEBUG "Executing: config_morecds()"

	# Ensure CDS server binaries have been installed
	if [ ! -x ${DCE_DAEMONS}/cdsd ]
	then
		err_exit "${DCE_DAEMONS}/cdsd is not installed. \
Continuing will return to the Previous Menu."
		return
	fi

   # Ensure an initial CDS server has been created in the cell.

   this_server=${HOSTNAME}
   #
   # Support configuration input via environment variables
   #
   if [ $cache_cds_server ]; then
	:;
   else
	cache_cds_server=${CACHE_CDS_SERVER:="NULL"}
   fi
   until [ ${cache_cds_server:="NULL"} != "NULL" ]; do
		log_msg VERBOSE "User query: A CDS server must have already been configured.
What is the name of a CDS server in this cell
(if there is more than one, enter the name of 
the server to be cached if necessary)? "
		echo "\tA CDS server must have already been configured."
		echo "\tWhat is the name of a CDS server in this cell"
		echo "\t(if there is more than one, enter the name of"
		echon "\tthe server to be cached if necessary)? "
		read cache_cds_server
		log_msg VERBOSE "User entry: $cache_cds_server"
   done

   cache_cds_server=${cache_cds_server:-$this_server}
   cache_cds_server=`echo $cache_cds_server | cut -f1 -d"." 2>/dev/null`
	
   if [ "$cache_cds_server" = "$this_server" ]
   then
	err_exit "You must first configure an initial CDS server using the \
INITIAL CELL CONFIGURATION option for a CDS Server.  \
Continuing will return to the Previous Menu."
	return
   else

	if [ ! -f $DCELOCAL/dce_cf.db ]
	then
		create_dcecfdb
	fi

	# Configure as a security client if sec_client_service isn't running.
	check_for_sec_client_service
	rtn_status=$?
	if [ $rtn_status -eq 2 ]
	then
		err_exit "Continuing will return to the Previous Menu."
		return
	fi
	if [ $rtn_status -eq 0 ]
	then
		config_secclient
	fi

	# Configure as a CDS client if cdsadv isn't running.
	ps ${PSARGS} | grep -q cdsadv > /dev/null
	if [ $? -ne 0 ]
	then
		config_cdsclient
	fi

	# verify that node is now a CDS client
	ps ${PSARGS} | grep -q cdsadv
	if [ $? -ne 0 ]
	then
		err_exit "Failed to configure node as a CDS client.  This node \
must be configured as a CDS client before it can be configured \
as an additional CDS server.  Continuing will return to the Previous Menu."
		return
	fi

	klist | grep cds-admin >/dev/null 2>&1
	if [ $? != 0 ]
	then
		log_msg DEBUG "Executing: dcelogin (from config_morecds)"
		dcelogin
		if [ $? != 0 ]; then
			menu0
		fi
	fi


	# Set BIND_PE_SITE=0 so that these CDS processes don't try to use
	# the pe_site file.  This is especially necessary for cross-cell
	# authentication to happen correctly.

	log_msg VERBOSE "Executing: BIND_PE_SITE=0"
	BIND_PE_SITE=0

        # Ensure cdsd has already been installed
        if [ ! -x ${DCE_DAEMONS}/cdsd ]
        then
                # Set BIND_PE_SITE back for further config
                log_msg VERBOSE "Executing: BIND_PE_SITE=1"
                BIND_PE_SITE=1
                err_exit "${DCE_DAEMONS}/cdsd is not installed. \
Continuing will return to the Previous Menu."
                return
        fi

        log_msg VERBOSE "Updating the cds.conf file."
        # Update the CDS configuration file cds.conf
        log_msg DETAIL "Executing: echo \"cds.cdsd.security.server_princ_name: \
hosts/${HOSTNAME}/cds-server\" > ${DCELOCAL}/etc/cds.conf"
        echo "cds.cdsd.security.server_princ_name: hosts/${HOSTNAME}/cds-server" > ${DCELOCAL}/etc/cds.conf
        log_msg DETAIL "Executing: echo \"cds.*.security.host_princ_name: \
hosts/${HOSTNAME}/self\" >> ${DCELOCAL}/etc/cds.conf"
        echo "cds.*.security.host_princ_name: hosts/${HOSTNAME}/self" >> ${DCELOCAL}/etc/cds.conf
        log_msg DETAIL "Executing: echo \"cds.*.security.server_group_name: \
${SUBSYSDIR}/cds-server\" >> ${DCELOCAL}/etc/cds.conf"
        echo "cds.*.security.server_group_name: ${SUBSYSDIR}/cds-server" >> ${DCELOCAL}/etc/cds.conf
        log_msg DETAIL "Executing: echo \"cds.*.security.admin_group_name: \
${SUBSYSDIR}/cds-admin\" >> $DCELOCAL/etc/cds.conf"
        echo "cds.*.security.admin_group_name: ${SUBSYSDIR}/cds-admin" >> ${DCELOCAL}/etc/cds.conf

	# Start cdsd (withOUT the -a)
	log_msg SUMMARY "Starting cdsd..."
        ps ${PSARGS} | grep -q cdsd
	if [ $? = 0 ]
	then
		# Set BIND_PE_SITE back for further config
		log_msg VERBOSE "Executing: BIND_PE_SITE=1"
		BIND_PE_SITE=1
		err_exit "cdsd is already running.  Continuing will return to the Previous Menu."
		return
	fi

	# Initialize namespace to reflect additional server

	ns_addserver_init


        #
        #
	log_msg DETAIL "Executing: cdsd"
	cdsd
	if [ $? -ne 0 ]
	then
		# Set BIND_PE_SITE back for further config
		log_msg VERBOSE "Executing: BIND_PE_SITE=1"
		BIND_PE_SITE=1
		err_exit "cdsd failed to start.  \
Continuing will return to the Previous Menu."
		return
	fi
	modify_rcfile cdsd

        cds_replicate

	# Set BIND_PE_SITE back for further config
	log_msg VERBOSE "Executing: BIND_PE_SITE=1"
	BIND_PE_SITE=1

   fi
}

#------------------------------------------------------
# cds_replicate()
#
# nth CDS Server Configuration
#    Prompt for name of this new clearinghouse, ensuring
#	 it's different from the original CDS clearinghouse's
#	 name.
#    Create new clearinghouse on this CDS server
#    replicate the specified directories
#------------------------------------------------------
cds_replicate()
{
	log_msg DEBUG "Executing: cds_replicate()"
	# Get clearinghouse name, and ensure it differs from
	# the default clearinghouse name.
	#
	# Support configuration input via environment variables
	newchname=${REP_CLEARINGHOUSE:="NULL"}
	until [ ${newchname:="NULL"} != "NULL" ]
	do
	    log_msg VERBOSE "User query: What is the name for this clearinghouse?  "
	    echon "\tWhat is the name for this clearinghouse?  "
	    read newchname
	    log_msg VERBOSE "User entry: $newchname"
	done

	default_ch=${cache_cds_server}

        while [ "$newchname" = "$default_ch" ]
        do
		log_msg VERBOSE "User query: New Clearinghouse name must differ from $default_ch.  
What is the name for this clearinghouse?"
                echo "\tNew Clearinghouse name must differ from $default_ch"
                echon "\tWhat is the name for this clearinghouse?"
                read newchname
		log_msg VERBOSE "User entry: $newchname"
        done

	log_msg VERBOSE "Creating clearinghouse files and replica for root directory."
	log_msg DETAIL "Executing: cdscp create clearinghouse /.:/$newchname"
	rm -f /tmp/cdscp_out$$
	cdscp create clearinghouse /.:/$newchname >/tmp/cdscp_out$$ 2>&1
	cdscp_status=$?
	chk_cdscp "Error during creation of clearinghouse /.:/$newchname."


	# Set the acls for the CDS clearinghouse
	echo "\tModifying acls on /.:/$newchname"
	acl_edit -e /.:/$newchname -s \
	unauthenticated:rt \
	group:$SUBSYSDIR/cds-admin:rwcdt \
	group:$SUBSYSDIR/cds-server:rwcdt \
	any_other:rt

	acl_edit /.:/$newchname -s \
	unauthenticated:rt \
	group:$SUBSYSDIR/cds-admin:rwcdt \
	group:$SUBSYSDIR/cds-server:rwcdt \
	any_other:rt
 
	dir_replicate=${DIR_REPLICATE:="NULL"}
	until [ ${dir_replicate:="NULL"} != "NULL" ];do
		log_msg VERBOSE "User query: Should more directories be replicated? (n)  "
		echon "\tShould more directories be replicated? (n)  "
		read dir_replicate
		dir_replicate=${dir_replicate:-"n"}
		log_msg VERBOSE "User entry: $dir_replicate"
	done
	case $dir_replicate in
		y) replicate_more;;
		yes) replicate_more;;
		*) ;;
	esac
}

#------------------------------------------------------
# replicate_more()
#
# This routine is called from the cds_replicate() routine
# above during the config_morecds() routine.  It is done
# when configuring an Nth CDS server.
#
#	Replicate as many directories as requested.
#------------------------------------------------------
replicate_more()
{
	log_msg DEBUG "Executing: replicate_more()"
	log_msg VERBOSE "User query: Enter the list of directories to be replicated, separated by spaces,
and terminated by <RETURN>:"
	echo "\tEnter the list of directories to be replicated, separated by spaces,"
	echo "\tand terminated by <RETURN>: "
	read LIST
	log_msg VERBOSE "User entry: $LIST"
	for i in $LIST
	do
		log_msg VERBOSE "Replicating $i."
		log_msg DETAIL "Executing: cdscp create replica /.:/$i clearinghouse /.:/$newchname"
		cdscp create replica /.:/$i clearinghouse /.:/$newchname >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			err_exit "Failed to create replica /.:/$i clearinghouse /.:/$newchname.  Continuing will return to the \
Main Menu."
			menu0
		fi
	done
}

#------------------------------------------------------
# config_gda()
#
# Add registry entry for gda principal
# Set acl's on the pricipal
# Start the gdad.
# The -x and -b switches it takes are for debugging only
#------------------------------------------------------
config_gda()
{
	switches=$*
	log_msg DEBUG "Executing: config_gda()"

	# verify gdad is not already running
	ps ${PSARGS} | grep -q gdad
	if [ $? -eq 0 ]
	then
		err_exit "gdad is already running.  Continuing will return to the Previous Menu."
		return
	fi

	# Ensure gdad server binaries have been installed
	if [ ! -x ${DCE_DAEMONS}/gdad ]
	then
		err_exit "${DCE_DAEMONS}/gdad is not installed.  \
Continuing will return to the Previous Menu."
		return
	fi

	log_msg VERBOSE "To run the gda with the Domain Name System, the administrator \
must manually register the information with named by obtaining the output of the cdscp show cell \
and registering it with named.  Then, restart named."

	# Ensure security client has been enabled
	check_for_sec_client_service
	rtn_status=$?
	if [ $rtn_status -eq 2 ]
	then
		err_exit "Continuing will return to the Previous Menu."
		return
	fi
	if [ $rtn_status -eq 0 ]
	then
		err_exit "Node must be configured as a client before installing a GDA server.  \
Continuing will return to the Previous Menu."
		return
	fi

	# Ensure cds client has been enabled
	ps ${PSARGS} | grep -q cdsadv
	if [ $? -ne 0 ]
	then
		err_exit "Node must be configured as a client before installing a GDA server.  \
Continuing will return to the Previous Menu."
		return
	fi

	log_msg SUMMARY "Adding entry for GDA to the registry database."
	log_msg DETAIL "Executing: rgy_edit> domain principal"
	log_msg DETAIL "Executing: rgy_edit> add hosts/$HOSTNAME/gda"
	log_msg DETAIL "Executing: rgy_edit> domain account"
	log_msg DETAIL "Executing: rgy_edit> add hosts/$HOSTNAME/gda \
-g $SUBSYSDIR/cds-server -o none -pw <not shown> -mp <not shown>"
	log_msg DETAIL "Executing: rgy_edit> ktadd -p hosts/$HOSTNAME/gda -pw <not shown>"
	log_msg DETAIL "Executing: rgy_edit> ktadd -p hosts/$HOSTNAME/gda -a -r"
	log_msg DETAIL "Executing: rgy_edit> quit"

	rm -f /tmp/rgy_edit_out$$
	rgy_edit -update >/tmp/rgy_edit_out$$ 2>&1 <<EOF
domain principal
add hosts/$HOSTNAME/gda
domain account
add hosts/$HOSTNAME/gda -g $SUBSYSDIR/cds-server -o none -pw $cellpw -mp $cellpw
quit
EOF
	rgy_edit_status=$?
	chk_rgy_edit "rgy_edit - adding entry for GDA to the registry database."

	# If there are security replicas, we must wait till they are
	# up to date before doing keytab update.
	log_msg DETAIL "Executing: verify_consistency()"
	verify_consistency
	if [ "$?" -ne 0 ]; then
		log_msg VERBOSE "Security server replicas are not consistent \
with the master.  Some servers may be stopped or otherwise unavailable.  This \
is ok since the running servers are consistent, however, there \
exists the unlikely possibility that ktadd may bind to a server that has come \
back up between the time when the \"dcecp registry verify\" command was \
executed and before the ktadd command itself is executed.  The server that \
ktadd is bound to may not yet be consistent with the master server, and if \
this is the case then you must UNCONFIGURE and REMOVE this node from the \
cell before reconfiguring.  Check the output from the rgy_edit command \
immediately following the ktadd commands."
	fi

	rgy_edit -update >/tmp/rgy_edit_out$$ 2>&1 <<EOF
ktadd -p hosts/$HOSTNAME/gda -pw $cellpw
ktadd -p hosts/$HOSTNAME/gda -a -r
quit
EOF
	rgy_edit_status=$?
	chk_rgy_edit "rgy_edit - adding entry for GDA to the registry database."
        BINDING=`grep $cellname $DCELOCAL/etc/security/pe_site | \
                 sed -e '1q'  | awk '{print $2}'`

	#acl_edit /.:/sec/principal/hosts/$HOSTNAME/gda
	rm -f /tmp/acl_edit_out$$
	acl_edit_status=0
	log_msg DETAIL "Executing: acl_edit -addr $BINDING principal/hosts/$HOSTNAME/gda \
-m group:acct-admin:rcDnfmaug -m group:$SUBSYSDIR/cds-admin:rcDnfmaug"
	acl_edit -addr $BINDING principal/hosts/$HOSTNAME/gda \
	-m group:acct-admin:rcDnfmaug \
	-m group:$SUBSYSDIR/cds-admin:rcDnfmaug >/tmp/acl_edit_out$$ 2>&1
	acl_edit_status=$?
	chk_acl_edit "acl_edit - modifying ACLs on GDA object in the name space."

	# Create/Export the GDA server DACL manager UUID
	rm -f /tmp/rpccp_out$$
	rpccp_status=0
	log_msg DETAIL "Executing:rpccp export -i 000cf72e-0688-1acb-97ad-08002b12b8f8,0001.0000 \
		-b $CONFIG_PROTSEQ: \
		-o fa620458-924f-11cc-840e-08002b1c8a62 -s dce \
		/.:/hosts/$HOSTNAME/cds-gda > /tmp/rpccp_out$$"
	rpccp export -i 000cf72e-0688-1acb-97ad-08002b12b8f8,0001.0000 \
		-b $CONFIG_PROTSEQ: \
		-o fa620458-924f-11cc-840e-08002b1c8a62 -s dce \
		/.:/hosts/$HOSTNAME/cds-gda > /tmp/rpccp_out$$
	rpccp_status=$?
	chk_rpccp "rpccp - initializing the name service"

	log_msg VERBOSE "Modifying acls on /.:/hosts/$HOSTNAME/cds-gda"
	rm -f /tmp/acl_edit_out$$
	acl_edit_status=0
	log_msg DETAIL "Executing: acl_edit -e /.:/hosts/$HOSTNAME/cds-gda -m user:hosts/$HOSTNAME/self:rwt"
	acl_edit -e /.:/hosts/$HOSTNAME/cds-gda \
	-m user:hosts/$HOSTNAME/self:rwt >/tmp/acl_edit_out$$ 2>&1
	acl_edit_status=$?
	chk_acl_edit "acl_edit - modifying ACLs on GDA object in the name space."

	log_msg SUMMARY "Adding GDA principal entry to cds.conf file."

	log_msg DETAIL "Executing: echo \"cds.gdad.security.server_princ_name: \
hosts/$HOSTNAME/gda\" >> $DCELOCAL/etc/cds.conf"
	echo "cds.gdad.security.server_princ_name: hosts/$HOSTNAME/gda" >> $DCELOCAL/etc/cds.conf

	log_msg SUMMARY "Starting gdad..."
	log_msg DETAIL "Executing: gdad"
	gdad
	modify_rcfile gdad
}

#------------------------------------------------------
# config_secclient()
#
# Perform the initialization required to make this machine
# a security client.
#
#  	Get the name and IP address of the security server
#	Add the kerberos5 entry to /etc/services
#	Create the /krb5/krb.conf file to match the
#		security server's file
#	Create necessary configuration for krb5 interoperability
#	Create the $DCELOCAL/var/security/pe_site file 
#		to match the security server's file
#	Start the endpoint mapper if necessary
#  	Add the ktab entry to the registry database for this client
#	Add hosts/<hostname>/self principal and keytab entry
#	Start sec_client service
#------------------------------------------------------
config_secclient()
{
	# Is this node already a security client?
	check_for_sec_client_service > /dev/null
	rtn_status=$?
	if [ $rtn_status -eq 2 ]
	then
		err_exit "Continuing will return to the Previous Menu."
		return
	fi
	if [ $rtn_status -ne 0 ]
	then
		log_msg SUMMARY "This node is already a security client."
		return
	fi


	log_msg DEBUG "Executing: config_secclient()"
	#
	# Support configuration input via environment variables
	#
	if [ "${sec_server:="NULL"}" = "NULL" ]
	then
	    sec_server=${SEC_SERVER:="NULL"}
	fi
	until [ ${sec_server:="NULL"} != "NULL" ]
	do
	    log_msg VERBOSE "User query: What is the name of the Security Server for this cell?  "
	    echon "\tWhat is the name of the Security Server for this cell?  "
	    read sec_server
	    log_msg VERBOSE "User entry: $sec_server"
        done
	ip=`getip ${sec_server}`
	if [ $? != 0 ]
	then
	    # Support configuration input via environment variables
	    #
	    ip=${SEC_SERVER_IP:="NULL"}
	    until [ "${ip:="NULL"}" != "NULL" ]
	    do
		log_msg VERBOSE "User query: Enter the IP address for $sec_server:  "
		echon "\tEnter the IP address for $sec_server:  "
		read ip
		log_msg VERBOSE "User entry: $ip"
	    done
        fi

        # Create krb.conf file
	log_msg VERBOSE "Creating /krb5/krb.conf file."
	while [ -f /krb5/krb.conf -a ! -w /krb5/krb.conf ]
	do
		err_exit "Existing /krb5/krb.conf can not be overwritten.  Continuing will re-try."
	done
	if [ ! -d /krb5 ]
	then
		mkdir -p /krb5
	fi
	log_msg DETAIL "Executing: echo $shortcellname  > /krb5/krb.conf"
	echo $shortcellname  > /krb5/krb.conf || \
		{ err_exit "Write to /krb5/krb.conf failed.  Continuing will return to the Previous Menu."; return; }
	log_msg DETAIL "Executing: echo $shortcellname $sec_server  >> /krb5/krb.conf"
	echo "$shortcellname $sec_server"  >> /krb5/krb.conf || \
		{ err_exit "Write to /krb5/krb.conf failed.  Continuing will return to the Previous Menu."; return; }

	# Add entry to /etc/services
	add_service kerberos5 $KERB_PORT udp kdc

        # Config as krb5 client
        log_msg DETAIL "Executing: krb5_client config"
        config_krb5client $sec_server
	if [ $? -ne 0 ]; then
		return
	fi

	# Create self entry for this client node
	log_msg VERBOSE "Adding self entry to registry for this client node."
	log_msg DETAIL "Executing: rgy_edit> domain principal"
	log_msg DETAIL "Executing: rgy_edit> add hosts/$HOSTNAME/self"
	log_msg DETAIL "Executing: rgy_edit> domain account"
	log_msg DETAIL "Executing: rgy_edit> add hosts/$HOSTNAME/self -g none -o none -pw <not shown> -mp <not shown>"
	log_msg DETAIL "Executing: rgy_edit> quit"
	rm -f /tmp/rgy_edit_out$$
	rgy_edit -update >/tmp/rgy_edit_out$$ 2>&1 <<EOF
domain principal
add hosts/$HOSTNAME/self
domain account
add hosts/$HOSTNAME/self -g none -o none -pw $cellpw -mp $cellpw
quit
EOF
	rgy_edit_status=$?
	chk_rgy_edit "rgy_edit - adding self entry to registry database."

	# If there are security replicas, we must wait till they are
	# up to date before doing keytab update.
	log_msg DETAIL "Executing: verify_consistency()"
	verify_consistency
	if [ "$?" -ne 0 ]; then
		log_msg VERBOSE "Security server replicas are not consistent \
with the master.  Some servers may be stopped or otherwise unavailable.  This \
is ok since the running servers are consistent, however, there \
exists the unlikely possibility that ktadd may bind to a server that has come \
back up between the time when the \"dcecp registry verify\" command was \
executed and before the ktadd command itself is executed.  The server that \
ktadd is bound to may not yet be consistent with the master server, and if \
this is the case then you must UNCONFIGURE and REMOVE this node from the \
cell before reconfiguring.  Check the output from the rgy_edit command \
immediately following the ktadd commands."
	fi

	log_msg VERBOSE "Creating ktab entry in registry for this client node."
	log_msg DETAIL "Executing: rgy_edit> ktadd -p hosts/$HOSTNAME/self -pw <not shown>"
	log_msg DETAIL "Executing: rgy_edit> ktadd -p hosts/$HOSTNAME/self -a -r"
	log_msg DETAIL "Executing: rgy_edit> quit"
	rm -f /tmp/rgy_edit_out$$

	rgy_edit -update >/tmp/rgy_edit_out$$ 2>&1 <<EOF
ktadd -p hosts/$HOSTNAME/self -pw $cellpw
ktadd -p hosts/$HOSTNAME/self -a -r
quit
EOF

	rgy_edit_status=$?
	chk_rgy_edit "rgy_edit - creating ktab entry in registry database."

	log_msg DETAIL "Executing: sec_client service startup"
	start_sec_client_service modify_rcfile
	if [ $? -ne 0 ]; then
		return
	fi

}
#
#------------------------------------------------------
# config_krb5client()
#
# Perform the initialization required to make this machine
# a Krb5 client.
#	Add kshell, ekshell, klogin, eklogin entries to
#		/etc/services
#	Add kshell, ekshell, klogin, eklogin entries to
#		/etc/inetd.conf and restart inetd.
#	Add host/<hostname> principal and keytab entry
#	Create /krb5/krb.realms file
#
# Syntax: config_krb5client [security server hostname]
#------------------------------------------------------
config_krb5client()
{
	sec_server=$1

        # Is this node already a krb5 client?
        check_for_krb5_client
        if [ $? -ne 0 ]
        then
                log_msg SUMMARY "This node is already a krb5 client."
                return
        fi

	log_msg DEBUG "Executing: config_krb5client()"
        log_msg DEBUG "fully qualified name is: $HOSTNAME.$krb5_domain"

	# Adding entries to /etc/services
	add_service klogin 543 tcp ""
	add_service kshell 544 tcp "krcmd kcmd"
	add_service ekshell 545 tcp "krcmd"
	add_service eklogin 2105 tcp ""

	# Adding entries to /etc/inetd.conf
	add_inetd_service klogin stream tcp nowait root $DCELOCAL/etc/rlogind "rlogind -k"
	add_inetd_service eklogin stream tcp nowait root $DCELOCAL/etc/rlogind "rlogind -kx"
	add_inetd_service kshell stream tcp nowait root $DCELOCAL/etc/rshd "rshd -k"
	add_inetd_service ekshell stream tcp nowait root $DCELOCAL/etc/rshd "rshd -kx"

	# Restart inetd
	log_msg DETAIL "Executing get_pid \"inetd\" | xargs kill -HUP > /dev/null 2>&1"
	get_pid "inetd" | xargs kill -HUP > /dev/null 2>&1

	# Create host entry for secure BSD remote utilities
        fully_qual_host=$HOSTNAME.$krb5_domain

	dcecp_out=/tmp/dcecp_out$$

	log_msg VERBOSE "Adding krb5 host entry to registry for this client node."
	log_msg DETAIL "Executing: dcecp -c principal create host/$fully_qual_host"
	dcecp_status=0
	dcecp -c principal create host/$fully_qual_host > $dcecp_out 2>&1
        if [ $? -ne 0 ]; then
                dcecp_status=1
        fi
	chk_dcecp "Creating krb5 host principal"

	log_msg DETAIL "Executing: dcecp -c group add none -member host/$fully_qual_host"
	dcecp_status=0
	dcecp -c group add none -member host/$fully_qual_host > $dcecp_out 2>&1
        if [ $? -ne 0 ]; then
                dcecp_status=1
        fi
	chk_dcecp "Adding group membership for krb5 host principal"

	log_msg DETAIL "Executing: dcecp -c organization add none -member host/$fully_qual_host"
	dcecp_status=0
	dcecp -c organization add none -member host/$fully_qual_host> $dcecp_out 2>&1
        if [ $? -ne 0 ]; then
                dcecp_status=1
        fi
	chk_dcecp "Adding org membership for krb5 host principal"

	log_msg DETAIL "Executing: dcecp account create host/$fully_qual_host -mypwd <not shown> \
-password <not shown> -group none -organization none"
	dcecp_status=0
	echo account create host/$fully_qual_host -mypwd $cellpw \
		-password $cellpw -group none -organization none | dcecp \
		> $dcecp_out 2>&1
        if [ $? -ne 0 ]; then
                dcecp_status=1
        fi
	chk_dcecp "Creating krb5 host account"

        # If there are security replicas, we must wait till they are
        # up to date before doing keytab update.
        log_msg DETAIL "Executing: verify_consistency()"
        verify_consistency
        if [ "$?" -ne 0 ]; then
                log_msg VERBOSE "Security server replicas are not consistent \
with the master.  Some servers may be stopped or otherwise unavailable.  This \
is ok since the running servers are consistent, however, there \
exists the unlikely possibility that ktadd may bind to a server that has come \
back up between the time when the \"dcecp registry verify\" command was \
executed and before the ktadd command itself is executed.  The server that \
ktadd is bound to may not yet be consistent with the master server, and if \
this is the case then you must UNCONFIGURE and REMOVE this node from the \
cell before reconfiguring.  Check the output from the rgy_edit command \
immediately following the ktadd commands."
        fi

	#
	# XXX - We use rgy_edit instead of dcecp because the dcecp
	# XXX - keytab create command has a dependency on CDS (which may
	# XXX - be fixed soon), and CDS may not be available yet.
	#
        log_msg VERBOSE "Creating ktab entry for krb5 host principal."
        log_msg DETAIL "Executing: rgy_edit> ktadd -p host/$fully_qual_host -pw <not shown>"
        log_msg DETAIL "Executing: rgy_edit> ktadd -p host/$fully_qual_host -a -r"
        log_msg DETAIL "Executing: rgy_edit> quit"
        rm -f /tmp/rgy_edit_out$$

        rgy_edit -update >/tmp/rgy_edit_out$$ 2>&1 <<EOF
ktadd -p host/$fully_qual_host -pw $cellpw
ktadd -p host/$fully_qual_host -a -r
quit
EOF

        rgy_edit_status=$?
        chk_rgy_edit "rgy_edit - creating ktab entry in registry database."

	log_msg VERBOSE "Creating /krb5/krb.realms file."
        while [ -f /krb5/krb.realms -a ! -w /krb5/krb.realms ]
        do
                err_exit "Existing /krb5/krb.realms can not be overwritten.  Continuing will re-try."
        done
        if [ ! -d /krb5 ]
        then
                mkdir -p /krb5
        fi
        log_msg DETAIL "Executing: echo .$krb5_domain $shortcellname  > /krb5/krb.realms"
        echo ".$krb5_domain" $shortcellname  > /krb5/krb.realms || \
                { err_exit "Write to /krb5/krb.realms failed.  Continuing will return to the Previous Menu."; return; }

        log_msg DETAIL "Executing: chmod 644 /krb5/krb.realms"
        chmod 644 /krb5/krb.realms

	#
	# Create bare-bones /etc/krb5.conf for krb5 beta5 clients
	# Link /etc/v5srvtab to /krb5/v5srvtab
	#
	log_msg VERBOSE "Creating /etc/krb5.conf file."
	while [ -f /etc/krb5.conf -a ! -w /etc/krb5.conf ]
	do
		err_exit "Existing /etc/krb5.conf can not be overwritten.  Continuing will re-try."
        done
	if [ ! -d /krb5 ]
	then
		mkdir -p /krb5
	fi
	log_msg DETAIL "Executing: echo [realms]\n\t$shortcellname = {  > /etc/krb5.conf"
	echo "[realms]\n\t$shortcellname = {"  > /etc/krb5.conf || \
		{ err_exit "Write to /etc/krb5.conf failed.  Continuing will return to the Previous Menu."; return; }
	log_msg DETAIL "Executing: echo \t\tkdc = $sec_server\n\t}\n >> /etc/krb5.conf"
	echo "\t\tkdc = $sec_server\n\t}\n" >> /etc/krb5.conf || \
		{ err_exit "Write to /etc/krb5.conf failed.  Continuing will return to the Previous Menu."; return; }
	log_msg DETAIL "Executing: echo [domain_realm]\n\t.$krb5_domain = $shortcellname >> /etc/krb5.conf"
	echo "[domain_realm]\n\t.$krb5_domain = $shortcellname" >> /etc/krb5.conf || \
		{ err_exit "Write to /etc/krb5.conf failed.  Continuing will return to the Previous Menu."; return; }
	chmod 644 /etc/krb5.conf

        if [ ! -L /etc/v5srvtab -a ! -f /etc/v5srvtab ]
        then
                log_msg DETAIL "Executing: ln -s /krb5/v5srvtab /etc/v5srvtab"
                ln -s /krb5/v5srvtab /etc/v5srvtab
        fi
}

#
#------------------------------------------------------
# check_for_krb5_client
#
# Check for active krb5 client.
# Get domain name and the fully qualified name
#   Return: 0 - Not configured
#           1 - Already configured
#   Set krb5_domain variable
#------------------------------------------------------
check_for_krb5_client ()
{

	log_msg SUMMARY "Checking for active krb5 client..."

        if [ -f /etc/resolv.conf ]
        then
            krb5_domain=`grep "domain[ |	]" /etc/resolv.conf | awk '{print $2}'`
        fi

        # If resolv.conf does not contain a domain name, then check if the env var is set.
        if [ -z "${krb5_domain}" ]
        then
            krb5_domain=${DOMAIN_NAME:="NULL"}
            until [ "${krb5_domain:="NULL"}" != "NULL" ]
            do
                    log_msg VERBOSE "User query: What is the name of the domain? "
                    echon "\tWhat is the name of the domain (ex: foo.bar.com)? "
                    read krb5_domain
                    log_msg VERBOSE "User entry: $krb5_domain"
           done
        fi
        fully_qual_host=$HOSTNAME.$krb5_domain

	# Check to see if krb5 host principal exists
	log_msg VERBOSE "Checking if krb5 host entry exists"
	log_msg DETAIL "Executing: dcecp -c principal show host/$fully_qual_host"
        dcecp -c principal show host/$fully_qual_host > /dev/null 2>&1
        if [ $? -ne 0 ]; then
		return 0
	else
		return 1
        fi
}  

#
#------------------------------------------------------
# add_service()
#
# Add an entry to /etc/services
# Syntax: add_service service port protocol alias
#------------------------------------------------------
add_service()
{
	service=$1
	port=$2
	protocol=$3
	alias=$4

	log_msg VERBOSE "Adding $service entry to /etc/services."
	PORT=`grep "$service[ |	]" /etc/services`
        if [ $? != 0 ]
	then
               	until [ -w /etc/services ]
               	do
                       	err_exit "Can not write to /etc/services.  Continuing will retry."
               	done
               	log_msg DETAIL "Executing: echo \"$service\t$port/$protocol\t\t$alias\" >> /etc/services"
               	echo "$service\t$port/$protocol\t\t$alias" >> /etc/services
	else
		PORT=`echo $PORT | cut -f1 -d"/" | cut -f2 -d" "`
		if [ "$PORT" != "$port" ]
		then
			log_msg VERBOSE "User query: A $service entry already exists in /etc/services
with a port number of $PORT.  Do you wish to
update the port number to $port (y/n)? (y) "
                        echo "A $service entry already exists in /etc/services"
                        echo "with a port number of $PORT.  Do you wish to"
                        echon "update the port number to $port (y/n)? (y) "
                        get_string
                        answer=${string:-"y"}
                        log_msg VERBOSE "User entry: $answer"
                        case $answer in
                                y)  doit=1;;
                                yes) doit=1;;
                                *)  doit=0;;
                        esac
                        if [ $doit -eq 1 ]
                        then
                                log_msg DETAIL "Executing: sed \"/$service[ |  ]/s/$PORT/$port/\"  /etc/services > /etc/services.new"
                                sed "/$service[ |      ]/s/$PORT/$port/" /etc/services \
                                > /etc/services.new
                                mv /etc/services.new /etc/services
                                chmod 644 /etc/services
                        fi
		fi
	fi
}

#
#------------------------------------------------------
# add_inetd_service()
#
# Add an entry to /etc/inetd.conf
# Syntax: add_inetd_service service socket_type protocol wait user server cmd_line
#------------------------------------------------------
add_inetd_service()
{
	service=$1
	socket_type=$2
	protocol=$3
	wait=$4
	user=$5
	server=$6
	cmd_line=$7

	log_msg VERBOSE "Adding $service entry to /etc/inetd.conf."
	SERVICE=`grep "$service[ 	]" /etc/inetd.conf`
        if [ $? != 0 ]
        then
                until [ -w /etc/inetd.conf ]
                do
                        err_exit "Can not write to /etc/inetd.conf.  Continuing will retry."
                done
                log_msg DETAIL "Executing: echo \"$service\t$socket_type\t$protocol\t$wait\t$user\t$server\t$cmd_line\" >> /etc/inetd.conf"
                echo "$service\t$socket_type\t$protocol\t$wait\t$user\t$server\t$cmd_line" >> /etc/inetd.conf
	else
		log_msg VERBOSE "$service entry already exists in /etc/inetd.conf!"
	fi
}

#
#------------------------------------------------------
# config_cdsclient()
#
# Perform the initialization required to make this machine
# a CDS client.
#	Add CDS entries to the registry database
#	Create the $DCELOCAL/cds.conf file
#	Start cdsadv
#	Ensure user is authenticated
#	Initialize the name space for this CDS client
#------------------------------------------------------
config_cdsclient()
{
	log_msg DEBUG "Executing: config_cdsclient()"

	if [ ! -f $DCELOCAL/etc/cds.conf ]
	then
		log_msg VERBOSE "Creating the cds.conf file."
		# Create the CDS configuration file cds.conf
		log_msg DETAIL "Executing: echo cds.*.security.host_princ_name: hosts/$HOSTNAME/self >> $DCELOCAL/etc/cds.conf"
		echo "cds.*.security.host_princ_name: hosts/$HOSTNAME/self" >> $DCELOCAL/etc/cds.conf
		log_msg DETAIL "Executing: echo cds.*.security.server_group_name: $SUBSYSDIR/cds-server >> $DCELOCAL/etc/cds.conf"
		echo "cds.*.security.server_group_name: $SUBSYSDIR/cds-server" >> $DCELOCAL/etc/cds.conf
		log_msg DETAIL "Executing: echo cds.*.security.admin_group_name: $SUBSYSDIR/cds-admin >> $DCELOCAL/etc/cds.conf"
		echo "cds.*.security.admin_group_name: $SUBSYSDIR/cds-admin" >> $DCELOCAL/etc/cds.conf
	fi

	ps ${PSARGS} | grep -q cdsadv
	if [ $? -eq 0 ]
	then
		err_exit "cdsadv is already running.  Continuing will return to the Main Menu."
		menu0
	fi

	# Set BIND_PE_SITE = 0 so the clerks use the real NS.

	log_msg VERBOSE "Executing: BIND_PE_SITE=0"
	BIND_PE_SITE=0
	log_msg SUMMARY "Starting cdsadv..."

	log_msg DETAIL "Executing: cdsadv"
        cdsadv

	log_msg VERBOSE "Executing: BIND_PE_SITE=1"
	BIND_PE_SITE=1

	modify_rcfile cdsadv

	# Force the user to authenticate in the cds-admin group
	log_msg DEBUG "Executing: dcelogin (from config_cdsclient)"
	dcelogin
	if [ $? != 0 ]; then
		menu0
	fi

        ns_client_init
}

#------------------------------------------------------
# ns_client_init()
#
# Create the client entries in the name space.
# Set ACLs as appropriate.
#------------------------------------------------------
ns_client_init()
{
   log_msg DEBUG "Executing: ns_client_init()"
#
#     Need to sleep for a short period of time to allow the
#     cdsadvertiser to send out a solicit request and receive
#     an advertisement back from the cds server node.  Otherwise
#     the situation can occur where the "dump clerk cache" does not
#     detect responses from cds server nodes, and dce_config
#     goes on and attempts to "create cached server" before the
#     advertiser has received an advertisement.  Not a good
#     situation.
#     The advertiser waits 15 seconds before sending out a solict.
#     A 15-second wait was insufficient, so we are using 25-seconds now.
#
   # Support configuration input via environment variables
   #
   if [ $cache_cds_server ]; then
	:;
   else
	cache_cds_server=${CACHE_CDS_SERVER:="NULL"}
   fi
   until [ ${cache_cds_server:="NULL"} != "NULL" ]
   do
	log_msg VERBOSE "User query: What is the name of a CDS server in this cell
(if there is more than one, enter the name of
the server to be cached if necessary)? "
	echo  "\tWhat is the name of a CDS server in this cell"
	echo  "\t(if there is more than one, enter the name of"
	echon "\tthe server to be cached if necessary)? "
	read cache_cds_server
	log_msg VERBOSE "User entry: $cache_cds_server"
   done

   # go ask the user about multiple lans
   ask_multiple_lans

   cache_cds_server=`echo $cache_cds_server | cut -f1 -d"." 2>/dev/null`
   if [ "$cache_cds_server" = "$HOSTNAME" ]
   then
	err_exit "Configuration of a CDS client node can not be done on a CDS server.  \
Continuing will return to the Main Menu."
	menu0
   else
	
	# Determine whether a "define cached server" command is needed.
	# "cdsadv" tries to broadcast to find a cdsd, and if found,
	# makes an entry in the clerk cache.  So if there is an entry in the
	# clerk cache for a host other than self, then a "define cached server"
	# command is not needed.  It takes between 25 (best case) and 75 (WAN/slow
	# link worst case) seconds for the cdsadv to complete this operation.
	# Since a lot of code has flowed under the bridge since we started up the cdsadv,
	# we will do some short sleeps up to a maximum of 75 seconds total, checking the
	# clerk cache between each.
	#
	found=0
	for i in $TEST15CNT; do
		log_msg DETAIL "Executing: cdscp dump clerk cache | grep $cellname >/dev/null 2>&1"
		cdscp dump clerk cache | grep $cellname >/dev/null 2>&1
		if [ $? -ne 0 ]
		then
			log_msg DEBUG "Executing: sleep 5"
			sleep 5
			continue
		else
			found=1
			break
		fi
	done
	if [ $found -eq 0 ]; then
	    log_msg DEBUG "$HOSTNAME cdsadv daemon has not received any responses to its \
broadcast for CDS servers.  Executing a \"cdscp define cached server\" command..."
		ip=`getip ${cache_cds_server}`
		if [ $? != 0 ]
		then
		    # Support configuration input via environment variables
		    #
		    ip=${CACHE_CDS_SERVER_IP:="NULL"}
		    until [ "${ip:="NULL"}" != "NULL" ]
		    do
			log_msg VERBOSE "User query: Enter the IP address of $cache_cds_server:  "
			echon "\tEnter the IP address of $cache_cds_server:  "
			read ip
			log_msg VERBOSE "User entry: $ip"
		    done
		fi
		log_msg DETAIL "Executing: cdscp define cached server $cache_cds_server tower $CONFIG_PROTSEQ:$ip"
		rm -f /tmp/cdscp_out$$
		log_msg DETAIL "Executing: cdscp define cached server $cache_cds_server \
tower $CONFIG_PROTSEQ:$ip >/tmp/cdscp_out$$"
		cdscp define cached server $cache_cds_server tower $CONFIG_PROTSEQ:$ip >/tmp/cdscp_out$$ 2>&1
		cdscp_status=$?
		chk_cdscp "cdscp - \"define cached server\" command."
	fi
	
	# Make sure that cdsadv is running
	verify_cds

	ip=`getip ${HOSTNAME}`
	if [ $? != 0 ]
	then
	    # Support configuration input via environment variables
	    #
	    ip=${HOSTNAME_IP:="NULL"}
	    until [ "${ip:="NULL"}" != "NULL" ]
	    do
		log_msg VERBOSE "User query: Enter the IP address of $HOSTNAME:  "
		echon "\tEnter the IP address of $HOSTNAME:  "
		read ip
		log_msg VERBOSE "User entry: $ip"
	    done
	fi

	log_msg VERBOSE "Creating hosts/$HOSTNAME objects in name space."

#       Generate file containing all the cdscp commands
	log_msg DETAIL "Executing cdscp commands."
	CDSTMPFILE="/tmp/config_cdstmpfile$$"
	echo "" >$CDSTMPFILE

	log_msg DETAIL "Executing: cdscp create dir /.:/hosts/$HOSTNAME"
	echo "create dir /.:/hosts/$HOSTNAME" >> $CDSTMPFILE
	log_msg DETAIL "Executing: cdscp create obj /.:/hosts/$HOSTNAME/self CDS_Class RPC_Entry CDS_ClassVersion 1.0"
	echo "create obj /.:/hosts/$HOSTNAME/self CDS_Class RPC_Entry CDS_ClassVersion 1.0" >> $CDSTMPFILE
	log_msg DETAIL "Executing: cdscp create obj /.:/hosts/$HOSTNAME/cds-clerk CDS_Class RPC_Entry CDS_ClassVersion 1.0"
	echo "create obj /.:/hosts/$HOSTNAME/cds-clerk CDS_Class RPC_Entry CDS_ClassVersion 1.0" >> $CDSTMPFILE
	log_msg DETAIL "Executing: cdscp create obj /.:/hosts/$HOSTNAME/profile CDS_Class RPC_Profile CDS_ClassVersion 1.0"
	echo "create obj /.:/hosts/$HOSTNAME/profile CDS_Class RPC_Profile CDS_ClassVersion 1.0" >> $CDSTMPFILE

	rm -f /tmp/cdscp_out$$
	cat $CDSTMPFILE | cdscp >/tmp/cdscp_out$$

	# If we are using multiple lans, go do it.
	if [ ! -z "$LAN_NAME" ]; then
	        do_multiple_lans
	fi

	# there is a window after the cdsadv is started up on a client
	# when the cache is empty.  During this window, cdscp calls can
	# fail because there is no information that allows a cdsclerk to create a
	# binding handle to a cdsd.  solution is to sleep and retry if cdscp fails
	cdscp_status=$?
	if [ $cdscp_status != 0 ]
	then
	    log_msg VERBOSE "cdscp calls failed, possibly due to empty cache.  Trying again."
	    log_msg VERBOSE "Executing: sleep 3"
	    sleep 3
	    rm -f /tmp/cdscp_out$$
	    cat $CDSTMPFILE | cdscp >/tmp/cdscp_out$$
	    cdscp_status=$?
	fi
	rm -f $CDSTMPFILE
	chk_cdscp "cdscp - configuring client entries in the name space."

	log_msg DETAIL "Executing rpccp commands."
	RPCTMPFILE="/tmp/config_rpctmpfile$$"
	echo "" >$RPCTMPFILE

	# Export the clerk DACL manager UUID
	log_msg DETAIL "Executing: rpccp export -i 000cf72e-0688-1acb-97ad-08002b12b8f8,0001.0000 \
-b $CONFIG_PROTSEQ: -o dc8c6fc0-6143-11ca-b4b9-08002b1bb4f5 -s dce /.:/hosts/$HOSTNAME/cds-clerk"
	echo "export -i 000cf72e-0688-1acb-97ad-08002b12b8f8,0001.0000 \
		-b $CONFIG_PROTSEQ: \
		-o dc8c6fc0-6143-11ca-b4b9-08002b1bb4f5 -s dce \
		/.:/hosts/$HOSTNAME/cds-clerk" >> $RPCTMPFILE


	# Export the endpoint mapper host binding
	log_msg DETAIL "Executing: rpccp export -i e1af8308-5d1f-11c9-91a4-08002b14a0fa,3.0 \
-b $CONFIG_PROTSEQ:$ip[135] \
/.:/hosts/$HOSTNAME/self"
	echo "export -i e1af8308-5d1f-11c9-91a4-08002b14a0fa,3.0 \
		-b $CONFIG_PROTSEQ:$ip[135] \
		/.:/hosts/$HOSTNAME/self" >> $RPCTMPFILE

        # Creating /.:/hosts/<hostname>/profile
	log_msg DETAIL "Executing: rpccp add_element /.:/hosts/$HOSTNAME/profile -m /.:/cell-profile -d -p 0"
	echo "add_element /.:/hosts/$HOSTNAME/profile -m /.:/cell-profile -d -p 0" >> $RPCTMPFILE

	echo "quit" >> $RPCTMPFILE

	rm -f /tmp/rpccp_out$$
	cat $RPCTMPFILE | rpccp > /tmp/rpccp_out$$
	rpccp_status=$?
	rm -f $RPCTMPFILE
	chk_rpccp "rpccp - configuring client entries in the name space."

	log_msg VERBOSE "Editing ACLs."
	acl_edit_status=0
	rm -f /tmp/acl_edit_out$$
	log_msg DETAIL "Executing: acl_edit /.:/hosts/$HOSTNAME -m user:hosts/$HOSTNAME/self:rwdtcia"
	acl_edit /.:/hosts/$HOSTNAME \
	-m user:hosts/$HOSTNAME/self:rwdtcia >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit -e /.:/hosts/$HOSTNAME/self -m user:hosts/$HOSTNAME/self:rwdtc"
	acl_edit -e /.:/hosts/$HOSTNAME/self \
	-m user:hosts/$HOSTNAME/self:rwdtc >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit -e /.:/hosts/$HOSTNAME/cds-clerk -m user:hosts/$HOSTNAME/self:rwt"
	acl_edit -e /.:/hosts/$HOSTNAME/cds-clerk \
	-m user:hosts/$HOSTNAME/self:rwt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	log_msg DETAIL "Executing: acl_edit -e /.:/hosts/$HOSTNAME/profile -m user:hosts/$HOSTNAME/self:rwt"
	acl_edit -e /.:/hosts/$HOSTNAME/profile \
	-m user:hosts/$HOSTNAME/self:rwt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ]; then
		acl_edit_status=1
	fi

	chk_acl_edit "acl_edit - modifying client ACLs in the name space."
   fi
}
#-----------------------------------------------------------
# ask_multiple_lans()
#
# This routine is called from config_basecds
# It asks the user if they are using multiple LANs
# creation is done in do_multiple_lans.
#
ask_multiple_lans()
{

	log_msg DEBUG "Executing: ask_multiple_lans()"

	# If the user has already provided this or doesn't want it, don't ask
	if [ "$MULTIPLE_LAN" = "n" ]; then
		LAN_NAME=""
		return
	fi

	if [ "$MULTIPLE_LAN" != "y" ]; then
		echo "\tCreate LAN profile so clients and servers can be divided"
		echon "\tinto profile groups for higher performance in a multi-lan cell ? (n) "
		log_msg VERBOSE "Create LAN profile so clients and servers can be divided into profile groups for higher performance in a multi-lan cell ? (n)"
		read answer
		answer=${answer:-"n"}
		log_msg VERBOSE "User entry: $answer"
		MULTIPLE_LAN="$answer"
		case $answer in
			y)   ;;
			yes) ;;
			*)   MULTIPLE_LAN="n"
			     return ;;
		esac
	fi

	if [ -z "$LAN_NAME" ]; then
		echon "\n\tWhat is the name of the LAN? "
		log_msg VERBOSE "User query: What is the name of the LAN? "
		read LAN_NAME
		log_msg VERBOSE "User entry: $LAN_NAME"
	fi
}

do_multiple_lans()
{

	log_msg DEBUG "Executing: do_multiple_lans() - LAN_NAME = $LAN_NAME"
	log_msg SUMMARY "Creating LAN profile..."

	rm -f /tmp/acl_edit_out$$
	acl_edit_status=0

	# Well known uuid
	LAN=6f264242-b9f8-11c9-ad31-08002b0dc035,0001.0000

	# create the object, even is its already there.
	log_msg DETAIL "Executing: cdscp create obj /.:/lan-$LAN_NAME-profile CDS_Class RPC_Profile"
	cdscp create obj /.:/lan-$LAN_NAME-profile CDS_Class RPC_Profile \
		CDS_ClassVersion 1.0 > /dev/null 2>&1

	log_msg DETAIL "Executing: acl_edit -e /.:/lan-$LAN_NAME-profile"
	acl_edit -e /.:/lan-$LAN_NAME-profile \
		-m group:$SUBSYSDIR/dts-admin:rwcdt \
		-m group:$SUBSYSDIR/dts-servers:rwcdt >/tmp/acl_edit_out$$ 2>&1

	if [ $? -ne 0 ];then
		acl_edit_status=1
	fi

	chk_acl_edit "Error while setting ACLs on routine do_multiple_lans."

	log_msg DETAIL "Executing: rpccp add element /.:/hosts/$HOSTNAME/profile"
	rpccp add element /.:/hosts/$HOSTNAME/profile \
		-i $LAN -m /.:/lan-$LAN_NAME-profile -a LAN -p 0 > /dev/null 2>&1

}

#-----------------------------------------------------------
# config_secreplica()
#
# This routine is reached via menu4() and will configure a security 
# replica as follows:
# 	Configure this machine as a security and cds client if necessary
#	Modify acls on required CDS name space entries
#	
#-----------------------------------------------------------
config_secreplica()
{
	log_msg DEBUG "Executing: config_secreplica()"
	# Ensure security server binaries have been installed
	if [ ! -x ${DCE_DAEMONS}/secd ]
	then
		err_exit "${DCE_DAEMONS}/secd is not installed.  \
Continuing will return to the Previous Menu."
		return
	fi

	sec_replica_name=${SEC_REPLICA:="NULL"}
	if [ "$sec_replica_name" = "NULL" ]
	then
		echo "\n"
		log_msg VERBOSE "User query: Enter the security replica name (without $SUBSYSDIR/$SECURITYDIR) ($HOSTNAME) :"
		echon "\tEnter the security replica name (without $SUBSYSDIR/$SECURITYDIR) : ($HOSTNAME)"
		read sec_replica_name
		sec_replica_name=${sec_replica_name:-"$HOSTNAME"}
		log_msg VERBOSE "User entry: $sec_replica_name"
	fi

	if [ ! -f $DCELOCAL/dce_cf.db ]
	then
		create_dcecfdb
	fi

	# Configure as a security client if sec_client service isn't running.
	check_for_sec_client_service
	rtn_status=$?
	if [ $rtn_status -eq 2 ]
	then
		err_exit "Continuing will return to the Previous Menu."
		return
	fi
	if [ $rtn_status -eq 0 ]
	then
		config_secclient
	fi

	klist | grep cds-admin >/dev/null 2>&1
	if [ $? -ne 0 ]
	then
		dcelogin
		if [ $? -ne 0 ]; then
			return
		fi
	fi
	# Configure as a CDS client if cdsadv isn't running.
	ps ${PSARGS} | grep -q cdsadv
	if [ $? -ne 0 ]
	then
		config_cdsclient
	fi

	# now configure a replica as follows

	rm -f /tmp/acl_edit_out$$
	acl_edit_status=0

	echo "\tModifying acls on /.:/$SECURITYDIR/replist ..."
	acl_edit /.:/$SECURITYDIR/replist \
	-m user:hosts/$HOSTNAME/self:imI >/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ];then
		acl_edit_status=1
	fi

	# The group acct-admin gets the same set of permissions
	# as cell_admin on replist object. The 'A' bit allows 
	# sec_admin commands to be executed.

	acl_edit /.:/$SECURITYDIR/replist \
	-m group:acct-admin:cidmA >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ];then
		acl_edit_status=1
	fi

	echo "\tModifying acls on /.:/$SUBSYSDIR/$SECURITYDIR ..."    
	acl_edit /.:/$SUBSYSDIR/$SECURITYDIR \
	-m user:hosts/$HOSTNAME/self:rwdtcia >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ];then
		acl_edit_status=1
	fi
    
	acl_edit /.:/$SUBSYSDIR/$SECURITYDIR \
	 -io -m user:hosts/$HOSTNAME/self:rwdtc >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ];then
		acl_edit_status=1
	fi

	acl_edit /.:/$SUBSYSDIR/$SECURITYDIR \
	-ic -m user:hosts/$HOSTNAME/self:rwdtci >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ];then
		acl_edit_status=1
	fi

	echo "\tModifying acls on /.:/$SECURITYDIR ..."    
	acl_edit -e /.:/$SECURITYDIR \
	-m user:hosts/$HOSTNAME/self:rwdtc >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ];then
		acl_edit_status=1
	fi

        # following two acl_edits required for pre-1.0.2 upgrades to 1.0.2
	echo "\tModifying acls on /.: ..."    
	acl_edit /.: \
        -m user:dce-rgy:rti >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ];then
		acl_edit_status=1
	fi

	echo "\tModifying acls on /.:/cell-profile ..."    
	acl_edit -e /.:/cell-profile \
        -m user:dce-rgy:rwt >>/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ];then
		acl_edit_status=1
	fi

	chk_acl_edit "Error while setting ACLs on routine config_secreplica."

	keyseed=${KEYSEED:-"NULL"}
	until [ ${keyseed:="NULL"} != "NULL" ]
	do
	    log_msg VERBOSE "User query: Enter keyseed for initial database master key: "
	    echon "\tEnter keyseed for initial database master key: "
	    stty -echo 2>/dev/null
	    read keyseed
	    stty echo 2>/dev/null
	    echo "\n"
	    log_msg VERBOSE "User entry: <not shown>"
	done

	log_msg VERBOSE "Executing: sec_create_db for sec_replica_name"
	sec_create_db -my $SUBSYSDIR/$SECURITYDIR/$sec_replica_name -keyseed $keyseed  -slave || \
		  { err_exit "sec_create_db may have failed to create security slave.  Continuing will return to the Previous Menu."; return; }

	log_msg SUMMARY "Starting slave security server (secd) ..."
	ps ${PSARGS} | grep -q secd 
	if [ $? -eq 0 ]
	then
		err_exit "secd is already running.  Continuing will return to the Previous Menu."
		return
	fi
	log_msg DETAIL "Executing: secd"
        secd
	modify_rcfile secd

	log_msg SUMMARY "Waiting for registry propagation ..."
	log_msg DETAIL "Executing: dcecp -c registry verify"
	not_uptodate=`dcecp -c registry verify`
	while [ ! -z "$not_uptodate" ] 
	do
		sleep 5
		log_msg DETAIL "Executing: dcecp -c registry verify"
		not_uptodate=`dcecp -c registry verify`
	done
}


#-----------------------------------------------------------
# dtsconfig()
#
# This routine is reached via menu3() and menu4(); configure DTS
#	Configure this machine as a security client, if necessary
#	Configure this machine as a cds client, if necessary
#	Call dts_config()
#-----------------------------------------------------------
dtsconfig()
{
	log_msg DEBUG "Executing: dtsconfig()"

	# Configure as a security client if sec client service isn't running.
	check_for_sec_client_service
	rtn_status=$?
	if [ $rtn_status -eq 2 ]
	then
		err_exit "Continuing will return to the Previous Menu."
		return
	fi
	if [ $rtn_status -eq 0 ]
	then
		config_secclient
	fi

	# Configure as a CDS client if cdsadv isn't running.
	ps ${PSARGS} | grep -q cdsadv
	if [ $? != 0 ]; then
		config_cdsclient
	fi

	dts_config
}


#-----------------------------------------------------------
# dts_rgyinit()
#
#    Add DTS entries to the registry database.
#    Re-start sec_client service, ensuring the new machine principal
#          is created for hosts/<hostname>/self.
#    Re-authenticate to ensure the new principal is obtained.
#-----------------------------------------------------------
dts_rgyinit()
{
	log_msg DEBUG "Executing: dts_rgyinit()"
	log_msg DETAIL "Executing: rgy_edit> domain group"
	log_msg DETAIL "Executing: rgy_edit> member $SUBSYSDIR/dts-servers -a hosts/$HOSTNAME/self"
	log_msg DETAIL "Executing: rgy_edit> quit"
	rm -f /tmp/rgy_edit_out$$
	rgy_edit -update >/tmp/rgy_edit_out$$ 2>&1 <<EOF
domain group
member $SUBSYSDIR/dts-servers -a hosts/$HOSTNAME/self
quit
EOF

	rgy_edit_status=$?
	chk_rgy_edit "rgy_edit - adding DTS entries."

	log_msg DETAIL "Executing: sec_client service stop"
	stop_sec_client_service

	log_msg DETAIL "Executing: sec_client service start"
	start_sec_client_service no_modify_rcfile
	if [ $? -ne 0 ]; then
		err_exit "Node identity has not been established.  There may be a problem with the \
security server, this node may have stale configuration information.  If this is a client node, \
then node may not have been unconfigured following a previous configuration.  Continuing will return \
to the Main Menu."
		menu0
	fi

	log_msg DEBUG "Executing: dcelogin (from dts_rgyinit)"
	dcelogin
	if [ $? != 0 ]; then
		menu0
	fi
}


#------------------------------------------------------
# dts_config()
#
# DTS Configuration
# This routine is reached when the machine being configured
# has entered the appropriate entries into the registry
# database and name space.  
#------------------------------------------------------
dts_config()
{
	log_msg DEBUG "Executing: dts_config()"

    while :
    do
        clear

       	LIST="1 2 3 4 98 99"
       	export LIST

	log_msg VERBOSE "User query: DTS Configuration Menu (on $HOSTNAME)"
       	echo "\n\n\n"
       	echo "\t DTS Configuration Menu"
        echo "\n"
       	echo "\t 1. DTS Local Server"
       	echo "\t 2. DTS Global Server (needed only in multi-LAN cells)"
      	echo "\t 3. DTS Clerk"
        echo "\t 4. DTS Time Provider"
       	echo "\n"
       	echo "\t98. Return to previous menu"
       	echo "\t99. Exit"
       	echo "\n\n"
       	echon "\tselection:  "

       	get_option
	
	# Allow only one selection from this menu
	one_option

       	# Note there's no need to check for an invalid option, because
       	# the get_option routine already did that.
	log_msg VERBOSE "User entry: $opt"
       	case $opt in
		1)	log_msg SUMMARY "Configuring DTS Local Server...";
			config_dtslocal;;
		2)	log_msg SUMMARY "Configuring DTS Global Server...";
			config_dtsglobal;;
              	3)	log_msg SUMMARY "Configuring DTS Clerk..."
			config_dtsclerk;;
                4)	log_msg SUMMARY "Configuring DTS Time Provider...";
			config_timeprovider;;
               	98)     return;;
               	99)     menu99;;
       	esac
    done	# until they want out
}


#------------------------------------------------------
# start_dtsd()
#
# Start dtsd daemon
# Start dtstimed daemon
#------------------------------------------------------
start_dtsd()
{
	case $1 in
		global)
			switch="-s -g"
			;;
		local) 
			switch="-s"
			;;
		clerk)
			switch="-c"
			;;
	esac

	# Ensure dtsd has already been installed
	if [ ! -x ${DCE_DAEMONS}/dtsd ]
	then
	        err_exit "${DCE_DAEMONS}/dtsd is not installed.  \
Continuing will return to the Main Menu."
	        menu0
	fi

	log_msg SUMMARY "Starting dtsd..."
	log_msg DETAIL "Executing: dtsd $switch"
	${DCE_DAEMONS}/dtsd $switch

	#
	# Make sure that the /opt/dcelocal/var/adm/time/dtsd.acl file
	# is created with 644 permissions.  It currently isn't because
	# dce_config sets the umask to 000.
	#
	chmod 644 ${DCELOCAL}/var/adm/time/dtsd.acl > /dev/null 2>&1

	# space in front of switches is important!
	modify_rcfile dtsd " $switch"

	# dtstimed emulates the adjtime system call
	# needed by dtsd to adjust the clock on hpux
	if [ "$UNAME" = "HP-UX" ]
	then
		log_msg SUMMARY "Starting dtstimed..."
		log_msg DETAIL "Executing: dtstimed"
		dtstimed
		modify_rcfile dtstimed
	fi
}


#------------------------------------------------------
# config_timeprovider()
#
#    Fire up a DTS Time Provider program.
#    The NTP provider only works if there's an
#    NTP daemon already running somewhere which
#    was started independent of this script.
#------------------------------------------------------
config_timeprovider() 
{
	log_msg DEBUG "Executing: config_timeprovider()"
	clear

        LIST="1 2 98 99"
        export LIST

	log_msg VERBOSE "User query: DTS Time Provider Menu (on $HOSTNAME)"
        echo "\n\n\n"
        echo "\tDTS Time Provider Menu (on $HOSTNAME)"
        echo "\n"
        echo "\t 1. Configure a NULL time provider"
        echo "\t 2. Configure an NTP time provider"
        echo "\n"
        echo "\t98. Return to previous menu"
        echo "\t99. Exit"
        echo "\n\n"
        echon "\tselection:  "

        get_option
        one_option
	log_msg VERBOSE "User entry: $opt"
        case $opt in
                1)	log_msg SUMMARY "Configuring a Null Time Provider...";
			config_nulltimeprovider;;
                2)	log_msg SUMMARY "Configuring an NTP Time Provider...";
			config_ntptimeprovider;;
                98)     return;;
                99)     menu99;;
        esac
}


#------------------------------------------------------
# config_nulltimeprovider()
#
# Start dts_null_provider
#------------------------------------------------------
config_nulltimeprovider()
{
	log_msg DEBUG "Executing: config_nulltimeprovider()"

	# Ensure dts_null_provider server binaries have been installed
	if [ ! -x ${DCE_DAEMONS}/dts_null_provider ]
	then
		err_exit "${DCE_DAEMONS}/dts_null_provider is not installed.  \
Continuing will return to the Previous Menu."
		return
	fi

        # Is a time provider already running on this node?
        ps ${PSARGS} | grep -q -e dts_null -e dts_ntp
        if [ $? != 0 ]; then
		log_msg SUMMARY "Starting dts_null_provider..."
		log_msg DETAIL "Executing: dts_null_provider -p $NULL_PROVIDER_POLL -i $NULL_PROVIDER_INACCURACY"
		dts_null_provider -p $NULL_PROVIDER_POLL -i $NULL_PROVIDER_INACCURACY 
		modify_rcfile dts_null_provider " -p $NULL_PROVIDER_POLL -i $NULL_PROVIDER_INACCURACY"

		log_msg VERBOSE "Executing: sleep 5"
		sleep 5
		log_msg SUMMARY "This node now has a Null time provider running."
	else
                log_msg SUMMARY "This node already has a time provider running."
	fi
}


#------------------------------------------------------
# config_ntptimeprovider()
#
# Get name of ntp server, if not already defined
# Start dts_ntp_provider
#------------------------------------------------------
config_ntptimeprovider()
{
	log_msg DEBUG "Executing: config_ntptimeprovider()"

	# Ensure dts_ntp_provider server binaries have been installed
	if [ ! -x ${DCE_DAEMONS}/dts_ntp_provider ]
	then
		err_exit "${DCE_DAEMONS}/dts_ntp_provider is not installed.  \
Continuing will return to the Previous Menu."
		return
	fi

        # Is a time provider already running on this node?
        ps ${PSARGS} | grep -q -e dts_null -e dts_ntp
        if [ $? != 0 ]; then
		ntp_host=${NTP_HOST:="NULL"}
		until [ ${ntp_host:="NULL"} != "NULL" ]; do
			log_msg VERBOSE "User query: Enter the hostname where the NTP server is running: "
			echon "\n\tEnter the hostname where the NTP server is running: "
			read ntp_host
			log_msg VERBOSE "User entry: $ntp_host"
		done

      		log_msg SUMMARY "Starting dts_ntp_provider..."
                log_msg DETAIL "Executing: dts_ntp_provider -h $ntp_host -p $NTP_PROVIDER_POLL -i $NTP_PROVIDER_INACCURACY"
                dts_ntp_provider -h $ntp_host -p $NTP_PROVIDER_POLL -i $NTP_PROVIDER_INACCURACY 
                modify_rcfile dts_ntp_provider " -h $ntp_host -p $NTP_PROVIDER_POLL -i $NTP_PROVIDER_INACCURACY"

                grep -q "daemonrunning \$DCELOCAL/bin/dts_ntp_provider" $RC_DCE 2>/dev/null
		if [ $? = 0 ]; then
			log_msg DETAIL "Executing: sed \"s:dts_ntp_provider -h.*-p.*-i.*: dts_ntp_provider \
-h $ntp_host -p $NTP_PROVIDER_POLL -i $NTP_PROVIDER_INACCURACY:\" $RC_DCE > /tmp/rc.dce.new"
			sed "s:dts_ntp_provider -h.*-p.*-i.*:dts_ntp_provider -h $ntp_host -p $NTP_PROVIDER_POLL -i $NTP_PROVIDER_INACCURACY:" \
			$RC_DCE > /tmp/rc.dce.new  && \
			{ cp /tmp/rc.dce.new $RC_DCE; rm /tmp/rc.dce.new; }
		fi

                log_msg VERBOSE "Executing: sleep 5"
		sleep 5
		log_msg SUMMARY "This node now has an NTP time provider running."
	else
                log_msg SUMMARY "This node already has a time provider running."
	fi
}


#------------------------------------------------------
# config_dtslocal()
#
# DTS Local Server Configuration
#	Initialize the registry database for DTS
#	Start dtsd
#	Use dtscp to create type server
#	Enable dts server
#------------------------------------------------------
config_dtslocal()
{
	log_msg DEBUG "Executing: config_dtslocal()"

        # Is DTS already running?
        ps ${PSARGS} | grep -q dtsd
        if [ $? != 0 ]; then
		dts_rgyinit

		start_dtsd local

		log_msg SUMMARY "This node is now a DTS local server."
        else
                log_msg SUMMARY "This node is already a DTS clerk or server."
        fi
}


#------------------------------------------------------
# config_dtsglobal()
#
# DTS Global Server Configuration
#	Initialize the registry database for DTS
#	Start dtsd
#	Use dtscp to create type server
#	Use dtscp advertise command
#------------------------------------------------------
config_dtsglobal()
{
	log_msg DEBUG "Executing: config_dtsglobal()"

        # Is DTS already running?
        ps ${PSARGS} | grep -q dtsd
        if [ $? != 0 ]; then
		dts_rgyinit

		start_dtsd global

		log_msg SUMMARY "This node is now a DTS global server."
        else
                log_msg SUMMARY "This node is already a DTS clerk or server."
        fi
}


#-----------------------------------------------------------
# config_dtsclerk()
#
#	Start dtsd
#	Use dtscp to create type clerk
#       dtscp enable
#-----------------------------------------------------------
config_dtsclerk()
{
	log_msg DEBUG "Executing: config_dtsclerk()"

        # Is DTS already running?
        ps ${PSARGS} | grep -q dtsd
        if [ $? != 0 ]; then
		start_dtsd clerk

		log_msg SUMMARY "This node is now a DTS clerk."
	else
                log_msg SUMMARY "This node is already a DTS clerk or server."
	fi
}

#-----------------------------------------------------------
#
# start_pkssd()
#
#-----------------------------------------------------------

start_pkssd()
{

	log_msg SUMMARY "Starting pkssd..."
	ps ${PSARGS} | grep -q pkssd
	if [ $? -eq 0 ]
	then
	  err_exit "pkssd is already running.  Continuing will return to the Previous Menu."
	  return
	fi

	log_msg DETAIL "Executing: pkssd"
        pkssd
	if [ $? -ne 0 ]
	then
	  err_exit "pkssd failed to start.  Continuing will return to the Previous Menu."
	  return
	fi

} # End start_pkssd()


#-----------------------------------------------------------
#
# config_pkss_clt()
#
#-----------------------------------------------------------

config_pkss_clt()
{

PKSS_CONF="/opt/dcelocal/etc/pkss.conf"

if [ -f "$PKSS_CONF" ]; then
  echo "$PKSS_CONF already exists; file not changed"
  return
fi

CDS_CELL_PROFILE="cell-profile"
SEC_SERVER_GROUP="$SUBSYSDIR/pkss-servers"

echo "*.cds.service_profile_name:	/.:/$CDS_CELL_PROFILE" > $PKSS_CONF
echo "*.security.server_group_name:	/.:/$SEC_SERVER_GROUP" >> $PKSS_CONF

chmod 644 $PKSS_CONF

} # End config_pkss_clt()


#-----------------------------------------------------------
#
# config_pkss_svr()
#
#-----------------------------------------------------------

config_pkss_svr()
{

#
# Setup symbolic names for PKSS configuration values
#

PKSS_CONF="/opt/dcelocal/etc/pkss.conf"
PKSS_CELL_PROFILE="cell-profile"
PKSS_SVR_BINDINGS="hosts/$HOSTNAME/pkss"
PKSS_SVC_GROUP="$SUBSYSDIR/pkssd"
PKSS_SVR_GROUP="$SUBSYSDIR/pkss-servers"
PKSS_SVR_PRINC="hosts/$HOSTNAME/pkssd"
PKSS_SVR_ADMIN_GROUP="$SUBSYSDIR/sec-admin"
PKSS_DB_DIR="$DCELOCAL/var/security/pkss"
PKSS_DB_PATH="$PKSS_DB_DIR/pkssdb"

#
# Construct PKSS server configuration file
#

log_msg DETAIL "Creating PKSS server configuration file..."

if [ -f "$PKSS_CONF" ]; then
  rm -f $PKSS_CONF
fi

echo "*.cds.service_profile_name:	/.:/$PKSS_CELL_PROFILE" > $PKSS_CONF
echo "pkssd.cds.server_bindings_name:	/.:/$PKSS_SVR_BINDINGS" >> $PKSS_CONF
echo "pkssd.cds.service_group_name:	/.:/$PKSS_SVC_GROUP" >> $PKSS_CONF
echo "*.security.server_group_name:	/.:/$PKSS_SVR_GROUP" >> $PKSS_CONF
echo "pkssd.security.server_princ_name:	/.:/$PKSS_SVR_PRINC" >> $PKSS_CONF
echo "pkssd.security.server_admin_group_name: $PKSS_SVR_ADMIN_GROUP" >> $PKSS_CONF
echo "pkssd.local.database_filename:	$PKSS_DB_PATH" >> $PKSS_CONF
chmod 644 $PKSS_CONF

#
# Create a directory for the PKSS database
#

log_msg DETAIL "Creating PKSS server database directory..."
if [ ! -d $PKSS_DB_DIR ]
then
   mkdir -p $PKSS_DB_DIR
fi
chmod 0600 $PKSS_DB_DIR

log_msg DETAIL "Executing: rgy_edit to add PKSS group/principal"
rgy_edit -update >/tmp/rgy_edit_out$$ 2>&1 <<EOF
domain group
add $PKSS_SVR_GROUP
domain principal
add $PKSS_SVR_PRINC
domain account
add $PKSS_SVR_PRINC -g $PKSS_SVR_GROUP -o none -pw $cellpw -mp $cellpw
ktadd -p $PKSS_SVR_PRINC -pw $cellpw
ktadd -p $PKSS_SVR_PRINC -a -r
quit
EOF

rgy_edit_status=$?
chk_rgy_edit "rgy_edit - adding PKSS group/prinicpal"

log_msg DETAIL "Executing: cdscp to add PKSS cds entries"
cdscp >/tmp/cdscp_out$$ 2>&1 <<EOF
create object /.:/$PKSS_SVC_GROUP
EOF


#
# Set the acls for cell-profile
#
log_msg DETAIL "Executing: acl_edit -e /.:/$PKSS_CELL_PROFILE -m group:$PKSS_SVR_GROUP:rwt"
acl_edit -e /.:/$PKSS_CELL_PROFILE -m group:$PKSS_SVR_GROUP:rwt
if [ $? -ne 0 ]; then
  err_exit "Cannot modify /.:/$PKSS_CELL_PROFILE acl.  Continuing will return \
to the previous menu."
  return
fi


log_msg DETAIL "Executing: acl_edit -e /.:/$PKSS_SVC_GROUP -m group:$PKSS_SVR_GROUP:rwt"
acl_edit -e /.:/$PKSS_SVC_GROUP -m group:$PKSS_SVR_GROUP:rwt
if [ $? -ne 0 ]; then
  err_exit "Cannot modify /.:/$PKSS_SVC_GROUP acl.  Continuing will return \
to the previous menu."
  return
fi

log_msg DETAIL "Executing: acl_edit -e /.:/hosts/$HOSTHAME -m user:$PKSS_SVR_PRINC:ri"
acl_edit /.:/hosts/$HOSTNAME -m user:$PKSS_SVR_PRINC:rti
if [ $? -ne 0 ]; then
  err_exit "Cannot modify /.:/hosts/$HOSTNAME acl.  Continuing will return \
to the previous menu."
  return
fi

modify_rcfile pkssd

start_pkssd

} # End config_pkss_svr()



#-----------------------------------------------------------
# config_client()
#
# This routine configures the DCE client.
#      Ensure DCE client binaries are installed
#      if secd isn't running,
#           configure this machine as a security client
#      if cdsd isn't running,
#           configure this machine as a CDS client
#      Optionally, configure this machine as a DFS client.
#-----------------------------------------------------------
config_client()
{
   log_msg DEBUG "Executing: config_client()"

   # Ensure binaries have been installed
   if [ ! -x ${DCE_DAEMONS}/cdsadv ]
   then
           err_exit "${DCE_DAEMONS}/cdsadv is not installed.  \
Continuing will return to the Main Menu."
           return
   fi

   # Ensure libdce.a is installed on this node. If it
   # isn't, force the user to do an install_common()
   if [ ! -f $DCELOCAL/$SHLIB_RDN/libdce${SHLIB_SUF} -a ! -f $DCELOCAL/lib/libdce.a ]
   then
	err_exit "The DCE Client installation must be run prior to client configuration. \
Continuing will return to the Main Menu."
	return
   else

        # Configure PKSS client if necessary (see config_pkss_clt)
	if [ -f $DCELOCAL/bin/pkss_helper -o -f $DCELOCAL/bin/pkssd ]
	then
		config_pkss_clt
	fi

	# Is this a security server?
	ps ${PSARGS} | grep -q secd
	if [ $? != 0 ]
	then
		# This configuration is needed because this node
		# is not running the secd daemon, so isn't a security server
		# Is this node already a security client?
	        check_for_sec_client_service
		rtn_status=$?
		if [ $rtn_status -eq 2 ]
		then
  		  err_exit "Continuing will return to the Previous Menu."
		  return
		fi
		if [ $rtn_status -eq 0 ]
		then
		  config_secclient
		  log_msg SUMMARY "This node is now a security client."
		else
		  log_msg SUMMARY "This node is already a security client."
		fi
	else
		log_msg SUMMARY "This node is a security server."
	fi

	# Is this a CDS server?
	ps ${PSARGS} | grep -q cdsd
	if [ $? != 0 ]
	then
		# Configure this node as a CDS client if cdsadv isn't running
		ps ${PSARGS} | grep -q cdsadv
		if [ $? != 0 ]; then
			config_cdsclient
			log_msg SUMMARY "This node is now a CDS client."
		else
			log_msg SUMMARY "This node is already a CDS client."
		fi
	else
		log_msg SUMMARY "This node is a CDS server."
	fi

	# Has DTS been configured?
	ps ${PSARGS} | grep -q dtsd
	if [ $? -ne 0 ]
	then
		if [ -z "$DTS_CONFIG" ]
		then
			echon "\tShould this machine be configured as a "
			echo "DTS Clerk, DTS Local Server, "
			echo "\tor DTS Global Server? (Default is DTS Clerk) "
			echon "\t(clerk, local, global, none) "
			log_msg VERBOSE "User query: Should this machine be configured as a DTS Clerk, DTS Local Server, or DTS Global Server?"
			read answer
			DTS_CONFIG=${answer:-clerk}
			log_msg VERBOSE "User entry: $answer"
		fi
		case $DTS_CONFIG in
			clerk)	config_dtsclerk;;
			local)	config_dtslocal;;
			global)	config_dtsglobal;;
			none) 	;;
		esac

	else
		log_msg SUMMARY "This node already has DTS configured."
	fi

    fi
}

#-----------------------------------------------------------
# dfs_config_call()
#
# Checks for existence of dfs_config script.
# If it exists, calls the script with parameters.
# If it doesn't exist, displays appropriate message.
# In either case, returns to caller.
#-----------------------------------------------------------
dfs_config_call()
{
	dfs_params=$1
	log_msg DEBUG "Executing: dfs_config_call($dfs_params)"
	if [ -f ${ETC}/dfs_config ]; then
		${ETC}/dfs_config $dfs_params
		return 0
	else
		err_exit "DFS is not available for installation and cannot be configured."
		return 1
	fi
}

#-----------------------------------------------------------
# check_app_prereqs()
#
# This routine configures the DCE client.
#      Ensure DCE client binaries are installed
#      if secd isn't running,
#           configure this node as a security client
#      if cdsd isn't running,
#           configure this node as a CDS client
#-----------------------------------------------------------
check_app_prereqs()
{
	log_msg DEBUG "Executing: check_app_prereqs()"
	# Ensure libdce.a is installed on this machine. If it
	# isn't, force the user to do an install_common()
        if [ ! -f $DCELOCAL/$SHLIB_RDN/libdce${SHLIB_SUF} -a ! -f $DCELOCAL/lib/libdce.a ]
	then
		err_exit "The DCE Client installation must be run prior to client configuration.  Continuing will \
return to the Main Menu."
                menu0
	else

		# Is this a security server?
		ps ${PSARGS} | grep -q secd
		if [ $? != 0 ]; then
			# This configuration is needed because this machine is
			# not running the secd daemon, so it isn't a sec server
			# Is this machine already a security client?
		        check_for_sec_client_service
			rtn_status=$?
			if [ $rtn_status -eq 2 ]
			then
  			  err_exit "Continuing will return to the Main Menu."
			  menu0
			fi
			if [ $rtn_status -eq 0 ]
			then
			  config_secclient
			  log_msg SUMMARY "This node is now a security client."
			else
			  log_msg SUMMARY "This node is already a security client."
			fi
		fi

		# Is this a CDS server?
		ps ${PSARGS} | grep -q cdsd
		if [ $? != 0 ]; then
			# Configure this machine as a CDS client
			# if cdsadv isn't running
			ps ${PSARGS} | grep -q cdsadv
			if [ $? != 0 ]; then
				config_cdsclient
				log_msg SUMMARY "This node is now a CDS client."
			fi
		fi
	fi
}

#------------------------------------------------------
# set_cell_name()
#
# Sets and exports cellname, shortcellname variables.  
# Invoked at start of this script, and whenever dce_cf.db
# is updated.
# 
#------------------------------------------------------
set_cell_name()
{
	if [ -f $DCELOCAL/dce_cf.db ]
	then
		cellname=`$DCELOCAL/bin/getcellname`
        	shortcellname=`echo $cellname | cut -c6-`
		export cellname shortcellname
	fi

}

#------------------------------------------------------
# ns_addserver_init()
#
# Initialize the name service to reflect additional
# CDS server.  All required directories and objects are 
# created in the name space.  ACLs are set on the objects, 
# as appropriate.
#------------------------------------------------------
ns_addserver_init()
{
	# Add CDS Server principals to this node
	log_msg VERBOSE "Adding CDS Server principals to this node."
	log_msg DETAIL "Executing: rgy_edit> domain principal"
	log_msg DETAIL "Executing: rgy_edit> add hosts/$HOSTNAME/cds-server"
	log_msg DETAIL "Executing: rgy_edit> domain account"
	log_msg DETAIL "Executing: rgy_edit> add hosts/$HOSTNAME/cds-server \
-g $SUBSYSDIR/cds-server -o none -pw <not shown> -mp <not shown>"
	log_msg DETAIL "Executing: rgy_edit> quit"
	rm -f /tmp/rgy_edit_out$$
	rgy_edit -update >/tmp/rgy_edit_out$$ 2>&1 <<EOF
domain principal
add hosts/$HOSTNAME/cds-server
domain account
add hosts/$HOSTNAME/cds-server -g $SUBSYSDIR/cds-server -o none -pw $cellpw -mp $cellpw
quit
EOF

	rgy_edit_status=$?
	chk_rgy_edit "rgy_edit - adding CDS Server principals."

	# If there are security replicas, we must wait till they are
	# up to date before doing keytab update.
	log_msg DETAIL "Executing: verify_consistency()"
	verify_consistency
	if [ "$?" -ne 0 ]; then
		log_msg VERBOSE "Security server replicas are not consistent \
with the master.  Some servers may be stopped or otherwise unavailable.  This \
is ok since the running servers are consistent, however, there \
exists the unlikely possibility that ktadd may bind to a server that has come \
back up between the time when the \"dcecp registry verify\" command was \
executed and before the ktadd command itself is executed.  The server that \
ktadd is bound to may not yet be consistent with the master server, and if \
this is the case then you must UNCONFIGURE and REMOVE this node from the \
cell before reconfiguring.  Check the output from the rgy_edit command \
immediately following the ktadd commands."
	fi

	log_msg DETAIL "Executing: rgy_edit> ktadd -p hosts/$HOSTNAME/cds-server -pw <not shown>"
	log_msg DETAIL "Executing: rgy_edit> ktadd -p hosts/$HOSTNAME/cds-server -a -r"
	rgy_edit -update >/tmp/rgy_edit_out$$ 2>&1 <<EOF
ktadd -p hosts/$HOSTNAME/cds-server -pw $cellpw
ktadd -p hosts/$HOSTNAME/cds-server -a -r
quit
EOF
	rgy_edit_status=$?
	chk_rgy_edit "rgy_edit - Adding CDS server keytab."

	log_msg SUMMARY "Initializing the name space for additional CDS server..."
	# Create/Export the server DACL manager UUID
	rm -f /tmp/rpccp_out$$
	rpccp_status=0
	log_msg DETAIL "Executing: rpccp export -i 4ea31de8-9a94-11c9-bb60-08002b0f79aa,0003.0000  \
                -b $CONFIG_PROTSEQ:  \
                -o faf2e540-58b8-11ca-a04a-08002b12a70d -s dce  \
                /.:/hosts/$HOSTNAME/cds-server > /tmp/rpccp_out$$"
	rpccp export -i 4ea31de8-9a94-11c9-bb60-08002b0f79aa,0003.0000 \
		-b $CONFIG_PROTSEQ: \
		-o faf2e540-58b8-11ca-a04a-08002b12a70d -s dce \
		/.:/hosts/$HOSTNAME/cds-server > /tmp/rpccp_out$$
	rpccp_status=$?
	chk_rpccp "rpccp - initializing the name service"

	rm -f /tmp/acl_edit_out$$
	acl_edit_status=0
	echo "\tModifying acls on /.:/hosts/$HOSTNAME/cds-server"
	log_msg DETAIL "Exectuing: acl_edit -e /.:/hosts/$HOSTNAME/cds-server  -m user:hosts/$HOSTNAME/self:rwt"
	acl_edit -e /.:/hosts/$HOSTNAME/cds-server \
	-m user:hosts/$HOSTNAME/self:rwt >/tmp/acl_edit_out$$ 2>&1
	if [ $? -ne 0 ];then
		acl_edit_status=1
	fi

	chk_acl_edit "Error while setting ACLs on routine ns_addserver_init."
}

#------------------------------------------------------
# config_audit()
#
# Configure audit subsystem
#------------------------------------------------------
config_audit()
{
	log_msg DEBUG "Executing: config_audit()"

	# Ensure binaries have been installed
	if [ ! -x ${DCE_DAEMONS}/auditd ]
	then
		err_exit "${DCE_DAEMONS}/auditd is not installed.  \
Continuing will return to the Previous Menu."
		return
	fi

	ps ${PSARGS} | grep -q auditd
	if [ $? -eq 0 ]
	then
		err_exit "Audit daemon is already running on this node. \
Continuing will return to the Previous Menu."
		return
	fi

	log_msg DETAIL "Executing: auditd -a"
        ${DCE_DAEMONS}/auditd -a
	modify_rcfile auditd " -a"

	log_msg SUMMARY "Creating default filters for security, dts, and audit."

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_sec_modify success log}"
        dcecp -c audfilter create world -at {dce_sec_modify success log}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_sec_modify {failure denial} all}"
        dcecp -c audfilter create world -at {dce_sec_modify {failure denial} all}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_sec_server success log}"
        dcecp -c audfilter create world -at {dce_sec_server success log}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_sec_server {failure denial} all}"
        dcecp -c audfilter create world -at {dce_sec_server {failure denial} all}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_sec_authent {failure denial} all}"
        dcecp -c audfilter create world -at {dce_sec_authent {failure denial} all}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_sec_query denial all}"
        dcecp -c audfilter create world -at {dce_sec_query denial all}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_dts_mgt_modify success log}"
        dcecp -c audfilter create world -at {dce_dts_mgt_modify success log}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_dts_mgt_modify {failure denial} all}"
        dcecp -c audfilter create world -at {dce_dts_mgt_modify {failure denial} all}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_dts_mgt_query {failure denial} all}"
        dcecp -c audfilter create world -at {dce_dts_mgt_query {failure denial} all}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_audit_admin_modify success log}"
        dcecp -c audfilter create world -at {dce_audit_admin_modify success log}
	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_audit_admin_modify {failure denial} all}"
        dcecp -c audfilter create world -at {dce_audit_admin_modify {failure denial} all}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_audit_filter_modify success log}"
        dcecp -c audfilter create world -at {dce_audit_filter_modify success log}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_audit_filter_modify {failure denial} all}"
        dcecp -c audfilter create world -at {dce_audit_filter_modify {failure denial} all}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_audit_admin_query {failure denial} all}"
        dcecp -c audfilter create world -at {dce_audit_admin_query {failure denial} all}

	log_msg DETAIL "Executing: dcecp -c audfilter create world -at {dce_audit_filter_query {failure denial} all}"
        dcecp -c audfilter create world -at {dce_audit_filter_query {failure denial} all}

}

#------------------------------------------------------
# config_pwd_mgmt()
#
# Configure password management server
# with "-unconfig", unconfigures server
#------------------------------------------------------
config_pwd_mgmt()
{
    option=$1
    log_msg DEBUG "Executing: config_pwd_mgmt(${option})"

    if [ -z "${option}" ]; then
        ps ${PSARGS} | grep -q `basename ${PWD_MGMT_SVR}`
        if [ $? -eq 0 ]
        then
            err_exit "Password Management Server is already running on this node.  \
Continuing will return to the Previous Menu."
            return
        fi
    fi

    if [ ! -x ${DCE_BIN}/pwd_config -o ! -x ${DCE_DAEMONS}/pwd_strengthd ]; then
        err_exit "\"${DCE_BIN}/pwd_config\" is not available or is not executable, \
or \"${DCE_DAEMONS}/pwd_strengthd\" is not available.  Continuing will return to the Previous Menu."
        return
    else
        log_msg DEBUG "Executing: ${DCE_BIN}/pwd_config ${option}"
        ${DCE_BIN}/pwd_config ${option}
	return $?
    fi
}

#------------------------------------------------------
# MAIN program
# main()
#
# Execute menu0.  From there, receive user input as
# to which operation is desired, and continue until
# the user requests to exit.
#------------------------------------------------------
ROUTINE="menu0"

# Use a feature of dce_login that allows authentication from a shell script
if [ -f /usr/bin/dce_login -a ! -f /usr/bin/dce_login_noexec ]
then
	    ln -s /usr/bin/dce_login /usr/bin/dce_login_noexec >/dev/null 
fi

if [ ! -z "${COMMAND_FILE}" ]
then
	set_cell_name
	. ${COMMAND_FILE}
else
	$ROUTINE
fi

menu99

exit 0

