/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 */
/*
 * HISTORY
 * $Log: ederoot.c,v $
 * Revision 1.1.82.1  1996/10/02  17:17:07  damon
 * 	Newest DFS from Transarc
 * 	[1996/10/01  18:27:02  damon]
 *
 * Revision 1.1.76.3  1994/07/13  22:21:37  devsrc
 * 	merged with bl-10
 * 	[1994/06/28  20:31:47  devsrc]
 * 
 * 	Changed #include with double quotes to #include with angle brackets.
 * 	[1994/04/28  15:55:59  mbs]
 * 
 * Revision 1.1.76.2  1994/06/09  13:57:24  annie
 * 	fixed copyright in src/file
 * 	[1994/06/08  21:32:29  annie]
 * 
 * Revision 1.1.76.1  1994/02/04  20:11:06  devsrc
 * 	Merged from 1.0.3a to 1.1
 * 	[1994/02/04  15:09:03  devsrc]
 * 
 * Revision 1.1.74.1  1993/12/07  17:16:55  jaffe
 * 	1.0.3a update from Transarc
 * 	[1993/12/03  13:39:43  jaffe]
 * 
 * Revision 1.1.4.4  1993/01/18  22:03:05  cjd
 * 	embedded copyright notice
 * 	[1993/01/18  21:42:37  cjd]
 * 
 * Revision 1.1.4.3  1992/11/24  16:19:46  bolinger
 * 	Change include file install directory from .../afs to .../dcedfs.
 * 	[1992/11/22  16:17:42  bolinger]
 * 
 * Revision 1.1.4.2  1992/08/31  18:33:30  jaffe
 * 	fixed header file.
 * 	[1992/08/30  13:06:13  jaffe]
 * 
 * Revision 1.1.2.2  1992/05/05  20:40:38  jdp
 * 	delta jdp-epimerge-1.0-to-1.0.1b9-into-2.17 1.20
 * 	[1992/05/04  20:18:09  jdp]
 * 
 * Revision 1.1  1992/01/19  02:37:08  devrcs
 * 	Initial revision
 * 
 * $EndLog$
 */
/* Copyright (C) 1993, 1990 Transarc Corporation - All rights reserved. */

/* Routines defining the locations of the duplicate Episode super-blocks. */

#include <stdio.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>

#define VICE
#include <dcedfs/param.h>

#include <dcedfs/stds.h>
#include <dcedfs/osi.h>
#include <dcedfs/debug.h>

#include <boot.h>

#if !defined(KERNEL) 
#include <pthread.h>
#endif /* !KERNEL */

RCSID("$Header: /u0/rcs_trees/dce/rcs/file/episode/anode/ederoot.c,v 1.1.82.1 1996/10/02 17:17:07 damon Exp $")

#define numSBLocs (sizeof(edsk_superBlockLocations) / sizeof(edsk_superBlockLocations[0]))

/* edsk_NumSuperBlocks -- Returns the number of superblocks that will be
 *     written on a device if there are \arg{Chunks} 64K blocks on that device.
 *     See also \fcn{edsk_FillSuperBlockArray}. */

EXPORT int edsk_NumSuperBlocks (Chunks)
  IN u_long Chunks;
{
    int cks;

    for (cks = 1; cks < EDSK_MAXNSUPERBLOCKS; ++cks) {
	if (edsk_superBlockLocations[cks] >= Chunks) break;
    }
    /* if out because cks >= EDSK_MAXNSUPERBLOCKS, it will == EDSK_MAXNSUPERBLOCKS,
	so that's the number of possible chunks */
    /* if out because edsk_superBlockLocations[cks] >= Chunks, then indices 0..(cks-1) are OK,
	  so number of chunks is still ``cks'' */
    /* This procedure will, though, gratuitously return 1 rather than 0. */
    return (cks);
}

/* edsk_FillSuperBlockArray -- Determines which superblock locations to use in
 *     an Episode aggregate that has \arg{numChunks} (in units of 64Kb) on
 *     the specified device. The array \arg{Arr} is filled in with at most
 *     \arg{maxCount} superblock locations (also in units of 64Kb).  The
 *     return value is the number of locations copied into \arg{Arr}. */

EXPORT int edsk_FillSuperBlockArray (numChunks, Arr, maxCount)
  IN u_long numChunks;
  OUT u_long Arr[];
  IN int maxCount;
{
    int ix;
    int SBix;
#if 0
    int subix;
    u_long Trial;
    /* Generated by the sequence R(n+1) = (R(n) * 314159269 + 271828182) % 2147483647 */
    static u_long SuperBlockSeeds[] = {
	1, 585987451, 1694768393, 739822354, 306216111, 345963918,
	1671501635, 453247644, 440693972, 1739623704, 2072147305,
	687089414, 1975044757, 1819970278, 1455555949, 24271105,
	458819, 1263601206, 599559567, 429829567, 733187090,
	782242290, 745135112, 268134202, 1668658981, 457578197,
	1375557701, 1158195976, 926998231, 1974172865, 405778180,
	883957074, 366362128, 1790350248, 1902701575, 1790901425,
	1217202637, 1402608463, 1000317619, 1879483415, 407751407,
	773919588, 450729595, 558593181, 978700142, 94347075,
	1003558369, 123387053, 863944234, 1266924773, 1954744220,
	1185570719, 268316551, 2023434490, 984602221, 1850656351,
	1780812299, 141885275, 1663738666, 918006356, 543392229,
	1457383479, 1465153931, 359611681, 1558747150, 1180492705,
	573918969, 1540160175, 730769364, 1830482014, 1203069626,
	1927532472, 1486740339, 1843595075, 2114181584, 137200128
    };
#define numDefinedSBSeeds (sizeof(SuperBlockSeeds) / sizeof(SuperBlockSeeds[0]))

    if (numChunks == 0) return -1;
    SBix = -1;
    for (ix = 0; ix < maxCount; ++ix) {
	for (;;) {	/* until we get something to populate Arr[ix] */
	    ++SBix;
	    if (SBix >= numDefinedSBSeeds) return ix;	/* have to return a short count */
	    Trial = (SuperBlockSeeds[SBix] % numChunks);
	    if (Trial >= 1) {		/* allow room for any firstBlock stuff */
		for (subix = 0; subix < ix; ++subix) {
		    if (Arr[subix] == Trial) break;
		}
		if (subix >= ix) {  /* wasn't a duplicate */
		    Arr[ix] = Trial;
		    break;		/* to continue to the next ``ix'' value */
		}
	    }
	}
    }
    return maxCount;
#else /* 0 */
    if (numChunks == 0) return -1;
    if (maxCount > EDSK_MAXNSUPERBLOCKS) maxCount = EDSK_MAXNSUPERBLOCKS;
    SBix = 0;
    for (ix = 0; ix < maxCount; ++ix) {
	if (edsk_superBlockLocations[ix] == 0) break;
	if (edsk_superBlockLocations[ix] >= numChunks) break;
	Arr[ix] = edsk_superBlockLocations[ix];
	++SBix;
    }
    return SBix;
#endif /* 0 */
}

